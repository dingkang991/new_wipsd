
libubox.so：     文件格式 elf64-x86-64


Disassembly of section .init:

00000000000022f8 <_init>:
    22f8:	48 83 ec 08          	sub    $0x8,%rsp
    22fc:	48 8b 05 bd 5c 20 00 	mov    0x205cbd(%rip),%rax        # 207fc0 <_DYNAMIC+0x1e0>
    2303:	48 85 c0             	test   %rax,%rax
    2306:	74 05                	je     230d <_init+0x15>
    2308:	e8 d3 04 00 00       	callq  27e0 <vlist_flush@plt+0x10>
    230d:	48 83 c4 08          	add    $0x8,%rsp
    2311:	c3                   	retq   

Disassembly of section .plt:

0000000000002320 <blob_check_type@plt-0x10>:
    2320:	ff 35 e2 5c 20 00    	pushq  0x205ce2(%rip)        # 208008 <_GLOBAL_OFFSET_TABLE_+0x8>
    2326:	ff 25 e4 5c 20 00    	jmpq   *0x205ce4(%rip)        # 208010 <_GLOBAL_OFFSET_TABLE_+0x10>
    232c:	0f 1f 40 00          	nopl   0x0(%rax)

0000000000002330 <blob_check_type@plt>:
    2330:	ff 25 e2 5c 20 00    	jmpq   *0x205ce2(%rip)        # 208018 <_GLOBAL_OFFSET_TABLE_+0x18>
    2336:	68 00 00 00 00       	pushq  $0x0
    233b:	e9 e0 ff ff ff       	jmpq   2320 <_init+0x28>

0000000000002340 <safe_list_for_each@plt>:
    2340:	ff 25 da 5c 20 00    	jmpq   *0x205cda(%rip)        # 208020 <_GLOBAL_OFFSET_TABLE_+0x20>
    2346:	68 01 00 00 00       	pushq  $0x1
    234b:	e9 d0 ff ff ff       	jmpq   2320 <_init+0x28>

0000000000002350 <ustream_vprintf@plt>:
    2350:	ff 25 d2 5c 20 00    	jmpq   *0x205cd2(%rip)        # 208028 <_GLOBAL_OFFSET_TABLE_+0x28>
    2356:	68 02 00 00 00       	pushq  $0x2
    235b:	e9 c0 ff ff ff       	jmpq   2320 <_init+0x28>

0000000000002360 <free@plt>:
    2360:	ff 25 ca 5c 20 00    	jmpq   *0x205cca(%rip)        # 208030 <_GLOBAL_OFFSET_TABLE_+0x30>
    2366:	68 03 00 00 00       	pushq  $0x3
    236b:	e9 b0 ff ff ff       	jmpq   2320 <_init+0x28>

0000000000002370 <abort@plt>:
    2370:	ff 25 c2 5c 20 00    	jmpq   *0x205cc2(%rip)        # 208038 <_GLOBAL_OFFSET_TABLE_+0x38>
    2376:	68 04 00 00 00       	pushq  $0x4
    237b:	e9 a0 ff ff ff       	jmpq   2320 <_init+0x28>

0000000000002380 <__errno_location@plt>:
    2380:	ff 25 ba 5c 20 00    	jmpq   *0x205cba(%rip)        # 208040 <_GLOBAL_OFFSET_TABLE_+0x40>
    2386:	68 05 00 00 00       	pushq  $0x5
    238b:	e9 90 ff ff ff       	jmpq   2320 <_init+0x28>

0000000000002390 <strcpy@plt>:
    2390:	ff 25 b2 5c 20 00    	jmpq   *0x205cb2(%rip)        # 208048 <_GLOBAL_OFFSET_TABLE_+0x48>
    2396:	68 06 00 00 00       	pushq  $0x6
    239b:	e9 80 ff ff ff       	jmpq   2320 <_init+0x28>

00000000000023a0 <sigaction@plt>:
    23a0:	ff 25 aa 5c 20 00    	jmpq   *0x205caa(%rip)        # 208050 <_GLOBAL_OFFSET_TABLE_+0x50>
    23a6:	68 07 00 00 00       	pushq  $0x7
    23ab:	e9 70 ff ff ff       	jmpq   2320 <_init+0x28>

00000000000023b0 <safe_list_add_first@plt>:
    23b0:	ff 25 a2 5c 20 00    	jmpq   *0x205ca2(%rip)        # 208058 <_GLOBAL_OFFSET_TABLE_+0x58>
    23b6:	68 08 00 00 00       	pushq  $0x8
    23bb:	e9 60 ff ff ff       	jmpq   2320 <_init+0x28>

00000000000023c0 <setsockopt@plt>:
    23c0:	ff 25 9a 5c 20 00    	jmpq   *0x205c9a(%rip)        # 208060 <_GLOBAL_OFFSET_TABLE_+0x60>
    23c6:	68 09 00 00 00       	pushq  $0x9
    23cb:	e9 50 ff ff ff       	jmpq   2320 <_init+0x28>

00000000000023d0 <blob_fill_pad@plt>:
    23d0:	ff 25 92 5c 20 00    	jmpq   *0x205c92(%rip)        # 208068 <_GLOBAL_OFFSET_TABLE_+0x68>
    23d6:	68 0a 00 00 00       	pushq  $0xa
    23db:	e9 40 ff ff ff       	jmpq   2320 <_init+0x28>

00000000000023e0 <blob_new@plt>:
    23e0:	ff 25 8a 5c 20 00    	jmpq   *0x205c8a(%rip)        # 208070 <_GLOBAL_OFFSET_TABLE_+0x70>
    23e6:	68 0b 00 00 00       	pushq  $0xb
    23eb:	e9 30 ff ff ff       	jmpq   2320 <_init+0x28>

00000000000023f0 <fcntl@plt>:
    23f0:	ff 25 82 5c 20 00    	jmpq   *0x205c82(%rip)        # 208078 <_GLOBAL_OFFSET_TABLE_+0x78>
    23f6:	68 0c 00 00 00       	pushq  $0xc
    23fb:	e9 20 ff ff ff       	jmpq   2320 <_init+0x28>

0000000000002400 <clock_gettime@plt>:
    2400:	ff 25 7a 5c 20 00    	jmpq   *0x205c7a(%rip)        # 208080 <_GLOBAL_OFFSET_TABLE_+0x80>
    2406:	68 0d 00 00 00       	pushq  $0xd
    240b:	e9 10 ff ff ff       	jmpq   2320 <_init+0x28>

0000000000002410 <avl_insert@plt>:
    2410:	ff 25 72 5c 20 00    	jmpq   *0x205c72(%rip)        # 208088 <_GLOBAL_OFFSET_TABLE_+0x88>
    2416:	68 0e 00 00 00       	pushq  $0xe
    241b:	e9 00 ff ff ff       	jmpq   2320 <_init+0x28>

0000000000002420 <write@plt>:
    2420:	ff 25 6a 5c 20 00    	jmpq   *0x205c6a(%rip)        # 208090 <_GLOBAL_OFFSET_TABLE_+0x90>
    2426:	68 0f 00 00 00       	pushq  $0xf
    242b:	e9 f0 fe ff ff       	jmpq   2320 <_init+0x28>

0000000000002430 <avl_init@plt>:
    2430:	ff 25 62 5c 20 00    	jmpq   *0x205c62(%rip)        # 208098 <_GLOBAL_OFFSET_TABLE_+0x98>
    2436:	68 10 00 00 00       	pushq  $0x10
    243b:	e9 e0 fe ff ff       	jmpq   2320 <_init+0x28>

0000000000002440 <avl_find@plt>:
    2440:	ff 25 5a 5c 20 00    	jmpq   *0x205c5a(%rip)        # 2080a0 <_GLOBAL_OFFSET_TABLE_+0xa0>
    2446:	68 11 00 00 00       	pushq  $0x11
    244b:	e9 d0 fe ff ff       	jmpq   2320 <_init+0x28>

0000000000002450 <vlist_delete@plt>:
    2450:	ff 25 52 5c 20 00    	jmpq   *0x205c52(%rip)        # 2080a8 <_GLOBAL_OFFSET_TABLE_+0xa8>
    2456:	68 12 00 00 00       	pushq  $0x12
    245b:	e9 c0 fe ff ff       	jmpq   2320 <_init+0x28>

0000000000002460 <runqueue_cancel_active@plt>:
    2460:	ff 25 4a 5c 20 00    	jmpq   *0x205c4a(%rip)        # 2080b0 <_GLOBAL_OFFSET_TABLE_+0xb0>
    2466:	68 13 00 00 00       	pushq  $0x13
    246b:	e9 b0 fe ff ff       	jmpq   2320 <_init+0x28>

0000000000002470 <uloop_process_delete@plt>:
    2470:	ff 25 42 5c 20 00    	jmpq   *0x205c42(%rip)        # 2080b8 <_GLOBAL_OFFSET_TABLE_+0xb8>
    2476:	68 14 00 00 00       	pushq  $0x14
    247b:	e9 a0 fe ff ff       	jmpq   2320 <_init+0x28>

0000000000002480 <__stack_chk_fail@plt>:
    2480:	ff 25 3a 5c 20 00    	jmpq   *0x205c3a(%rip)        # 2080c0 <_GLOBAL_OFFSET_TABLE_+0xc0>
    2486:	68 15 00 00 00       	pushq  $0x15
    248b:	e9 90 fe ff ff       	jmpq   2320 <_init+0x28>

0000000000002490 <ustream_init_defaults@plt>:
    2490:	ff 25 32 5c 20 00    	jmpq   *0x205c32(%rip)        # 2080c8 <_GLOBAL_OFFSET_TABLE_+0xc8>
    2496:	68 16 00 00 00       	pushq  $0x16
    249b:	e9 80 fe ff ff       	jmpq   2320 <_init+0x28>

00000000000024a0 <runqueue_task_cancel@plt>:
    24a0:	ff 25 2a 5c 20 00    	jmpq   *0x205c2a(%rip)        # 2080d0 <_GLOBAL_OFFSET_TABLE_+0xd0>
    24a6:	68 17 00 00 00       	pushq  $0x17
    24ab:	e9 70 fe ff ff       	jmpq   2320 <_init+0x28>

00000000000024b0 <uloop_timeout_add@plt>:
    24b0:	ff 25 22 5c 20 00    	jmpq   *0x205c22(%rip)        # 2080d8 <_GLOBAL_OFFSET_TABLE_+0xd8>
    24b6:	68 18 00 00 00       	pushq  $0x18
    24bb:	e9 60 fe ff ff       	jmpq   2320 <_init+0x28>

00000000000024c0 <safe_list_del@plt>:
    24c0:	ff 25 1a 5c 20 00    	jmpq   *0x205c1a(%rip)        # 2080e0 <_GLOBAL_OFFSET_TABLE_+0xe0>
    24c6:	68 19 00 00 00       	pushq  $0x19
    24cb:	e9 50 fe ff ff       	jmpq   2320 <_init+0x28>

00000000000024d0 <fputs@plt>:
    24d0:	ff 25 12 5c 20 00    	jmpq   *0x205c12(%rip)        # 2080e8 <_GLOBAL_OFFSET_TABLE_+0xe8>
    24d6:	68 1a 00 00 00       	pushq  $0x1a
    24db:	e9 40 fe ff ff       	jmpq   2320 <_init+0x28>

00000000000024e0 <blob_buf_grow@plt>:
    24e0:	ff 25 0a 5c 20 00    	jmpq   *0x205c0a(%rip)        # 2080f0 <_GLOBAL_OFFSET_TABLE_+0xf0>
    24e6:	68 1b 00 00 00       	pushq  $0x1b
    24eb:	e9 30 fe ff ff       	jmpq   2320 <_init+0x28>

00000000000024f0 <ustream_fill_read@plt>:
    24f0:	ff 25 02 5c 20 00    	jmpq   *0x205c02(%rip)        # 2080f8 <_GLOBAL_OFFSET_TABLE_+0xf8>
    24f6:	68 1c 00 00 00       	pushq  $0x1c
    24fb:	e9 20 fe ff ff       	jmpq   2320 <_init+0x28>

0000000000002500 <blobmsg_alloc_string_buffer@plt>:
    2500:	ff 25 fa 5b 20 00    	jmpq   *0x205bfa(%rip)        # 208100 <_GLOBAL_OFFSET_TABLE_+0x100>
    2506:	68 1d 00 00 00       	pushq  $0x1d
    250b:	e9 10 fe ff ff       	jmpq   2320 <_init+0x28>

0000000000002510 <blob_set_raw_len@plt>:
    2510:	ff 25 f2 5b 20 00    	jmpq   *0x205bf2(%rip)        # 208108 <_GLOBAL_OFFSET_TABLE_+0x108>
    2516:	68 1e 00 00 00       	pushq  $0x1e
    251b:	e9 00 fe ff ff       	jmpq   2320 <_init+0x28>

0000000000002520 <ustream_reserve@plt>:
    2520:	ff 25 ea 5b 20 00    	jmpq   *0x205bea(%rip)        # 208110 <_GLOBAL_OFFSET_TABLE_+0x110>
    2526:	68 1f 00 00 00       	pushq  $0x1f
    252b:	e9 f0 fd ff ff       	jmpq   2320 <_init+0x28>

0000000000002530 <uloop_timeout_set@plt>:
    2530:	ff 25 e2 5b 20 00    	jmpq   *0x205be2(%rip)        # 208118 <_GLOBAL_OFFSET_TABLE_+0x118>
    2536:	68 20 00 00 00       	pushq  $0x20
    253b:	e9 e0 fd ff ff       	jmpq   2320 <_init+0x28>

0000000000002540 <close@plt>:
    2540:	ff 25 da 5b 20 00    	jmpq   *0x205bda(%rip)        # 208120 <_GLOBAL_OFFSET_TABLE_+0x120>
    2546:	68 21 00 00 00       	pushq  $0x21
    254b:	e9 d0 fd ff ff       	jmpq   2320 <_init+0x28>

0000000000002550 <epoll_ctl@plt>:
    2550:	ff 25 d2 5b 20 00    	jmpq   *0x205bd2(%rip)        # 208128 <_GLOBAL_OFFSET_TABLE_+0x128>
    2556:	68 22 00 00 00       	pushq  $0x22
    255b:	e9 c0 fd ff ff       	jmpq   2320 <_init+0x28>

0000000000002560 <read@plt>:
    2560:	ff 25 ca 5b 20 00    	jmpq   *0x205bca(%rip)        # 208130 <_GLOBAL_OFFSET_TABLE_+0x130>
    2566:	68 23 00 00 00       	pushq  $0x23
    256b:	e9 b0 fd ff ff       	jmpq   2320 <_init+0x28>

0000000000002570 <memcmp@plt>:
    2570:	ff 25 c2 5b 20 00    	jmpq   *0x205bc2(%rip)        # 208138 <_GLOBAL_OFFSET_TABLE_+0x138>
    2576:	68 24 00 00 00       	pushq  $0x24
    257b:	e9 a0 fd ff ff       	jmpq   2320 <_init+0x28>

0000000000002580 <ustream_write_pending@plt>:
    2580:	ff 25 ba 5b 20 00    	jmpq   *0x205bba(%rip)        # 208140 <_GLOBAL_OFFSET_TABLE_+0x140>
    2586:	68 25 00 00 00       	pushq  $0x25
    258b:	e9 90 fd ff ff       	jmpq   2320 <_init+0x28>

0000000000002590 <calloc@plt>:
    2590:	ff 25 b2 5b 20 00    	jmpq   *0x205bb2(%rip)        # 208148 <_GLOBAL_OFFSET_TABLE_+0x148>
    2596:	68 26 00 00 00       	pushq  $0x26
    259b:	e9 80 fd ff ff       	jmpq   2320 <_init+0x28>

00000000000025a0 <strcmp@plt>:
    25a0:	ff 25 aa 5b 20 00    	jmpq   *0x205baa(%rip)        # 208150 <_GLOBAL_OFFSET_TABLE_+0x150>
    25a6:	68 27 00 00 00       	pushq  $0x27
    25ab:	e9 70 fd ff ff       	jmpq   2320 <_init+0x28>

00000000000025b0 <blobmsg_add_string_buffer@plt>:
    25b0:	ff 25 a2 5b 20 00    	jmpq   *0x205ba2(%rip)        # 208158 <_GLOBAL_OFFSET_TABLE_+0x158>
    25b6:	68 28 00 00 00       	pushq  $0x28
    25bb:	e9 60 fd ff ff       	jmpq   2320 <_init+0x28>

00000000000025c0 <kill@plt>:
    25c0:	ff 25 9a 5b 20 00    	jmpq   *0x205b9a(%rip)        # 208160 <_GLOBAL_OFFSET_TABLE_+0x160>
    25c6:	68 29 00 00 00       	pushq  $0x29
    25cb:	e9 50 fd ff ff       	jmpq   2320 <_init+0x28>

00000000000025d0 <safe_list_add@plt>:
    25d0:	ff 25 92 5b 20 00    	jmpq   *0x205b92(%rip)        # 208168 <_GLOBAL_OFFSET_TABLE_+0x168>
    25d6:	68 2a 00 00 00       	pushq  $0x2a
    25db:	e9 40 fd ff ff       	jmpq   2320 <_init+0x28>

00000000000025e0 <malloc@plt>:
    25e0:	ff 25 8a 5b 20 00    	jmpq   *0x205b8a(%rip)        # 208170 <_GLOBAL_OFFSET_TABLE_+0x170>
    25e6:	68 2b 00 00 00       	pushq  $0x2b
    25eb:	e9 30 fd ff ff       	jmpq   2320 <_init+0x28>

00000000000025f0 <listen@plt>:
    25f0:	ff 25 82 5b 20 00    	jmpq   *0x205b82(%rip)        # 208178 <_GLOBAL_OFFSET_TABLE_+0x178>
    25f6:	68 2c 00 00 00       	pushq  $0x2c
    25fb:	e9 20 fd ff ff       	jmpq   2320 <_init+0x28>

0000000000002600 <runqueue_task_complete@plt>:
    2600:	ff 25 7a 5b 20 00    	jmpq   *0x205b7a(%rip)        # 208180 <_GLOBAL_OFFSET_TABLE_+0x180>
    2606:	68 2d 00 00 00       	pushq  $0x2d
    260b:	e9 10 fd ff ff       	jmpq   2320 <_init+0x28>

0000000000002610 <__vsnprintf_chk@plt>:
    2610:	ff 25 72 5b 20 00    	jmpq   *0x205b72(%rip)        # 208188 <_GLOBAL_OFFSET_TABLE_+0x188>
    2616:	68 2e 00 00 00       	pushq  $0x2e
    261b:	e9 00 fd ff ff       	jmpq   2320 <_init+0x28>

0000000000002620 <md5_begin@plt>:
    2620:	ff 25 6a 5b 20 00    	jmpq   *0x205b6a(%rip)        # 208190 <_GLOBAL_OFFSET_TABLE_+0x190>
    2626:	68 2f 00 00 00       	pushq  $0x2f
    262b:	e9 f0 fc ff ff       	jmpq   2320 <_init+0x28>

0000000000002630 <realloc@plt>:
    2630:	ff 25 62 5b 20 00    	jmpq   *0x205b62(%rip)        # 208198 <_GLOBAL_OFFSET_TABLE_+0x198>
    2636:	68 30 00 00 00       	pushq  $0x30
    263b:	e9 e0 fc ff ff       	jmpq   2320 <_init+0x28>

0000000000002640 <md5_hash@plt>:
    2640:	ff 25 5a 5b 20 00    	jmpq   *0x205b5a(%rip)        # 2081a0 <_GLOBAL_OFFSET_TABLE_+0x1a0>
    2646:	68 31 00 00 00       	pushq  $0x31
    264b:	e9 d0 fc ff ff       	jmpq   2320 <_init+0x28>

0000000000002650 <uloop_process_add@plt>:
    2650:	ff 25 52 5b 20 00    	jmpq   *0x205b52(%rip)        # 2081a8 <_GLOBAL_OFFSET_TABLE_+0x1a8>
    2656:	68 32 00 00 00       	pushq  $0x32
    265b:	e9 c0 fc ff ff       	jmpq   2320 <_init+0x28>

0000000000002660 <__strcpy_chk@plt>:
    2660:	ff 25 4a 5b 20 00    	jmpq   *0x205b4a(%rip)        # 2081b0 <_GLOBAL_OFFSET_TABLE_+0x1b0>
    2666:	68 33 00 00 00       	pushq  $0x33
    266b:	e9 b0 fc ff ff       	jmpq   2320 <_init+0x28>

0000000000002670 <uloop_fd_add@plt>:
    2670:	ff 25 42 5b 20 00    	jmpq   *0x205b42(%rip)        # 2081b8 <_GLOBAL_OFFSET_TABLE_+0x1b8>
    2676:	68 34 00 00 00       	pushq  $0x34
    267b:	e9 a0 fc ff ff       	jmpq   2320 <_init+0x28>

0000000000002680 <epoll_wait@plt>:
    2680:	ff 25 3a 5b 20 00    	jmpq   *0x205b3a(%rip)        # 2081c0 <_GLOBAL_OFFSET_TABLE_+0x1c0>
    2686:	68 35 00 00 00       	pushq  $0x35
    268b:	e9 90 fc ff ff       	jmpq   2320 <_init+0x28>

0000000000002690 <avl_delete@plt>:
    2690:	ff 25 32 5b 20 00    	jmpq   *0x205b32(%rip)        # 2081c8 <_GLOBAL_OFFSET_TABLE_+0x1c8>
    2696:	68 36 00 00 00       	pushq  $0x36
    269b:	e9 80 fc ff ff       	jmpq   2320 <_init+0x28>

00000000000026a0 <bind@plt>:
    26a0:	ff 25 2a 5b 20 00    	jmpq   *0x205b2a(%rip)        # 2081d0 <_GLOBAL_OFFSET_TABLE_+0x1d0>
    26a6:	68 37 00 00 00       	pushq  $0x37
    26ab:	e9 70 fc ff ff       	jmpq   2320 <_init+0x28>

00000000000026b0 <blobmsg_vprintf@plt>:
    26b0:	ff 25 22 5b 20 00    	jmpq   *0x205b22(%rip)        # 2081d8 <_GLOBAL_OFFSET_TABLE_+0x1d8>
    26b6:	68 38 00 00 00       	pushq  $0x38
    26bb:	e9 60 fc ff ff       	jmpq   2320 <_init+0x28>

00000000000026c0 <memmove@plt>:
    26c0:	ff 25 1a 5b 20 00    	jmpq   *0x205b1a(%rip)        # 2081e0 <_GLOBAL_OFFSET_TABLE_+0x1e0>
    26c6:	68 39 00 00 00       	pushq  $0x39
    26cb:	e9 50 fc ff ff       	jmpq   2320 <_init+0x28>

00000000000026d0 <waitpid@plt>:
    26d0:	ff 25 12 5b 20 00    	jmpq   *0x205b12(%rip)        # 2081e8 <_GLOBAL_OFFSET_TABLE_+0x1e8>
    26d6:	68 3a 00 00 00       	pushq  $0x3a
    26db:	e9 40 fc ff ff       	jmpq   2320 <_init+0x28>

00000000000026e0 <open@plt>:
    26e0:	ff 25 0a 5b 20 00    	jmpq   *0x205b0a(%rip)        # 2081f0 <_GLOBAL_OFFSET_TABLE_+0x1f0>
    26e6:	68 3b 00 00 00       	pushq  $0x3b
    26eb:	e9 30 fc ff ff       	jmpq   2320 <_init+0x28>

00000000000026f0 <ustream_write@plt>:
    26f0:	ff 25 02 5b 20 00    	jmpq   *0x205b02(%rip)        # 2081f8 <_GLOBAL_OFFSET_TABLE_+0x1f8>
    26f6:	68 3c 00 00 00       	pushq  $0x3c
    26fb:	e9 20 fc ff ff       	jmpq   2320 <_init+0x28>

0000000000002700 <runqueue_task_kill@plt>:
    2700:	ff 25 fa 5a 20 00    	jmpq   *0x205afa(%rip)        # 208200 <_GLOBAL_OFFSET_TABLE_+0x200>
    2706:	68 3d 00 00 00       	pushq  $0x3d
    270b:	e9 10 fc ff ff       	jmpq   2320 <_init+0x28>

0000000000002710 <runqueue_cancel_pending@plt>:
    2710:	ff 25 f2 5a 20 00    	jmpq   *0x205af2(%rip)        # 208208 <_GLOBAL_OFFSET_TABLE_+0x208>
    2716:	68 3e 00 00 00       	pushq  $0x3e
    271b:	e9 00 fc ff ff       	jmpq   2320 <_init+0x28>

0000000000002720 <epoll_create@plt>:
    2720:	ff 25 ea 5a 20 00    	jmpq   *0x205aea(%rip)        # 208210 <_GLOBAL_OFFSET_TABLE_+0x210>
    2726:	68 3f 00 00 00       	pushq  $0x3f
    272b:	e9 f0 fb ff ff       	jmpq   2320 <_init+0x28>

0000000000002730 <connect@plt>:
    2730:	ff 25 e2 5a 20 00    	jmpq   *0x205ae2(%rip)        # 208218 <_GLOBAL_OFFSET_TABLE_+0x218>
    2736:	68 40 00 00 00       	pushq  $0x40
    273b:	e9 e0 fb ff ff       	jmpq   2320 <_init+0x28>

0000000000002740 <uloop_fd_delete@plt>:
    2740:	ff 25 da 5a 20 00    	jmpq   *0x205ada(%rip)        # 208220 <_GLOBAL_OFFSET_TABLE_+0x220>
    2746:	68 41 00 00 00       	pushq  $0x41
    274b:	e9 d0 fb ff ff       	jmpq   2320 <_init+0x28>

0000000000002750 <getaddrinfo@plt>:
    2750:	ff 25 d2 5a 20 00    	jmpq   *0x205ad2(%rip)        # 208228 <_GLOBAL_OFFSET_TABLE_+0x228>
    2756:	68 42 00 00 00       	pushq  $0x42
    275b:	e9 c0 fb ff ff       	jmpq   2320 <_init+0x28>

0000000000002760 <uloop_timeout_cancel@plt>:
    2760:	ff 25 ca 5a 20 00    	jmpq   *0x205aca(%rip)        # 208230 <_GLOBAL_OFFSET_TABLE_+0x230>
    2766:	68 43 00 00 00       	pushq  $0x43
    276b:	e9 b0 fb ff ff       	jmpq   2320 <_init+0x28>

0000000000002770 <md5_end@plt>:
    2770:	ff 25 c2 5a 20 00    	jmpq   *0x205ac2(%rip)        # 208238 <_GLOBAL_OFFSET_TABLE_+0x238>
    2776:	68 44 00 00 00       	pushq  $0x44
    277b:	e9 a0 fb ff ff       	jmpq   2320 <_init+0x28>

0000000000002780 <runqueue_task_add@plt>:
    2780:	ff 25 ba 5a 20 00    	jmpq   *0x205aba(%rip)        # 208240 <_GLOBAL_OFFSET_TABLE_+0x240>
    2786:	68 45 00 00 00       	pushq  $0x45
    278b:	e9 90 fb ff ff       	jmpq   2320 <_init+0x28>

0000000000002790 <__vsprintf_chk@plt>:
    2790:	ff 25 b2 5a 20 00    	jmpq   *0x205ab2(%rip)        # 208248 <_GLOBAL_OFFSET_TABLE_+0x248>
    2796:	68 46 00 00 00       	pushq  $0x46
    279b:	e9 80 fb ff ff       	jmpq   2320 <_init+0x28>

00000000000027a0 <blobmsg_check_attr@plt>:
    27a0:	ff 25 aa 5a 20 00    	jmpq   *0x205aaa(%rip)        # 208250 <_GLOBAL_OFFSET_TABLE_+0x250>
    27a6:	68 47 00 00 00       	pushq  $0x47
    27ab:	e9 70 fb ff ff       	jmpq   2320 <_init+0x28>

00000000000027b0 <freeaddrinfo@plt>:
    27b0:	ff 25 a2 5a 20 00    	jmpq   *0x205aa2(%rip)        # 208258 <_GLOBAL_OFFSET_TABLE_+0x258>
    27b6:	68 48 00 00 00       	pushq  $0x48
    27bb:	e9 60 fb ff ff       	jmpq   2320 <_init+0x28>

00000000000027c0 <socket@plt>:
    27c0:	ff 25 9a 5a 20 00    	jmpq   *0x205a9a(%rip)        # 208260 <_GLOBAL_OFFSET_TABLE_+0x260>
    27c6:	68 49 00 00 00       	pushq  $0x49
    27cb:	e9 50 fb ff ff       	jmpq   2320 <_init+0x28>

00000000000027d0 <vlist_flush@plt>:
    27d0:	ff 25 92 5a 20 00    	jmpq   *0x205a92(%rip)        # 208268 <_GLOBAL_OFFSET_TABLE_+0x268>
    27d6:	68 4a 00 00 00       	pushq  $0x4a
    27db:	e9 40 fb ff ff       	jmpq   2320 <_init+0x28>

Disassembly of section .plt.got:

00000000000027e0 <.plt.got>:
    27e0:	ff 25 da 57 20 00    	jmpq   *0x2057da(%rip)        # 207fc0 <_DYNAMIC+0x1e0>
    27e6:	66 90                	xchg   %ax,%ax
    27e8:	ff 25 f2 57 20 00    	jmpq   *0x2057f2(%rip)        # 207fe0 <_DYNAMIC+0x200>
    27ee:	66 90                	xchg   %ax,%ax

Disassembly of section .text:

00000000000027f0 <deregister_tm_clones>:
    27f0:	48 8d 3d a9 5a 20 00 	lea    0x205aa9(%rip),%rdi        # 2082a0 <_edata>
    27f7:	48 8d 05 a9 5a 20 00 	lea    0x205aa9(%rip),%rax        # 2082a7 <_edata+0x7>
    27fe:	55                   	push   %rbp
    27ff:	48 29 f8             	sub    %rdi,%rax
    2802:	48 89 e5             	mov    %rsp,%rbp
    2805:	48 83 f8 0e          	cmp    $0xe,%rax
    2809:	76 15                	jbe    2820 <deregister_tm_clones+0x30>
    280b:	48 8b 05 9e 57 20 00 	mov    0x20579e(%rip),%rax        # 207fb0 <_DYNAMIC+0x1d0>
    2812:	48 85 c0             	test   %rax,%rax
    2815:	74 09                	je     2820 <deregister_tm_clones+0x30>
    2817:	5d                   	pop    %rbp
    2818:	ff e0                	jmpq   *%rax
    281a:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)
    2820:	5d                   	pop    %rbp
    2821:	c3                   	retq   
    2822:	0f 1f 40 00          	nopl   0x0(%rax)
    2826:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    282d:	00 00 00 

0000000000002830 <register_tm_clones>:
    2830:	48 8d 3d 69 5a 20 00 	lea    0x205a69(%rip),%rdi        # 2082a0 <_edata>
    2837:	48 8d 35 62 5a 20 00 	lea    0x205a62(%rip),%rsi        # 2082a0 <_edata>
    283e:	55                   	push   %rbp
    283f:	48 29 fe             	sub    %rdi,%rsi
    2842:	48 89 e5             	mov    %rsp,%rbp
    2845:	48 c1 fe 03          	sar    $0x3,%rsi
    2849:	48 89 f0             	mov    %rsi,%rax
    284c:	48 c1 e8 3f          	shr    $0x3f,%rax
    2850:	48 01 c6             	add    %rax,%rsi
    2853:	48 d1 fe             	sar    %rsi
    2856:	74 18                	je     2870 <register_tm_clones+0x40>
    2858:	48 8b 05 79 57 20 00 	mov    0x205779(%rip),%rax        # 207fd8 <_DYNAMIC+0x1f8>
    285f:	48 85 c0             	test   %rax,%rax
    2862:	74 0c                	je     2870 <register_tm_clones+0x40>
    2864:	5d                   	pop    %rbp
    2865:	ff e0                	jmpq   *%rax
    2867:	66 0f 1f 84 00 00 00 	nopw   0x0(%rax,%rax,1)
    286e:	00 00 
    2870:	5d                   	pop    %rbp
    2871:	c3                   	retq   
    2872:	0f 1f 40 00          	nopl   0x0(%rax)
    2876:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    287d:	00 00 00 

0000000000002880 <__do_global_dtors_aux>:
    2880:	80 3d 19 5a 20 00 00 	cmpb   $0x0,0x205a19(%rip)        # 2082a0 <_edata>
    2887:	75 27                	jne    28b0 <__do_global_dtors_aux+0x30>
    2889:	48 83 3d 4f 57 20 00 	cmpq   $0x0,0x20574f(%rip)        # 207fe0 <_DYNAMIC+0x200>
    2890:	00 
    2891:	55                   	push   %rbp
    2892:	48 89 e5             	mov    %rsp,%rbp
    2895:	74 0c                	je     28a3 <__do_global_dtors_aux+0x23>
    2897:	48 8b 3d d2 59 20 00 	mov    0x2059d2(%rip),%rdi        # 208270 <__dso_handle>
    289e:	e8 45 ff ff ff       	callq  27e8 <vlist_flush@plt+0x18>
    28a3:	e8 48 ff ff ff       	callq  27f0 <deregister_tm_clones>
    28a8:	5d                   	pop    %rbp
    28a9:	c6 05 f0 59 20 00 01 	movb   $0x1,0x2059f0(%rip)        # 2082a0 <_edata>
    28b0:	f3 c3                	repz retq 
    28b2:	0f 1f 40 00          	nopl   0x0(%rax)
    28b6:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    28bd:	00 00 00 

00000000000028c0 <frame_dummy>:
    28c0:	48 8d 3d f1 54 20 00 	lea    0x2054f1(%rip),%rdi        # 207db8 <__JCR_END__>
    28c7:	48 83 3f 00          	cmpq   $0x0,(%rdi)
    28cb:	75 0b                	jne    28d8 <frame_dummy+0x18>
    28cd:	e9 5e ff ff ff       	jmpq   2830 <register_tm_clones>
    28d2:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)
    28d8:	48 8b 05 f1 56 20 00 	mov    0x2056f1(%rip),%rax        # 207fd0 <_DYNAMIC+0x1f0>
    28df:	48 85 c0             	test   %rax,%rax
    28e2:	74 e9                	je     28cd <frame_dummy+0xd>
    28e4:	55                   	push   %rbp
    28e5:	48 89 e5             	mov    %rsp,%rbp
    28e8:	ff d0                	callq  *%rax
    28ea:	5d                   	pop    %rbp
    28eb:	e9 40 ff ff ff       	jmpq   2830 <register_tm_clones>

00000000000028f0 <avl_find_rec>:
  avl_remove(tree, node);
}

static struct avl_node *
avl_find_rec(struct avl_node *node, const void *key, avl_tree_comp comp, void *cmp_ptr, int *cmp_result)
{
    28f0:	41 55                	push   %r13
    28f2:	41 54                	push   %r12
    28f4:	49 89 cd             	mov    %rcx,%r13
    28f7:	55                   	push   %rbp
    28f8:	53                   	push   %rbx
    28f9:	48 89 f5             	mov    %rsi,%rbp
    28fc:	48 89 fb             	mov    %rdi,%rbx
    28ff:	49 89 d4             	mov    %rdx,%r12
    2902:	48 83 ec 18          	sub    $0x18,%rsp
    2906:	4c 89 44 24 08       	mov    %r8,0x8(%rsp)
  int diff;

  diff = (*comp) (key, node->key, cmp_ptr);
    290b:	48 8b 73 28          	mov    0x28(%rbx),%rsi
    290f:	4c 89 ea             	mov    %r13,%rdx
    2912:	48 89 ef             	mov    %rbp,%rdi
    2915:	41 ff d4             	callq  *%r12
  *cmp_result = diff;
    2918:	4c 8b 44 24 08       	mov    0x8(%rsp),%r8

  if (diff < 0) {
    291d:	85 c0                	test   %eax,%eax
avl_find_rec(struct avl_node *node, const void *key, avl_tree_comp comp, void *cmp_ptr, int *cmp_result)
{
  int diff;

  diff = (*comp) (key, node->key, cmp_ptr);
  *cmp_result = diff;
    291f:	41 89 00             	mov    %eax,(%r8)

  if (diff < 0) {
    2922:	79 06                	jns    292a <avl_find_rec+0x3a>
    if (node->left != NULL)
    2924:	48 8b 43 18          	mov    0x18(%rbx),%rax
    2928:	eb 06                	jmp    2930 <avl_find_rec+0x40>
      return avl_find_rec(node->left, key, comp, cmp_ptr, cmp_result);

    return node;
  }

  if (diff > 0) {
    292a:	74 0e                	je     293a <avl_find_rec+0x4a>
    if (node->right != NULL)
    292c:	48 8b 43 20          	mov    0x20(%rbx),%rax
    2930:	48 85 c0             	test   %rax,%rax
    2933:	74 05                	je     293a <avl_find_rec+0x4a>
  avl_remove(tree, node);
}

static struct avl_node *
avl_find_rec(struct avl_node *node, const void *key, avl_tree_comp comp, void *cmp_ptr, int *cmp_result)
{
    2935:	48 89 c3             	mov    %rax,%rbx
    2938:	eb cc                	jmp    2906 <avl_find_rec+0x16>

    return node;
  }

  return node;
}
    293a:	48 83 c4 18          	add    $0x18,%rsp
    293e:	48 89 d8             	mov    %rbx,%rax
    2941:	5b                   	pop    %rbx
    2942:	5d                   	pop    %rbp
    2943:	41 5c                	pop    %r12
    2945:	41 5d                	pop    %r13
    2947:	c3                   	retq   

0000000000002948 <avl_rotate_right.isra.2>:
avl_rotate_right(struct avl_tree *tree, struct avl_node *node)
{
  struct avl_node *left, *parent;

  left = node->left;
  parent = node->parent;
    2948:	48 8b 46 10          	mov    0x10(%rsi),%rax
static void
avl_rotate_right(struct avl_tree *tree, struct avl_node *node)
{
  struct avl_node *left, *parent;

  left = node->left;
    294c:	48 8b 56 18          	mov    0x18(%rsi),%rdx
  parent = node->parent;

  left->parent = parent;
  node->parent = left;

  if (parent == NULL)
    2950:	48 85 c0             	test   %rax,%rax
  struct avl_node *left, *parent;

  left = node->left;
  parent = node->parent;

  left->parent = parent;
    2953:	48 89 42 10          	mov    %rax,0x10(%rdx)
  node->parent = left;
    2957:	48 89 56 10          	mov    %rdx,0x10(%rsi)

  if (parent == NULL)
    295b:	75 05                	jne    2962 <avl_rotate_right.isra.2+0x1a>
    tree->root = left;
    295d:	48 89 17             	mov    %rdx,(%rdi)
    2960:	eb 10                	jmp    2972 <avl_rotate_right.isra.2+0x2a>

  else {
    if (parent->left == node)
    2962:	48 3b 70 18          	cmp    0x18(%rax),%rsi
    2966:	75 06                	jne    296e <avl_rotate_right.isra.2+0x26>
      parent->left = left;
    2968:	48 89 50 18          	mov    %rdx,0x18(%rax)
    296c:	eb 04                	jmp    2972 <avl_rotate_right.isra.2+0x2a>

    else
      parent->right = left;
    296e:	48 89 50 20          	mov    %rdx,0x20(%rax)
  }

  node->left = left->right;
    2972:	48 8b 42 20          	mov    0x20(%rdx),%rax
  left->right = node;

  if (node->left != NULL)
    2976:	48 85 c0             	test   %rax,%rax

    else
      parent->right = left;
  }

  node->left = left->right;
    2979:	48 89 46 18          	mov    %rax,0x18(%rsi)
  left->right = node;
    297d:	48 89 72 20          	mov    %rsi,0x20(%rdx)

  if (node->left != NULL)
    2981:	74 04                	je     2987 <avl_rotate_right.isra.2+0x3f>
    node->left->parent = node;
    2983:	48 89 70 10          	mov    %rsi,0x10(%rax)

  node->balance += 1 - avl_min(left->balance, 0);
    2987:	0f be 4a 30          	movsbl 0x30(%rdx),%ecx
    298b:	31 ff                	xor    %edi,%edi
    298d:	b8 01 00 00 00       	mov    $0x1,%eax
    2992:	85 c9                	test   %ecx,%ecx
    2994:	0f 4f cf             	cmovg  %edi,%ecx
    2997:	29 c8                	sub    %ecx,%eax
    2999:	03 46 30             	add    0x30(%rsi),%eax
    299c:	88 46 30             	mov    %al,0x30(%rsi)
  left->balance += 1 + avl_max(node->balance, 0);
    299f:	0f be c0             	movsbl %al,%eax
    29a2:	85 c0                	test   %eax,%eax
    29a4:	0f 48 c7             	cmovs  %edi,%eax
    29a7:	ff c0                	inc    %eax
    29a9:	00 42 30             	add    %al,0x30(%rdx)
    29ac:	c3                   	retq   

00000000000029ad <avl_rotate_left.isra.3>:
avl_rotate_left(struct avl_tree *tree, struct avl_node *node)
{
  struct avl_node *right, *parent;

  right = node->right;
  parent = node->parent;
    29ad:	48 8b 46 10          	mov    0x10(%rsi),%rax
static void
avl_rotate_left(struct avl_tree *tree, struct avl_node *node)
{
  struct avl_node *right, *parent;

  right = node->right;
    29b1:	48 8b 56 20          	mov    0x20(%rsi),%rdx
  parent = node->parent;

  right->parent = parent;
  node->parent = right;

  if (parent == NULL)
    29b5:	48 85 c0             	test   %rax,%rax
  struct avl_node *right, *parent;

  right = node->right;
  parent = node->parent;

  right->parent = parent;
    29b8:	48 89 42 10          	mov    %rax,0x10(%rdx)
  node->parent = right;
    29bc:	48 89 56 10          	mov    %rdx,0x10(%rsi)

  if (parent == NULL)
    29c0:	75 05                	jne    29c7 <avl_rotate_left.isra.3+0x1a>
    tree->root = right;
    29c2:	48 89 17             	mov    %rdx,(%rdi)
    29c5:	eb 10                	jmp    29d7 <avl_rotate_left.isra.3+0x2a>

  else {
    if (parent->left == node)
    29c7:	48 3b 70 18          	cmp    0x18(%rax),%rsi
    29cb:	75 06                	jne    29d3 <avl_rotate_left.isra.3+0x26>
      parent->left = right;
    29cd:	48 89 50 18          	mov    %rdx,0x18(%rax)
    29d1:	eb 04                	jmp    29d7 <avl_rotate_left.isra.3+0x2a>

    else
      parent->right = right;
    29d3:	48 89 50 20          	mov    %rdx,0x20(%rax)
  }

  node->right = right->left;
    29d7:	48 8b 42 18          	mov    0x18(%rdx),%rax
  right->left = node;

  if (node->right != NULL)
    29db:	48 85 c0             	test   %rax,%rax

    else
      parent->right = right;
  }

  node->right = right->left;
    29de:	48 89 46 20          	mov    %rax,0x20(%rsi)
  right->left = node;
    29e2:	48 89 72 18          	mov    %rsi,0x18(%rdx)

  if (node->right != NULL)
    29e6:	74 04                	je     29ec <avl_rotate_left.isra.3+0x3f>
    node->right->parent = node;
    29e8:	48 89 70 10          	mov    %rsi,0x10(%rax)

  node->balance -= 1 + avl_max(right->balance, 0);
    29ec:	0f be 42 30          	movsbl 0x30(%rdx),%eax
    29f0:	31 c9                	xor    %ecx,%ecx
    29f2:	85 c0                	test   %eax,%eax
    29f4:	0f 48 c1             	cmovs  %ecx,%eax
    29f7:	f7 d0                	not    %eax
    29f9:	03 46 30             	add    0x30(%rsi),%eax
    29fc:	88 46 30             	mov    %al,0x30(%rsi)
  right->balance -= 1 - avl_min(node->balance, 0);
    29ff:	0f be c0             	movsbl %al,%eax
    2a02:	85 c0                	test   %eax,%eax
    2a04:	0f 4f c1             	cmovg  %ecx,%eax
    2a07:	b9 01 00 00 00       	mov    $0x1,%ecx
    2a0c:	29 c1                	sub    %eax,%ecx
    2a0e:	28 4a 30             	sub    %cl,0x30(%rdx)
    2a11:	c3                   	retq   

0000000000002a12 <post_insert>:
}

static void
post_insert(struct avl_tree *tree, struct avl_node *node)
{
    2a12:	49 89 f0             	mov    %rsi,%r8
  struct avl_node *parent = node->parent;
    2a15:	48 8b 76 10          	mov    0x10(%rsi),%rsi

  if (parent == NULL)
    2a19:	48 85 f6             	test   %rsi,%rsi
    2a1c:	74 6f                	je     2a8d <post_insert+0x7b>
    return;

  if (node == parent->left) {
    2a1e:	4c 3b 46 18          	cmp    0x18(%rsi),%r8
    2a22:	8a 46 30             	mov    0x30(%rsi),%al
    2a25:	75 33                	jne    2a5a <post_insert+0x48>
    parent->balance--;
    2a27:	ff c8                	dec    %eax

    if (parent->balance == 0)
    2a29:	84 c0                	test   %al,%al

  if (parent == NULL)
    return;

  if (node == parent->left) {
    parent->balance--;
    2a2b:	88 46 30             	mov    %al,0x30(%rsi)

    if (parent->balance == 0)
    2a2e:	74 5d                	je     2a8d <post_insert+0x7b>
      return;

    if (parent->balance == -1) {
    2a30:	fe c0                	inc    %al
    2a32:	74 de                	je     2a12 <post_insert>
      post_insert(tree, parent);
      return;
    }

    if (node->balance == -1) {
    2a34:	41 80 78 30 ff       	cmpb   $0xff,0x30(%r8)
    2a39:	4c 8d 4f 10          	lea    0x10(%rdi),%r9
    2a3d:	74 13                	je     2a52 <post_insert+0x40>
      avl_rotate_right(tree, parent);
      return;
    }

    avl_rotate_left(tree, node);
    2a3f:	4c 89 c6             	mov    %r8,%rsi
    2a42:	4c 89 cf             	mov    %r9,%rdi
    2a45:	e8 63 ff ff ff       	callq  29ad <avl_rotate_left.isra.3>
    avl_rotate_right(tree, node->parent->parent);
    2a4a:	49 8b 40 10          	mov    0x10(%r8),%rax
    2a4e:	48 8b 70 10          	mov    0x10(%rax),%rsi
    2a52:	4c 89 cf             	mov    %r9,%rdi
    2a55:	e9 ee fe ff ff       	jmpq   2948 <avl_rotate_right.isra.2>
    return;
  }

  parent->balance++;
    2a5a:	ff c0                	inc    %eax

  if (parent->balance == 0)
    2a5c:	84 c0                	test   %al,%al
    avl_rotate_left(tree, node);
    avl_rotate_right(tree, node->parent->parent);
    return;
  }

  parent->balance++;
    2a5e:	88 46 30             	mov    %al,0x30(%rsi)

  if (parent->balance == 0)
    2a61:	74 2a                	je     2a8d <post_insert+0x7b>
    return;

  if (parent->balance == 1) {
    2a63:	fe c8                	dec    %al
    2a65:	74 ab                	je     2a12 <post_insert>
    post_insert(tree, parent);
    return;
  }

  if (node->balance == 1) {
    2a67:	41 80 78 30 01       	cmpb   $0x1,0x30(%r8)
    2a6c:	4c 8d 4f 10          	lea    0x10(%rdi),%r9
    2a70:	74 13                	je     2a85 <post_insert+0x73>
    avl_rotate_left(tree, parent);
    return;
  }

  avl_rotate_right(tree, node);
    2a72:	4c 89 c6             	mov    %r8,%rsi
    2a75:	4c 89 cf             	mov    %r9,%rdi
    2a78:	e8 cb fe ff ff       	callq  2948 <avl_rotate_right.isra.2>
  avl_rotate_left(tree, node->parent->parent);
    2a7d:	49 8b 40 10          	mov    0x10(%r8),%rax
    2a81:	48 8b 70 10          	mov    0x10(%rax),%rsi
    2a85:	4c 89 cf             	mov    %r9,%rdi
    2a88:	e9 20 ff ff ff       	jmpq   29ad <avl_rotate_left.isra.3>
    2a8d:	c3                   	retq   

0000000000002a8e <avl_post_delete>:
  tree->count--;
}

static void
avl_post_delete(struct avl_tree *tree, struct avl_node *node)
{
    2a8e:	4c 8d 4f 10          	lea    0x10(%rdi),%r9
  struct avl_node *parent;

  if ((parent = node->parent) == NULL)
    2a92:	4c 8b 46 10          	mov    0x10(%rsi),%r8
    2a96:	4d 85 c0             	test   %r8,%r8
    2a99:	0f 84 8f 00 00 00    	je     2b2e <avl_post_delete+0xa0>
    return;

  if (node == parent->left) {
    2a9f:	49 8b 50 18          	mov    0x18(%r8),%rdx
    2aa3:	41 8a 40 30          	mov    0x30(%r8),%al
    2aa7:	48 39 d6             	cmp    %rdx,%rsi
    2aaa:	75 42                	jne    2aee <avl_post_delete+0x60>
    parent->balance++;
    2aac:	ff c0                	inc    %eax

    if (parent->balance == 0) {
    2aae:	84 c0                	test   %al,%al

  if ((parent = node->parent) == NULL)
    return;

  if (node == parent->left) {
    parent->balance++;
    2ab0:	41 88 40 30          	mov    %al,0x30(%r8)

    if (parent->balance == 0) {
    2ab4:	75 05                	jne    2abb <avl_post_delete+0x2d>
  tree->count--;
}

static void
avl_post_delete(struct avl_tree *tree, struct avl_node *node)
{
    2ab6:	4c 89 c6             	mov    %r8,%rsi
    2ab9:	eb d7                	jmp    2a92 <avl_post_delete+0x4>
    if (parent->balance == 0) {
      avl_post_delete(tree, parent);
      return;
    }

    if (parent->balance == 1)
    2abb:	fe c8                	dec    %al
    2abd:	74 6f                	je     2b2e <avl_post_delete+0xa0>
      return;

    if (parent->right->balance == 0) {
    2abf:	49 8b 70 20          	mov    0x20(%r8),%rsi
    2ac3:	8a 46 30             	mov    0x30(%rsi),%al
    2ac6:	84 c0                	test   %al,%al
    2ac8:	75 0b                	jne    2ad5 <avl_post_delete+0x47>
      avl_rotate_left(tree, parent);
    2aca:	4c 89 c6             	mov    %r8,%rsi
    2acd:	4c 89 cf             	mov    %r9,%rdi
    2ad0:	e9 d8 fe ff ff       	jmpq   29ad <avl_rotate_left.isra.3>
      return;
    }

    if (parent->right->balance == 1) {
    2ad5:	fe c8                	dec    %al
    2ad7:	74 08                	je     2ae1 <avl_post_delete+0x53>
      avl_rotate_left(tree, parent);
      avl_post_delete(tree, parent->parent);
      return;
    }

    avl_rotate_right(tree, parent->right);
    2ad9:	4c 89 cf             	mov    %r9,%rdi
    2adc:	e8 67 fe ff ff       	callq  2948 <avl_rotate_right.isra.2>
    avl_rotate_left(tree, parent);
    2ae1:	4c 89 c6             	mov    %r8,%rsi
    2ae4:	4c 89 cf             	mov    %r9,%rdi
    2ae7:	e8 c1 fe ff ff       	callq  29ad <avl_rotate_left.isra.3>
    2aec:	eb 3a                	jmp    2b28 <avl_post_delete+0x9a>
    avl_post_delete(tree, parent->parent);
    return;
  }

  parent->balance--;
    2aee:	ff c8                	dec    %eax

  if (parent->balance == 0) {
    2af0:	84 c0                	test   %al,%al
    avl_rotate_left(tree, parent);
    avl_post_delete(tree, parent->parent);
    return;
  }

  parent->balance--;
    2af2:	41 88 40 30          	mov    %al,0x30(%r8)

  if (parent->balance == 0) {
    2af6:	74 be                	je     2ab6 <avl_post_delete+0x28>
    avl_post_delete(tree, parent);
    return;
  }

  if (parent->balance == -1)
    2af8:	fe c0                	inc    %al
    2afa:	74 32                	je     2b2e <avl_post_delete+0xa0>
    return;

  if (parent->left->balance == 0) {
    2afc:	8a 42 30             	mov    0x30(%rdx),%al
    2aff:	84 c0                	test   %al,%al
    2b01:	75 0b                	jne    2b0e <avl_post_delete+0x80>
    avl_rotate_right(tree, parent);
    2b03:	4c 89 c6             	mov    %r8,%rsi
    2b06:	4c 89 cf             	mov    %r9,%rdi
    2b09:	e9 3a fe ff ff       	jmpq   2948 <avl_rotate_right.isra.2>
    return;
  }

  if (parent->left->balance == -1) {
    2b0e:	fe c0                	inc    %al
    2b10:	74 0b                	je     2b1d <avl_post_delete+0x8f>
    avl_rotate_right(tree, parent);
    avl_post_delete(tree, parent->parent);
    return;
  }

  avl_rotate_left(tree, parent->left);
    2b12:	48 89 d6             	mov    %rdx,%rsi
    2b15:	4c 89 cf             	mov    %r9,%rdi
    2b18:	e8 90 fe ff ff       	callq  29ad <avl_rotate_left.isra.3>
  avl_rotate_right(tree, parent);
    2b1d:	4c 89 c6             	mov    %r8,%rsi
    2b20:	4c 89 cf             	mov    %r9,%rdi
    2b23:	e8 20 fe ff ff       	callq  2948 <avl_rotate_right.isra.2>
  avl_post_delete(tree, parent->parent);
    2b28:	4d 8b 40 10          	mov    0x10(%r8),%r8
    2b2c:	eb 88                	jmp    2ab6 <avl_post_delete+0x28>
    2b2e:	c3                   	retq   

0000000000002b2f <avl_delete_worker>:
}
#endif

static void
avl_delete_worker(struct avl_tree *tree, struct avl_node *node)
{
    2b2f:	41 56                	push   %r14
    2b31:	41 54                	push   %r12
    2b33:	49 89 f4             	mov    %rsi,%r12
    2b36:	55                   	push   %rbp
    2b37:	53                   	push   %rbx
    2b38:	48 89 fd             	mov    %rdi,%rbp
    2b3b:	41 51                	push   %r9
  struct avl_node *parent, *min;

  parent = node->parent;

  if (node->left == NULL && node->right == NULL) {
    2b3d:	48 8b 46 18          	mov    0x18(%rsi),%rax
static void
avl_delete_worker(struct avl_tree *tree, struct avl_node *node)
{
  struct avl_node *parent, *min;

  parent = node->parent;
    2b41:	4c 8b 76 10          	mov    0x10(%rsi),%r14
    2b45:	48 8b 5e 20          	mov    0x20(%rsi),%rbx

  if (node->left == NULL && node->right == NULL) {
    2b49:	48 85 c0             	test   %rax,%rax
    2b4c:	0f 85 14 01 00 00    	jne    2c66 <avl_delete_worker+0x137>
    2b52:	48 85 db             	test   %rbx,%rbx
    2b55:	0f 85 da 00 00 00    	jne    2c35 <avl_delete_worker+0x106>
    if (parent == NULL) {
    2b5b:	4d 85 f6             	test   %r14,%r14
    2b5e:	75 0d                	jne    2b6d <avl_delete_worker+0x3e>
      tree->root = NULL;
    2b60:	48 c7 47 10 00 00 00 	movq   $0x0,0x10(%rdi)
    2b67:	00 
      return;
    2b68:	e9 a5 01 00 00       	jmpq   2d12 <avl_delete_worker+0x1e3>
    }

    if (parent->left == node) {
    2b6d:	49 8b 76 18          	mov    0x18(%r14),%rsi
    2b71:	49 39 f4             	cmp    %rsi,%r12
    2b74:	75 59                	jne    2bcf <avl_delete_worker+0xa0>
      parent->left = NULL;
      parent->balance++;
    2b76:	41 8a 46 30          	mov    0x30(%r14),%al
      tree->root = NULL;
      return;
    }

    if (parent->left == node) {
      parent->left = NULL;
    2b7a:	49 c7 46 18 00 00 00 	movq   $0x0,0x18(%r14)
    2b81:	00 
      parent->balance++;
    2b82:	ff c0                	inc    %eax

      if (parent->balance == 1)
    2b84:	3c 01                	cmp    $0x1,%al
      return;
    }

    if (parent->left == node) {
      parent->left = NULL;
      parent->balance++;
    2b86:	41 88 46 30          	mov    %al,0x30(%r14)

      if (parent->balance == 1)
    2b8a:	0f 84 82 01 00 00    	je     2d12 <avl_delete_worker+0x1e3>
        return;

      if (parent->balance == 0) {
    2b90:	84 c0                	test   %al,%al
    2b92:	74 5f                	je     2bf3 <avl_delete_worker+0xc4>
        avl_post_delete(tree, parent);
        return;
      }

      if (parent->right->balance == 0) {
    2b94:	49 8b 76 20          	mov    0x20(%r14),%rsi
    2b98:	48 8d 5f 10          	lea    0x10(%rdi),%rbx
    2b9c:	8a 46 30             	mov    0x30(%rsi),%al
    2b9f:	84 c0                	test   %al,%al
    2ba1:	75 13                	jne    2bb6 <avl_delete_worker+0x87>
    parent->left = min;
    return;
  }

  parent->right = min;
}
    2ba3:	41 58                	pop    %r8
        avl_post_delete(tree, parent);
        return;
      }

      if (parent->right->balance == 0) {
        avl_rotate_left(tree, parent);
    2ba5:	4c 89 f6             	mov    %r14,%rsi
    2ba8:	48 89 df             	mov    %rbx,%rdi
    parent->left = min;
    return;
  }

  parent->right = min;
}
    2bab:	5b                   	pop    %rbx
    2bac:	5d                   	pop    %rbp
    2bad:	41 5c                	pop    %r12
    2baf:	41 5e                	pop    %r14
        avl_post_delete(tree, parent);
        return;
      }

      if (parent->right->balance == 0) {
        avl_rotate_left(tree, parent);
    2bb1:	e9 f7 fd ff ff       	jmpq   29ad <avl_rotate_left.isra.3>
        return;
      }

      if (parent->right->balance == 1) {
    2bb6:	fe c8                	dec    %al
    2bb8:	74 08                	je     2bc2 <avl_delete_worker+0x93>
        avl_rotate_left(tree, parent);
        avl_post_delete(tree, parent->parent);
        return;
      }

      avl_rotate_right(tree, parent->right);
    2bba:	48 89 df             	mov    %rbx,%rdi
    2bbd:	e8 86 fd ff ff       	callq  2948 <avl_rotate_right.isra.2>
      avl_rotate_left(tree, parent);
    2bc2:	4c 89 f6             	mov    %r14,%rsi
    2bc5:	48 89 df             	mov    %rbx,%rdi
    2bc8:	e8 e0 fd ff ff       	callq  29ad <avl_rotate_left.isra.3>
    2bcd:	eb 60                	jmp    2c2f <avl_delete_worker+0x100>
      avl_post_delete(tree, parent->parent);
      return;
    }

    if (parent->right == node) {
    2bcf:	4d 3b 66 20          	cmp    0x20(%r14),%r12
    2bd3:	75 76                	jne    2c4b <avl_delete_worker+0x11c>
      parent->right = NULL;
      parent->balance--;
    2bd5:	41 8a 46 30          	mov    0x30(%r14),%al
      avl_post_delete(tree, parent->parent);
      return;
    }

    if (parent->right == node) {
      parent->right = NULL;
    2bd9:	49 c7 46 20 00 00 00 	movq   $0x0,0x20(%r14)
    2be0:	00 
      parent->balance--;
    2be1:	ff c8                	dec    %eax

      if (parent->balance == -1)
    2be3:	3c ff                	cmp    $0xff,%al
      return;
    }

    if (parent->right == node) {
      parent->right = NULL;
      parent->balance--;
    2be5:	41 88 46 30          	mov    %al,0x30(%r14)

      if (parent->balance == -1)
    2be9:	0f 84 23 01 00 00    	je     2d12 <avl_delete_worker+0x1e3>
        return;

      if (parent->balance == 0) {
    2bef:	84 c0                	test   %al,%al
    2bf1:	75 08                	jne    2bfb <avl_delete_worker+0xcc>
        avl_post_delete(tree, parent);
    2bf3:	4c 89 f6             	mov    %r14,%rsi
    2bf6:	e9 9f 00 00 00       	jmpq   2c9a <avl_delete_worker+0x16b>
        return;
      }

      if (parent->left->balance == 0) {
    2bfb:	8a 46 30             	mov    0x30(%rsi),%al
    2bfe:	48 8d 5f 10          	lea    0x10(%rdi),%rbx
    2c02:	84 c0                	test   %al,%al
    2c04:	75 12                	jne    2c18 <avl_delete_worker+0xe9>
    parent->left = min;
    return;
  }

  parent->right = min;
}
    2c06:	59                   	pop    %rcx
        avl_post_delete(tree, parent);
        return;
      }

      if (parent->left->balance == 0) {
        avl_rotate_right(tree, parent);
    2c07:	4c 89 f6             	mov    %r14,%rsi
    2c0a:	48 89 df             	mov    %rbx,%rdi
    parent->left = min;
    return;
  }

  parent->right = min;
}
    2c0d:	5b                   	pop    %rbx
    2c0e:	5d                   	pop    %rbp
    2c0f:	41 5c                	pop    %r12
    2c11:	41 5e                	pop    %r14
        avl_post_delete(tree, parent);
        return;
      }

      if (parent->left->balance == 0) {
        avl_rotate_right(tree, parent);
    2c13:	e9 30 fd ff ff       	jmpq   2948 <avl_rotate_right.isra.2>
        return;
      }

      if (parent->left->balance == -1) {
    2c18:	fe c0                	inc    %al
    2c1a:	74 08                	je     2c24 <avl_delete_worker+0xf5>
        avl_rotate_right(tree, parent);
        avl_post_delete(tree, parent->parent);
        return;
      }

      avl_rotate_left(tree, parent->left);
    2c1c:	48 89 df             	mov    %rbx,%rdi
    2c1f:	e8 89 fd ff ff       	callq  29ad <avl_rotate_left.isra.3>
      avl_rotate_right(tree, parent);
    2c24:	4c 89 f6             	mov    %r14,%rsi
    2c27:	48 89 df             	mov    %rbx,%rdi
    2c2a:	e8 19 fd ff ff       	callq  2948 <avl_rotate_right.isra.2>
      avl_post_delete(tree, parent->parent);
    2c2f:	49 8b 76 10          	mov    0x10(%r14),%rsi
    2c33:	eb 65                	jmp    2c9a <avl_delete_worker+0x16b>
      return;
    }
  }

  if (node->left == NULL) {
    if (parent == NULL) {
    2c35:	4d 85 f6             	test   %r14,%r14
    2c38:	75 11                	jne    2c4b <avl_delete_worker+0x11c>
      tree->root = node->right;
    2c3a:	48 89 5f 10          	mov    %rbx,0x10(%rdi)
      node->right->parent = NULL;
    2c3e:	48 c7 43 10 00 00 00 	movq   $0x0,0x10(%rbx)
    2c45:	00 
      return;
    2c46:	e9 c7 00 00 00       	jmpq   2d12 <avl_delete_worker+0x1e3>
    }

    node->right->parent = parent;

    if (parent->left == node)
    2c4b:	4d 3b 66 18          	cmp    0x18(%r14),%r12
      tree->root = node->right;
      node->right->parent = NULL;
      return;
    }

    node->right->parent = parent;
    2c4f:	4c 89 73 10          	mov    %r14,0x10(%rbx)

    if (parent->left == node)
    2c53:	75 06                	jne    2c5b <avl_delete_worker+0x12c>
      parent->left = node->right;
    2c55:	49 89 5e 18          	mov    %rbx,0x18(%r14)
    2c59:	eb 04                	jmp    2c5f <avl_delete_worker+0x130>

    else
      parent->right = node->right;
    2c5b:	49 89 5e 20          	mov    %rbx,0x20(%r14)

    avl_post_delete(tree, node->right);
    2c5f:	49 8b 74 24 20       	mov    0x20(%r12),%rsi
    2c64:	eb 34                	jmp    2c9a <avl_delete_worker+0x16b>
    return;
  }

  if (node->right == NULL) {
    2c66:	48 85 db             	test   %rbx,%rbx
    2c69:	75 3e                	jne    2ca9 <avl_delete_worker+0x17a>
    if (parent == NULL) {
    2c6b:	4d 85 f6             	test   %r14,%r14
    2c6e:	75 11                	jne    2c81 <avl_delete_worker+0x152>
      tree->root = node->left;
    2c70:	48 89 47 10          	mov    %rax,0x10(%rdi)
      node->left->parent = NULL;
    2c74:	48 c7 40 10 00 00 00 	movq   $0x0,0x10(%rax)
    2c7b:	00 
      return;
    2c7c:	e9 91 00 00 00       	jmpq   2d12 <avl_delete_worker+0x1e3>
    }

    node->left->parent = parent;

    if (parent->left == node)
    2c81:	49 3b 76 18          	cmp    0x18(%r14),%rsi
      tree->root = node->left;
      node->left->parent = NULL;
      return;
    }

    node->left->parent = parent;
    2c85:	4c 89 70 10          	mov    %r14,0x10(%rax)

    if (parent->left == node)
    2c89:	75 06                	jne    2c91 <avl_delete_worker+0x162>
      parent->left = node->left;
    2c8b:	49 89 46 18          	mov    %rax,0x18(%r14)
    2c8f:	eb 04                	jmp    2c95 <avl_delete_worker+0x166>

    else
      parent->right = node->left;
    2c91:	49 89 46 20          	mov    %rax,0x20(%r14)

    avl_post_delete(tree, node->left);
    2c95:	49 8b 74 24 18       	mov    0x18(%r12),%rsi
    parent->left = min;
    return;
  }

  parent->right = min;
}
    2c9a:	5a                   	pop    %rdx
      parent->left = node->left;

    else
      parent->right = node->left;

    avl_post_delete(tree, node->left);
    2c9b:	48 89 ef             	mov    %rbp,%rdi
    parent->left = min;
    return;
  }

  parent->right = min;
}
    2c9e:	5b                   	pop    %rbx
    2c9f:	5d                   	pop    %rbp
    2ca0:	41 5c                	pop    %r12
    2ca2:	41 5e                	pop    %r14
      parent->left = node->left;

    else
      parent->right = node->left;

    avl_post_delete(tree, node->left);
    2ca4:	e9 e5 fd ff ff       	jmpq   2a8e <avl_post_delete>
}

static struct avl_node *
avl_local_min(struct avl_node *node)
{
  while (node->left != NULL)
    2ca9:	48 8b 43 18          	mov    0x18(%rbx),%rax
    2cad:	48 85 c0             	test   %rax,%rax
    2cb0:	74 05                	je     2cb7 <avl_delete_worker+0x188>
    2cb2:	48 89 c3             	mov    %rax,%rbx
    2cb5:	eb f2                	jmp    2ca9 <avl_delete_worker+0x17a>
    avl_post_delete(tree, node->left);
    return;
  }

  min = avl_local_min(node->right);
  avl_delete_worker(tree, min);
    2cb7:	48 89 de             	mov    %rbx,%rsi
    2cba:	48 89 ef             	mov    %rbp,%rdi
    2cbd:	e8 6d fe ff ff       	callq  2b2f <avl_delete_worker>
  parent = node->parent;

  min->balance = node->balance;
    2cc2:	41 8a 54 24 30       	mov    0x30(%r12),%dl
    return;
  }

  min = avl_local_min(node->right);
  avl_delete_worker(tree, min);
  parent = node->parent;
    2cc7:	49 8b 44 24 10       	mov    0x10(%r12),%rax

  min->balance = node->balance;
    2ccc:	88 53 30             	mov    %dl,0x30(%rbx)
  min->parent = parent;
  min->left = node->left;
    2ccf:	49 8b 4c 24 18       	mov    0x18(%r12),%rcx
  min->right = node->right;
    2cd4:	49 8b 54 24 20       	mov    0x20(%r12),%rdx
  min = avl_local_min(node->right);
  avl_delete_worker(tree, min);
  parent = node->parent;

  min->balance = node->balance;
  min->parent = parent;
    2cd9:	48 89 43 10          	mov    %rax,0x10(%rbx)
  min->left = node->left;
  min->right = node->right;

  if (min->left != NULL)
    2cdd:	48 85 c9             	test   %rcx,%rcx
  avl_delete_worker(tree, min);
  parent = node->parent;

  min->balance = node->balance;
  min->parent = parent;
  min->left = node->left;
    2ce0:	48 89 4b 18          	mov    %rcx,0x18(%rbx)
  min->right = node->right;
    2ce4:	48 89 53 20          	mov    %rdx,0x20(%rbx)

  if (min->left != NULL)
    2ce8:	74 04                	je     2cee <avl_delete_worker+0x1bf>
    min->left->parent = min;
    2cea:	48 89 59 10          	mov    %rbx,0x10(%rcx)

  if (min->right != NULL)
    2cee:	48 85 d2             	test   %rdx,%rdx
    2cf1:	74 04                	je     2cf7 <avl_delete_worker+0x1c8>
    min->right->parent = min;
    2cf3:	48 89 5a 10          	mov    %rbx,0x10(%rdx)

  if (parent == NULL) {
    2cf7:	48 85 c0             	test   %rax,%rax
    2cfa:	75 06                	jne    2d02 <avl_delete_worker+0x1d3>
    tree->root = min;
    2cfc:	48 89 5d 10          	mov    %rbx,0x10(%rbp)
    return;
    2d00:	eb 10                	jmp    2d12 <avl_delete_worker+0x1e3>
  }

  if (parent->left == node) {
    2d02:	4c 3b 60 18          	cmp    0x18(%rax),%r12
    2d06:	75 06                	jne    2d0e <avl_delete_worker+0x1df>
    parent->left = min;
    2d08:	48 89 58 18          	mov    %rbx,0x18(%rax)
    return;
    2d0c:	eb 04                	jmp    2d12 <avl_delete_worker+0x1e3>
  }

  parent->right = min;
    2d0e:	48 89 58 20          	mov    %rbx,0x20(%rax)
}
    2d12:	58                   	pop    %rax
    2d13:	5b                   	pop    %rbx
    2d14:	5d                   	pop    %rbp
    2d15:	41 5c                	pop    %r12
    2d17:	41 5e                	pop    %r14
    2d19:	c3                   	retq   

0000000000002d1a <avl_init>:
#define LIST_HEAD(name)	struct list_head name = LIST_HEAD_INIT(name)

static inline void
INIT_LIST_HEAD(struct list_head *list)
{
	list->next = list->prev = list;
    2d1a:	48 89 7f 08          	mov    %rdi,0x8(%rdi)
    2d1e:	48 89 3f             	mov    %rdi,(%rdi)
 */
void
avl_init(struct avl_tree *tree, avl_tree_comp comp, bool allow_dups, void *ptr)
{
  list_init_head(&tree->list_head);
  tree->root = NULL;
    2d21:	48 c7 47 10 00 00 00 	movq   $0x0,0x10(%rdi)
    2d28:	00 
  tree->count = 0;
    2d29:	c7 47 18 00 00 00 00 	movl   $0x0,0x18(%rdi)
  tree->comp = comp;
    2d30:	48 89 77 20          	mov    %rsi,0x20(%rdi)
  tree->allow_dups = allow_dups;
    2d34:	88 57 1c             	mov    %dl,0x1c(%rdi)
  tree->cmp_ptr = ptr;
    2d37:	48 89 4f 28          	mov    %rcx,0x28(%rdi)
    2d3b:	c3                   	retq   

0000000000002d3c <avl_find>:
 * @return pointer to avl-node with key, NULL if no node with
 *    this key exists.
 */
struct avl_node *
avl_find(const struct avl_tree *tree, const void *key)
{
    2d3c:	48 83 ec 18          	sub    $0x18,%rsp
    2d40:	48 89 f8             	mov    %rdi,%rax
  struct avl_node *node;
  int diff;

  if (tree->root == NULL)
    2d43:	48 8b 7f 10          	mov    0x10(%rdi),%rdi
 * @return pointer to avl-node with key, NULL if no node with
 *    this key exists.
 */
struct avl_node *
avl_find(const struct avl_tree *tree, const void *key)
{
    2d47:	64 48 8b 14 25 28 00 	mov    %fs:0x28,%rdx
    2d4e:	00 00 
    2d50:	48 89 54 24 08       	mov    %rdx,0x8(%rsp)
    2d55:	31 d2                	xor    %edx,%edx
  struct avl_node *node;
  int diff;

  if (tree->root == NULL)
    2d57:	48 85 ff             	test   %rdi,%rdi
    2d5a:	75 04                	jne    2d60 <avl_find+0x24>
    return NULL;
    2d5c:	31 c0                	xor    %eax,%eax
    2d5e:	eb 19                	jmp    2d79 <avl_find+0x3d>

  node = avl_find_rec(tree->root, key, tree->comp, tree->cmp_ptr, &diff);
    2d60:	48 8b 48 28          	mov    0x28(%rax),%rcx
    2d64:	48 8b 50 20          	mov    0x20(%rax),%rdx
    2d68:	4c 8d 44 24 04       	lea    0x4(%rsp),%r8
    2d6d:	e8 7e fb ff ff       	callq  28f0 <avl_find_rec>

  return diff == 0 ? node : NULL;
    2d72:	83 7c 24 04 00       	cmpl   $0x0,0x4(%rsp)
    2d77:	75 e3                	jne    2d5c <avl_find+0x20>
}
    2d79:	48 8b 4c 24 08       	mov    0x8(%rsp),%rcx
    2d7e:	64 48 33 0c 25 28 00 	xor    %fs:0x28,%rcx
    2d85:	00 00 
    2d87:	74 05                	je     2d8e <avl_find+0x52>
    2d89:	e8 f2 f6 ff ff       	callq  2480 <__stack_chk_fail@plt>
    2d8e:	48 83 c4 18          	add    $0x18,%rsp
    2d92:	c3                   	retq   

0000000000002d93 <avl_find_lessequal>:
 * @param key pointer to specified key
 * @return pointer to avl-node, NULL if no node with
 *    key less or equal specified key exists.
 */
struct avl_node *
avl_find_lessequal(const struct avl_tree *tree, const void *key) {
    2d93:	41 56                	push   %r14
    2d95:	41 55                	push   %r13
    2d97:	41 54                	push   %r12
    2d99:	55                   	push   %rbp
    2d9a:	53                   	push   %rbx
    2d9b:	48 89 fb             	mov    %rdi,%rbx
    2d9e:	48 83 ec 10          	sub    $0x10,%rsp
  struct avl_node *node, *next;
  int diff;

  if (tree->root == NULL)
    2da2:	48 8b 7f 10          	mov    0x10(%rdi),%rdi
 * @param key pointer to specified key
 * @return pointer to avl-node, NULL if no node with
 *    key less or equal specified key exists.
 */
struct avl_node *
avl_find_lessequal(const struct avl_tree *tree, const void *key) {
    2da6:	64 48 8b 04 25 28 00 	mov    %fs:0x28,%rax
    2dad:	00 00 
    2daf:	48 89 44 24 08       	mov    %rax,0x8(%rsp)
    2db4:	31 c0                	xor    %eax,%eax
  struct avl_node *node, *next;
  int diff;

  if (tree->root == NULL)
    2db6:	48 85 ff             	test   %rdi,%rdi
    2db9:	75 04                	jne    2dbf <avl_find_lessequal+0x2c>
    return NULL;
    2dbb:	31 c0                	xor    %eax,%eax
    2dbd:	eb 73                	jmp    2e32 <avl_find_lessequal+0x9f>

  node = avl_find_rec(tree->root, key, tree->comp, tree->cmp_ptr, &diff);
    2dbf:	48 8b 4b 28          	mov    0x28(%rbx),%rcx
    2dc3:	48 8b 53 20          	mov    0x20(%rbx),%rdx
    2dc7:	4c 8d 44 24 04       	lea    0x4(%rsp),%r8
    2dcc:	49 89 f5             	mov    %rsi,%r13
    2dcf:	e8 1c fb ff ff       	callq  28f0 <avl_find_rec>
    2dd4:	49 89 c4             	mov    %rax,%r12

  /* go left as long as key<node.key */
  while (diff < 0) {
    2dd7:	83 7c 24 04 00       	cmpl   $0x0,0x4(%rsp)
    2ddc:	79 1f                	jns    2dfd <avl_find_lessequal+0x6a>
    2dde:	4d 8b 64 24 08       	mov    0x8(%r12),%r12
    if (list_is_first(&tree->list_head, &node->list)) {
    2de3:	4c 39 e3             	cmp    %r12,%rbx
    2de6:	74 d3                	je     2dbb <avl_find_lessequal+0x28>
      return NULL;
    }

    node = (struct avl_node *)node->list.prev;
    diff = (*tree->comp) (key, node->key, tree->cmp_ptr);
    2de8:	48 8b 53 28          	mov    0x28(%rbx),%rdx
    2dec:	49 8b 74 24 28       	mov    0x28(%r12),%rsi
    2df1:	4c 89 ef             	mov    %r13,%rdi
    2df4:	ff 53 20             	callq  *0x20(%rbx)
    2df7:	89 44 24 04          	mov    %eax,0x4(%rsp)
    2dfb:	eb da                	jmp    2dd7 <avl_find_lessequal+0x44>
    2dfd:	4c 89 e5             	mov    %r12,%rbp
  }

  /* go right as long as key>=next_node.key */
  next = node;
  while (diff >= 0) {
    2e00:	83 7c 24 04 00       	cmpl   $0x0,0x4(%rsp)
    2e05:	78 23                	js     2e2a <avl_find_lessequal+0x97>
    2e07:	4c 8b 75 00          	mov    0x0(%rbp),%r14
    node = next;
    if (list_is_last(&tree->list_head, &node->list)) {
    2e0b:	4c 39 f3             	cmp    %r14,%rbx
    2e0e:	74 1f                	je     2e2f <avl_find_lessequal+0x9c>
      break;
    }

    next = (struct avl_node *)node->list.next;
    diff = (*tree->comp) (key, next->key, tree->cmp_ptr);
    2e10:	48 8b 53 28          	mov    0x28(%rbx),%rdx
    2e14:	49 8b 76 28          	mov    0x28(%r14),%rsi
    2e18:	4c 89 ef             	mov    %r13,%rdi
    2e1b:	49 89 ec             	mov    %rbp,%r12
    2e1e:	4c 89 f5             	mov    %r14,%rbp
    2e21:	ff 53 20             	callq  *0x20(%rbx)
    2e24:	89 44 24 04          	mov    %eax,0x4(%rsp)
    2e28:	eb d6                	jmp    2e00 <avl_find_lessequal+0x6d>
    2e2a:	4c 89 e0             	mov    %r12,%rax
    2e2d:	eb 03                	jmp    2e32 <avl_find_lessequal+0x9f>
    2e2f:	48 89 e8             	mov    %rbp,%rax
  }
  return node;
}
    2e32:	48 8b 4c 24 08       	mov    0x8(%rsp),%rcx
    2e37:	64 48 33 0c 25 28 00 	xor    %fs:0x28,%rcx
    2e3e:	00 00 
    2e40:	74 05                	je     2e47 <avl_find_lessequal+0xb4>
    2e42:	e8 39 f6 ff ff       	callq  2480 <__stack_chk_fail@plt>
    2e47:	48 83 c4 10          	add    $0x10,%rsp
    2e4b:	5b                   	pop    %rbx
    2e4c:	5d                   	pop    %rbp
    2e4d:	41 5c                	pop    %r12
    2e4f:	41 5d                	pop    %r13
    2e51:	41 5e                	pop    %r14
    2e53:	c3                   	retq   

0000000000002e54 <avl_find_greaterequal>:
 * @param key pointer to specified key
 * @return pointer to avl-node, NULL if no node with
 *    key greater or equal specified key exists.
 */
struct avl_node *
avl_find_greaterequal(const struct avl_tree *tree, const void *key) {
    2e54:	41 56                	push   %r14
    2e56:	41 55                	push   %r13
    2e58:	41 54                	push   %r12
    2e5a:	55                   	push   %rbp
    2e5b:	53                   	push   %rbx
    2e5c:	48 89 fb             	mov    %rdi,%rbx
    2e5f:	48 83 ec 10          	sub    $0x10,%rsp
  struct avl_node *node, *next;
  int diff;

  if (tree->root == NULL)
    2e63:	48 8b 7f 10          	mov    0x10(%rdi),%rdi
 * @param key pointer to specified key
 * @return pointer to avl-node, NULL if no node with
 *    key greater or equal specified key exists.
 */
struct avl_node *
avl_find_greaterequal(const struct avl_tree *tree, const void *key) {
    2e67:	64 48 8b 04 25 28 00 	mov    %fs:0x28,%rax
    2e6e:	00 00 
    2e70:	48 89 44 24 08       	mov    %rax,0x8(%rsp)
    2e75:	31 c0                	xor    %eax,%eax
  struct avl_node *node, *next;
  int diff;

  if (tree->root == NULL)
    2e77:	48 85 ff             	test   %rdi,%rdi
    2e7a:	75 04                	jne    2e80 <avl_find_greaterequal+0x2c>
    return NULL;
    2e7c:	31 c0                	xor    %eax,%eax
    2e7e:	eb 72                	jmp    2ef2 <avl_find_greaterequal+0x9e>

  node = avl_find_rec(tree->root, key, tree->comp, tree->cmp_ptr, &diff);
    2e80:	48 8b 4b 28          	mov    0x28(%rbx),%rcx
    2e84:	48 8b 53 20          	mov    0x20(%rbx),%rdx
    2e88:	4c 8d 44 24 04       	lea    0x4(%rsp),%r8
    2e8d:	49 89 f5             	mov    %rsi,%r13
    2e90:	e8 5b fa ff ff       	callq  28f0 <avl_find_rec>
    2e95:	49 89 c4             	mov    %rax,%r12

  /* go right as long as key>node.key */
  while (diff > 0) {
    2e98:	83 7c 24 04 00       	cmpl   $0x0,0x4(%rsp)
    2e9d:	7e 1e                	jle    2ebd <avl_find_greaterequal+0x69>
    2e9f:	4d 8b 24 24          	mov    (%r12),%r12
    if (list_is_last(&tree->list_head, &node->list)) {
    2ea3:	4c 39 e3             	cmp    %r12,%rbx
    2ea6:	74 d4                	je     2e7c <avl_find_greaterequal+0x28>
      return NULL;
    }

    node = (struct avl_node *)node->list.next;
    diff = (*tree->comp) (key, node->key, tree->cmp_ptr);
    2ea8:	48 8b 53 28          	mov    0x28(%rbx),%rdx
    2eac:	49 8b 74 24 28       	mov    0x28(%r12),%rsi
    2eb1:	4c 89 ef             	mov    %r13,%rdi
    2eb4:	ff 53 20             	callq  *0x20(%rbx)
    2eb7:	89 44 24 04          	mov    %eax,0x4(%rsp)
    2ebb:	eb db                	jmp    2e98 <avl_find_greaterequal+0x44>
    2ebd:	4c 89 e5             	mov    %r12,%rbp
  }

  /* go left as long as key<=next_node.key */
  next = node;
  while (diff <= 0) {
    2ec0:	83 7c 24 04 00       	cmpl   $0x0,0x4(%rsp)
    2ec5:	7f 23                	jg     2eea <avl_find_greaterequal+0x96>
    2ec7:	4c 8b 75 08          	mov    0x8(%rbp),%r14
    node = next;
    if (list_is_first(&tree->list_head, &node->list)) {
    2ecb:	4c 39 f3             	cmp    %r14,%rbx
    2ece:	74 1f                	je     2eef <avl_find_greaterequal+0x9b>
      break;
    }

    next = (struct avl_node *)node->list.prev;
    diff = (*tree->comp) (key, next->key, tree->cmp_ptr);
    2ed0:	48 8b 53 28          	mov    0x28(%rbx),%rdx
    2ed4:	49 8b 76 28          	mov    0x28(%r14),%rsi
    2ed8:	4c 89 ef             	mov    %r13,%rdi
    2edb:	49 89 ec             	mov    %rbp,%r12
    2ede:	4c 89 f5             	mov    %r14,%rbp
    2ee1:	ff 53 20             	callq  *0x20(%rbx)
    2ee4:	89 44 24 04          	mov    %eax,0x4(%rsp)
    2ee8:	eb d6                	jmp    2ec0 <avl_find_greaterequal+0x6c>
    2eea:	4c 89 e0             	mov    %r12,%rax
    2eed:	eb 03                	jmp    2ef2 <avl_find_greaterequal+0x9e>
    2eef:	48 89 e8             	mov    %rbp,%rax
  }
  return node;
}
    2ef2:	48 8b 4c 24 08       	mov    0x8(%rsp),%rcx
    2ef7:	64 48 33 0c 25 28 00 	xor    %fs:0x28,%rcx
    2efe:	00 00 
    2f00:	74 05                	je     2f07 <avl_find_greaterequal+0xb3>
    2f02:	e8 79 f5 ff ff       	callq  2480 <__stack_chk_fail@plt>
    2f07:	48 83 c4 10          	add    $0x10,%rsp
    2f0b:	5b                   	pop    %rbx
    2f0c:	5d                   	pop    %rbp
    2f0d:	41 5c                	pop    %r12
    2f0f:	41 5d                	pop    %r13
    2f11:	41 5e                	pop    %r14
    2f13:	c3                   	retq   

0000000000002f14 <avl_insert>:
 * @return 0 if node was inserted successfully, -1 if it was not inserted
 *   because of a key collision
 */
int
avl_insert(struct avl_tree *tree, struct avl_node *new)
{
    2f14:	41 55                	push   %r13
    2f16:	41 54                	push   %r12
    2f18:	55                   	push   %rbp
    2f19:	53                   	push   %rbx
    2f1a:	48 89 fd             	mov    %rdi,%rbp
    2f1d:	48 89 f3             	mov    %rsi,%rbx
    2f20:	48 83 ec 18          	sub    $0x18,%rsp
  new->parent = NULL;

  new->left = NULL;
  new->right = NULL;

  new->balance = 0;
    2f24:	c6 46 30 00          	movb   $0x0,0x30(%rsi)
  new->leader = true;

  if (tree->root == NULL) {
    2f28:	48 8b 7f 10          	mov    0x10(%rdi),%rdi
 * @return 0 if node was inserted successfully, -1 if it was not inserted
 *   because of a key collision
 */
int
avl_insert(struct avl_tree *tree, struct avl_node *new)
{
    2f2c:	64 48 8b 04 25 28 00 	mov    %fs:0x28,%rax
    2f33:	00 00 
    2f35:	48 89 44 24 08       	mov    %rax,0x8(%rsp)
    2f3a:	31 c0                	xor    %eax,%eax
  struct avl_node *node, *next, *last;
  int diff;

  new->parent = NULL;
    2f3c:	48 c7 46 10 00 00 00 	movq   $0x0,0x10(%rsi)
    2f43:	00 

  new->left = NULL;
    2f44:	48 c7 46 18 00 00 00 	movq   $0x0,0x18(%rsi)
    2f4b:	00 
  new->right = NULL;

  new->balance = 0;
  new->leader = true;

  if (tree->root == NULL) {
    2f4c:	48 85 ff             	test   %rdi,%rdi
  int diff;

  new->parent = NULL;

  new->left = NULL;
  new->right = NULL;
    2f4f:	48 c7 46 20 00 00 00 	movq   $0x0,0x20(%rsi)
    2f56:	00 

  new->balance = 0;
  new->leader = true;
    2f57:	c6 46 31 01          	movb   $0x1,0x31(%rsi)

  if (tree->root == NULL) {
    2f5b:	75 23                	jne    2f80 <avl_insert+0x6c>
#define	list_for_each_prev_safe(p, n, h) for (p = (h)->prev, n = p->prev; p != (h); p = n, n = p->prev)

static inline void
list_add(struct list_head *_new, struct list_head *head)
{
	_list_add(_new, head, head->next);
    2f5d:	48 8b 45 00          	mov    0x0(%rbp),%rax
static inline void
_list_add(struct list_head *_new, struct list_head *prev,
    struct list_head *next)
{

	next->prev = _new;
    2f61:	48 89 70 08          	mov    %rsi,0x8(%rax)
	_new->next = next;
    2f65:	48 89 06             	mov    %rax,(%rsi)
	_new->prev = prev;
    2f68:	48 89 6e 08          	mov    %rbp,0x8(%rsi)
	prev->next = _new;
    2f6c:	48 89 75 00          	mov    %rsi,0x0(%rbp)
    list_add_head(&tree->list_head, &new->list);
    tree->root = new;
    2f70:	48 89 75 10          	mov    %rsi,0x10(%rbp)
    tree->count = 1;
    2f74:	c7 45 18 01 00 00 00 	movl   $0x1,0x18(%rbp)
    2f7b:	e9 2f 01 00 00       	jmpq   30af <avl_insert+0x19b>
    return 0;
  }

  node = avl_find_rec(tree->root, new->key, tree->comp, tree->cmp_ptr, &diff);
    2f80:	48 8b 4d 28          	mov    0x28(%rbp),%rcx
    2f84:	48 8b 55 20          	mov    0x20(%rbp),%rdx
    2f88:	4c 8d 44 24 04       	lea    0x4(%rsp),%r8
    2f8d:	48 8b 76 28          	mov    0x28(%rsi),%rsi
    2f91:	e8 5a f9 ff ff       	callq  28f0 <avl_find_rec>
    2f96:	49 89 c4             	mov    %rax,%r12
    2f99:	49 89 c5             	mov    %rax,%r13
    2f9c:	49 8b 45 00          	mov    0x0(%r13),%rax

  last = node;

  while (!list_is_last(&tree->list_head, &last->list)) {
    2fa0:	48 39 c5             	cmp    %rax,%rbp
    2fa3:	74 06                	je     2fab <avl_insert+0x97>
    next = list_next_element(last, list);
    if (next->leader) {
    2fa5:	80 78 31 00          	cmpb   $0x0,0x31(%rax)
    2fa9:	74 1a                	je     2fc5 <avl_insert+0xb1>
      break;
    }
    last = next;
  }

  diff = (*tree->comp) (new->key, node->key, tree->cmp_ptr);
    2fab:	48 8b 55 28          	mov    0x28(%rbp),%rdx
    2faf:	49 8b 74 24 28       	mov    0x28(%r12),%rsi
    2fb4:	48 8b 7b 28          	mov    0x28(%rbx),%rdi
    2fb8:	ff 55 20             	callq  *0x20(%rbp)

  if (diff == 0) {
    2fbb:	85 c0                	test   %eax,%eax
      break;
    }
    last = next;
  }

  diff = (*tree->comp) (new->key, node->key, tree->cmp_ptr);
    2fbd:	89 44 24 04          	mov    %eax,0x4(%rsp)

  if (diff == 0) {
    2fc1:	74 07                	je     2fca <avl_insert+0xb6>
    2fc3:	eb 2e                	jmp    2ff3 <avl_insert+0xdf>
    2fc5:	49 89 c5             	mov    %rax,%r13
    2fc8:	eb d2                	jmp    2f9c <avl_insert+0x88>
    if (!tree->allow_dups)
    2fca:	80 7d 1c 00          	cmpb   $0x0,0x1c(%rbp)
    2fce:	0f 84 df 00 00 00    	je     30b3 <avl_insert+0x19f>
#define	list_for_each_prev_safe(p, n, h) for (p = (h)->prev, n = p->prev; p != (h); p = n, n = p->prev)

static inline void
list_add(struct list_head *_new, struct list_head *head)
{
	_list_add(_new, head, head->next);
    2fd4:	49 8b 55 00          	mov    0x0(%r13),%rdx
      return -1;

    new->leader = 0;
    2fd8:	c6 43 31 00          	movb   $0x0,0x31(%rbx)
static inline void
_list_add(struct list_head *_new, struct list_head *prev,
    struct list_head *next)
{

	next->prev = _new;
    2fdc:	48 89 5a 08          	mov    %rbx,0x8(%rdx)
	_new->next = next;
    2fe0:	48 89 13             	mov    %rdx,(%rbx)
	_new->prev = prev;
    2fe3:	4c 89 6b 08          	mov    %r13,0x8(%rbx)
	prev->next = _new;
    2fe7:	49 89 5d 00          	mov    %rbx,0x0(%r13)

static void
avl_insert_after(struct avl_tree *tree, struct avl_node *pos_node, struct avl_node *node)
{
  list_add_after(&pos_node->list, &node->list);
  tree->count++;
    2feb:	ff 45 18             	incl   0x18(%rbp)
    2fee:	e9 c3 00 00 00       	jmpq   30b6 <avl_insert+0x1a2>

    avl_insert_after(tree, last, new);
    return 0;
  }

  if (node->balance == 1) {
    2ff3:	41 8a 54 24 30       	mov    0x30(%r12),%dl
    2ff8:	80 fa 01             	cmp    $0x1,%dl
    2ffb:	75 2b                	jne    3028 <avl_insert+0x114>
}

static inline void
list_add_tail(struct list_head *_new, struct list_head *head)
{
	_list_add(_new, head->prev, head);
    2ffd:	49 8b 44 24 08       	mov    0x8(%r12),%rax
static inline void
_list_add(struct list_head *_new, struct list_head *prev,
    struct list_head *next)
{

	next->prev = _new;
    3002:	49 89 5c 24 08       	mov    %rbx,0x8(%r12)
	_new->next = next;
    3007:	4c 89 23             	mov    %r12,(%rbx)
	_new->prev = prev;
    300a:	48 89 43 08          	mov    %rax,0x8(%rbx)
	prev->next = _new;
    300e:	48 89 18             	mov    %rbx,(%rax)

static void
avl_insert_before(struct avl_tree *tree, struct avl_node *pos_node, struct avl_node *node)
{
  list_add_before(&pos_node->list, &node->list);
  tree->count++;
    3011:	ff 45 18             	incl   0x18(%rbp)
  }

  if (node->balance == 1) {
    avl_insert_before(tree, node, new);

    node->balance = 0;
    3014:	41 c6 44 24 30 00    	movb   $0x0,0x30(%r12)
    new->parent = node;
    301a:	4c 89 63 10          	mov    %r12,0x10(%rbx)
    node->left = new;
    301e:	49 89 5c 24 18       	mov    %rbx,0x18(%r12)
    3023:	e9 87 00 00 00       	jmpq   30af <avl_insert+0x19b>
    return 0;
  }

  if (node->balance == -1) {
    3028:	fe c2                	inc    %dl
    302a:	75 27                	jne    3053 <avl_insert+0x13f>
#define	list_for_each_prev_safe(p, n, h) for (p = (h)->prev, n = p->prev; p != (h); p = n, n = p->prev)

static inline void
list_add(struct list_head *_new, struct list_head *head)
{
	_list_add(_new, head, head->next);
    302c:	49 8b 45 00          	mov    0x0(%r13),%rax
static inline void
_list_add(struct list_head *_new, struct list_head *prev,
    struct list_head *next)
{

	next->prev = _new;
    3030:	48 89 58 08          	mov    %rbx,0x8(%rax)
	_new->next = next;
    3034:	48 89 03             	mov    %rax,(%rbx)
	_new->prev = prev;
    3037:	4c 89 6b 08          	mov    %r13,0x8(%rbx)
	prev->next = _new;
    303b:	49 89 5d 00          	mov    %rbx,0x0(%r13)

static void
avl_insert_after(struct avl_tree *tree, struct avl_node *pos_node, struct avl_node *node)
{
  list_add_after(&pos_node->list, &node->list);
  tree->count++;
    303f:	ff 45 18             	incl   0x18(%rbp)
  }

  if (node->balance == -1) {
    avl_insert_after(tree, last, new);

    node->balance = 0;
    3042:	41 c6 44 24 30 00    	movb   $0x0,0x30(%r12)
    new->parent = node;
    3048:	4c 89 63 10          	mov    %r12,0x10(%rbx)
    node->right = new;
    304c:	49 89 5c 24 20       	mov    %rbx,0x20(%r12)
    3051:	eb 5c                	jmp    30af <avl_insert+0x19b>
    return 0;
  }

  if (diff < 0) {
    3053:	85 c0                	test   %eax,%eax
    3055:	79 28                	jns    307f <avl_insert+0x16b>
}

static inline void
list_add_tail(struct list_head *_new, struct list_head *head)
{
	_list_add(_new, head->prev, head);
    3057:	49 8b 44 24 08       	mov    0x8(%r12),%rax
static inline void
_list_add(struct list_head *_new, struct list_head *prev,
    struct list_head *next)
{

	next->prev = _new;
    305c:	49 89 5c 24 08       	mov    %rbx,0x8(%r12)
	_new->next = next;
    3061:	4c 89 23             	mov    %r12,(%rbx)
	_new->prev = prev;
    3064:	48 89 43 08          	mov    %rax,0x8(%rbx)
	prev->next = _new;
    3068:	48 89 18             	mov    %rbx,(%rax)

static void
avl_insert_before(struct avl_tree *tree, struct avl_node *pos_node, struct avl_node *node)
{
  list_add_before(&pos_node->list, &node->list);
  tree->count++;
    306b:	ff 45 18             	incl   0x18(%rbp)
  }

  if (diff < 0) {
    avl_insert_before(tree, node, new);

    node->balance = -1;
    306e:	41 c6 44 24 30 ff    	movb   $0xff,0x30(%r12)
    new->parent = node;
    3074:	4c 89 63 10          	mov    %r12,0x10(%rbx)
    node->left = new;
    3078:	49 89 5c 24 18       	mov    %rbx,0x18(%r12)
    307d:	eb 25                	jmp    30a4 <avl_insert+0x190>
#define	list_for_each_prev_safe(p, n, h) for (p = (h)->prev, n = p->prev; p != (h); p = n, n = p->prev)

static inline void
list_add(struct list_head *_new, struct list_head *head)
{
	_list_add(_new, head, head->next);
    307f:	49 8b 45 00          	mov    0x0(%r13),%rax
static inline void
_list_add(struct list_head *_new, struct list_head *prev,
    struct list_head *next)
{

	next->prev = _new;
    3083:	48 89 58 08          	mov    %rbx,0x8(%rax)
	_new->next = next;
    3087:	48 89 03             	mov    %rax,(%rbx)
	_new->prev = prev;
    308a:	4c 89 6b 08          	mov    %r13,0x8(%rbx)
	prev->next = _new;
    308e:	49 89 5d 00          	mov    %rbx,0x0(%r13)

static void
avl_insert_after(struct avl_tree *tree, struct avl_node *pos_node, struct avl_node *node)
{
  list_add_after(&pos_node->list, &node->list);
  tree->count++;
    3092:	ff 45 18             	incl   0x18(%rbp)
    return 0;
  }

  avl_insert_after(tree, last, new);

  node->balance = 1;
    3095:	41 c6 44 24 30 01    	movb   $0x1,0x30(%r12)
  new->parent = node;
    309b:	4c 89 63 10          	mov    %r12,0x10(%rbx)
  node->right = new;
    309f:	49 89 5c 24 20       	mov    %rbx,0x20(%r12)
  post_insert(tree, node);
    30a4:	4c 89 e6             	mov    %r12,%rsi
    30a7:	48 89 ef             	mov    %rbp,%rdi
    30aa:	e8 63 f9 ff ff       	callq  2a12 <post_insert>
  return 0;
    30af:	31 c0                	xor    %eax,%eax
    30b1:	eb 03                	jmp    30b6 <avl_insert+0x1a2>

  diff = (*tree->comp) (new->key, node->key, tree->cmp_ptr);

  if (diff == 0) {
    if (!tree->allow_dups)
      return -1;
    30b3:	83 c8 ff             	or     $0xffffffff,%eax
  node->balance = 1;
  new->parent = node;
  node->right = new;
  post_insert(tree, node);
  return 0;
}
    30b6:	48 8b 4c 24 08       	mov    0x8(%rsp),%rcx
    30bb:	64 48 33 0c 25 28 00 	xor    %fs:0x28,%rcx
    30c2:	00 00 
    30c4:	74 05                	je     30cb <avl_insert+0x1b7>
    30c6:	e8 b5 f3 ff ff       	callq  2480 <__stack_chk_fail@plt>
    30cb:	48 83 c4 18          	add    $0x18,%rsp
    30cf:	5b                   	pop    %rbx
    30d0:	5d                   	pop    %rbp
    30d1:	41 5c                	pop    %r12
    30d3:	41 5d                	pop    %r13
    30d5:	c3                   	retq   

00000000000030d6 <avl_delete>:
 * @param tree pointer to tree
 * @param node pointer to node
 */
void
avl_delete(struct avl_tree *tree, struct avl_node *node)
{
    30d6:	52                   	push   %rdx
  struct avl_node *next;
  struct avl_node *parent;
  struct avl_node *left;
  struct avl_node *right;
  if (node->leader) {
    30d7:	80 7e 31 00          	cmpb   $0x0,0x31(%rsi)
 * @param tree pointer to tree
 * @param node pointer to node
 */
void
avl_delete(struct avl_tree *tree, struct avl_node *node)
{
    30db:	49 89 fb             	mov    %rdi,%r11
    30de:	49 89 f2             	mov    %rsi,%r10
  struct avl_node *next;
  struct avl_node *parent;
  struct avl_node *left;
  struct avl_node *right;
  if (node->leader) {
    30e1:	74 70                	je     3153 <avl_delete+0x7d>
    if (tree->allow_dups
    30e3:	80 7f 1c 00          	cmpb   $0x0,0x1c(%rdi)
    30e7:	74 5f                	je     3148 <avl_delete+0x72>
    30e9:	48 8b 06             	mov    (%rsi),%rax
        && !list_is_last(&tree->list_head, &node->list)
    30ec:	48 39 c7             	cmp    %rax,%rdi
    30ef:	74 57                	je     3148 <avl_delete+0x72>
        && !(next = list_next_element(node, list))->leader) {
    30f1:	80 78 31 00          	cmpb   $0x0,0x31(%rax)
    30f5:	75 51                	jne    3148 <avl_delete+0x72>
      next->leader = true;
    30f7:	c6 40 31 01          	movb   $0x1,0x31(%rax)
      next->balance = node->balance;
    30fb:	8a 56 30             	mov    0x30(%rsi),%dl
    30fe:	88 50 30             	mov    %dl,0x30(%rax)

      parent = node->parent;
    3101:	48 8b 56 10          	mov    0x10(%rsi),%rdx
      left = node->left;
      right = node->right;
    3105:	49 8b 4a 20          	mov    0x20(%r10),%rcx
        && !(next = list_next_element(node, list))->leader) {
      next->leader = true;
      next->balance = node->balance;

      parent = node->parent;
      left = node->left;
    3109:	48 8b 76 18          	mov    0x18(%rsi),%rsi

      next->parent = parent;
      next->left = left;
      next->right = right;

      if (parent == NULL)
    310d:	48 85 d2             	test   %rdx,%rdx

      parent = node->parent;
      left = node->left;
      right = node->right;

      next->parent = parent;
    3110:	48 89 50 10          	mov    %rdx,0x10(%rax)
      next->left = left;
    3114:	48 89 70 18          	mov    %rsi,0x18(%rax)
      next->right = right;
    3118:	48 89 48 20          	mov    %rcx,0x20(%rax)

      if (parent == NULL)
    311c:	75 06                	jne    3124 <avl_delete+0x4e>
        tree->root = next;
    311e:	48 89 47 10          	mov    %rax,0x10(%rdi)
    3122:	eb 10                	jmp    3134 <avl_delete+0x5e>

      else {
        if (node == parent->left)
    3124:	4c 3b 52 18          	cmp    0x18(%rdx),%r10
    3128:	75 06                	jne    3130 <avl_delete+0x5a>
          parent->left = next;
    312a:	48 89 42 18          	mov    %rax,0x18(%rdx)
    312e:	eb 04                	jmp    3134 <avl_delete+0x5e>

        else
          parent->right = next;
    3130:	48 89 42 20          	mov    %rax,0x20(%rdx)
      }

      if (left != NULL)
    3134:	48 85 f6             	test   %rsi,%rsi
    3137:	74 04                	je     313d <avl_delete+0x67>
        left->parent = next;
    3139:	48 89 46 10          	mov    %rax,0x10(%rsi)

      if (right != NULL)
    313d:	48 85 c9             	test   %rcx,%rcx
    3140:	74 11                	je     3153 <avl_delete+0x7d>
        right->parent = next;
    3142:	48 89 41 10          	mov    %rax,0x10(%rcx)
    3146:	eb 0b                	jmp    3153 <avl_delete+0x7d>
    }

    else
      avl_delete_worker(tree, node);
    3148:	4c 89 d6             	mov    %r10,%rsi
    314b:	4c 89 df             	mov    %r11,%rdi
    314e:	e8 dc f9 ff ff       	callq  2b2f <avl_delete_worker>
}

static inline void
_list_del(struct list_head *entry)
{
	entry->next->prev = entry->prev;
    3153:	49 8b 52 08          	mov    0x8(%r10),%rdx
    3157:	49 8b 02             	mov    (%r10),%rax
    315a:	48 89 50 08          	mov    %rdx,0x8(%rax)
	entry->prev->next = entry->next;
    315e:	49 8b 52 08          	mov    0x8(%r10),%rdx
    3162:	48 89 02             	mov    %rax,(%rdx)

static inline void
list_del(struct list_head *entry)
{
	_list_del(entry);
	entry->next = entry->prev = NULL;
    3165:	49 c7 42 08 00 00 00 	movq   $0x0,0x8(%r10)
    316c:	00 
    316d:	49 c7 02 00 00 00 00 	movq   $0x0,(%r10)

static void
avl_remove(struct avl_tree *tree, struct avl_node *node)
{
  list_remove(&node->list);
  tree->count--;
    3174:	41 ff 4b 18          	decl   0x18(%r11)
    else
      avl_delete_worker(tree, node);
  }

  avl_remove(tree, node);
}
    3178:	58                   	pop    %rax
    3179:	c3                   	retq   

000000000000317a <avl_strcmp>:
#include "avl-cmp.h"

int
avl_strcmp(const void *k1, const void *k2, void *ptr)
{
	return strcmp(k1, k2);
    317a:	e9 21 f4 ff ff       	jmpq   25a0 <strcmp@plt>

000000000000317f <blob_buffer_grow>:
#include "blob.h"

static bool
blob_buffer_grow(struct blob_buf *buf, int minlen)
{
	int delta = ((minlen / 256) + 1) * 256;
    317f:	89 f0                	mov    %esi,%eax

#include "blob.h"

static bool
blob_buffer_grow(struct blob_buf *buf, int minlen)
{
    3181:	55                   	push   %rbp
    3182:	48 89 fd             	mov    %rdi,%rbp
	int delta = ((minlen / 256) + 1) * 256;
    3185:	99                   	cltd   
    3186:	bf 00 01 00 00       	mov    $0x100,%edi

#include "blob.h"

static bool
blob_buffer_grow(struct blob_buf *buf, int minlen)
{
    318b:	53                   	push   %rbx
	int delta = ((minlen / 256) + 1) * 256;
    318c:	f7 ff                	idiv   %edi

#include "blob.h"

static bool
blob_buffer_grow(struct blob_buf *buf, int minlen)
{
    318e:	51                   	push   %rcx
	int delta = ((minlen / 256) + 1) * 256;
	buf->buflen += delta;
    318f:	8b 75 10             	mov    0x10(%rbp),%esi
	buf->buf = realloc(buf->buf, buf->buflen);
    3192:	48 8b 7d 18          	mov    0x18(%rbp),%rdi
#include "blob.h"

static bool
blob_buffer_grow(struct blob_buf *buf, int minlen)
{
	int delta = ((minlen / 256) + 1) * 256;
    3196:	8d 48 01             	lea    0x1(%rax),%ecx
    3199:	89 cb                	mov    %ecx,%ebx
    319b:	c1 e3 08             	shl    $0x8,%ebx
	buf->buflen += delta;
    319e:	01 de                	add    %ebx,%esi
    31a0:	89 75 10             	mov    %esi,0x10(%rbp)
	buf->buf = realloc(buf->buf, buf->buflen);
    31a3:	48 63 f6             	movslq %esi,%rsi
    31a6:	e8 85 f4 ff ff       	callq  2630 <realloc@plt>
	if (buf->buf)
    31ab:	48 85 c0             	test   %rax,%rax
static bool
blob_buffer_grow(struct blob_buf *buf, int minlen)
{
	int delta = ((minlen / 256) + 1) * 256;
	buf->buflen += delta;
	buf->buf = realloc(buf->buf, buf->buflen);
    31ae:	48 89 45 18          	mov    %rax,0x18(%rbp)
	if (buf->buf)
    31b2:	74 14                	je     31c8 <blob_buffer_grow+0x49>
    {
      __warn_memset_zero_len ();
      return __dest;
    }
#endif
  return __builtin___memset_chk (__dest, __ch, __len, __bos0 (__dest));
    31b4:	48 63 55 10          	movslq 0x10(%rbp),%rdx
		memset(buf->buf + buf->buflen - delta, 0, delta);
    31b8:	48 63 cb             	movslq %ebx,%rcx
    31bb:	48 29 ca             	sub    %rcx,%rdx
    31be:	48 01 c2             	add    %rax,%rdx
    31c1:	31 c0                	xor    %eax,%eax
    31c3:	48 89 d7             	mov    %rdx,%rdi
    31c6:	f3 aa                	rep stos %al,%es:(%rdi)
	return !!buf->buf;
    31c8:	48 83 7d 18 00       	cmpq   $0x0,0x18(%rbp)
}
    31cd:	5a                   	pop    %rdx
    31ce:	5b                   	pop    %rbx
    31cf:	5d                   	pop    %rbp
	int delta = ((minlen / 256) + 1) * 256;
	buf->buflen += delta;
	buf->buf = realloc(buf->buf, buf->buflen);
	if (buf->buf)
		memset(buf->buf + buf->buflen - delta, 0, delta);
	return !!buf->buf;
    31d0:	0f 95 c0             	setne  %al
}
    31d3:	c3                   	retq   

00000000000031d4 <blob_pad_len>:
 * blob_len: returns the length of the attribute's payload
 */
static inline unsigned int
blob_len(const struct blob_attr *attr)
{
	return (be32_to_cpu(attr->id_len) & BLOB_ATTR_LEN_MASK) - sizeof(struct blob_attr);
    31d4:	8b 07                	mov    (%rdi),%eax
    31d6:	0f c8                	bswap  %eax
 */
static inline unsigned int
blob_pad_len(const struct blob_attr *attr)
{
	int len = blob_raw_len(attr);
	len = (len + BLOB_ATTR_ALIGN - 1) & ~(BLOB_ATTR_ALIGN - 1);
    31d8:	25 ff ff ff 00       	and    $0xffffff,%eax
    31dd:	83 c0 03             	add    $0x3,%eax
	return len;
    31e0:	83 e0 fc             	and    $0xfffffffc,%eax
}
    31e3:	c3                   	retq   

00000000000031e4 <blob_buf_grow>:
void
blob_buf_grow(struct blob_buf *buf, int required)
{
	int offset_head = attr_to_offset(buf, buf->head);

	if (!buf->grow || !buf->grow(buf, required))
    31e4:	48 8b 47 08          	mov    0x8(%rdi),%rax
    31e8:	48 85 c0             	test   %rax,%rax
    31eb:	74 33                	je     3220 <blob_buf_grow+0x3c>
	return (char *)attr - (char *) buf->buf + BLOB_COOKIE;
}

void
blob_buf_grow(struct blob_buf *buf, int required)
{
    31ed:	41 54                	push   %r12
    31ef:	4c 8b 67 18          	mov    0x18(%rdi),%r12
    31f3:	55                   	push   %rbp
	int offset_head = attr_to_offset(buf, buf->head);
    31f4:	48 8b 2f             	mov    (%rdi),%rbp
	return (char *)attr - (char *) buf->buf + BLOB_COOKIE;
}

void
blob_buf_grow(struct blob_buf *buf, int required)
{
    31f7:	53                   	push   %rbx
    31f8:	48 89 fb             	mov    %rdi,%rbx
	int offset_head = attr_to_offset(buf, buf->head);

	if (!buf->grow || !buf->grow(buf, required))
    31fb:	ff d0                	callq  *%rax
    31fd:	84 c0                	test   %al,%al
    31ff:	74 1b                	je     321c <blob_buf_grow+0x38>
		return;

	buf->head = offset_to_attr(buf, offset_head);
    3201:	4c 29 e5             	sub    %r12,%rbp
    3204:	48 8b 43 18          	mov    0x18(%rbx),%rax
    3208:	81 c5 67 45 23 01    	add    $0x1234567,%ebp
    320e:	48 63 ed             	movslq %ebp,%rbp
    3211:	48 8d 84 28 99 ba dc 	lea    -0x1234567(%rax,%rbp,1),%rax
    3218:	fe 
    3219:	48 89 03             	mov    %rax,(%rbx)
}
    321c:	5b                   	pop    %rbx
    321d:	5d                   	pop    %rbp
    321e:	41 5c                	pop    %r12
    3220:	c3                   	retq   

0000000000003221 <blob_buf_free>:
	return 0;
}

void
blob_buf_free(struct blob_buf *buf)
{
    3221:	53                   	push   %rbx
    3222:	48 89 fb             	mov    %rdi,%rbx
	free(buf->buf);
    3225:	48 8b 7f 18          	mov    0x18(%rdi),%rdi
    3229:	e8 32 f1 ff ff       	callq  2360 <free@plt>
	buf->buf = NULL;
    322e:	48 c7 43 18 00 00 00 	movq   $0x0,0x18(%rbx)
    3235:	00 
	buf->buflen = 0;
    3236:	c7 43 10 00 00 00 00 	movl   $0x0,0x10(%rbx)
}
    323d:	5b                   	pop    %rbx
    323e:	c3                   	retq   

000000000000323f <blob_fill_pad>:

void
blob_fill_pad(struct blob_attr *attr)
{
    323f:	48 89 fa             	mov    %rdi,%rdx
	char *buf = (char *) attr;
	int len = blob_pad_len(attr);
    3242:	e8 8d ff ff ff       	callq  31d4 <blob_pad_len>
 * blob_len: returns the length of the attribute's payload
 */
static inline unsigned int
blob_len(const struct blob_attr *attr)
{
	return (be32_to_cpu(attr->id_len) & BLOB_ATTR_LEN_MASK) - sizeof(struct blob_attr);
    3247:	8b 0f                	mov    (%rdi),%ecx
	int delta = len - blob_raw_len(attr);
    3249:	89 c6                	mov    %eax,%esi
    324b:	0f c9                	bswap  %ecx
    324d:	81 e1 ff ff ff 00    	and    $0xffffff,%ecx
    3253:	29 ce                	sub    %ecx,%esi

	if (delta > 0)
    3255:	85 f6                	test   %esi,%esi
void
blob_fill_pad(struct blob_attr *attr)
{
	char *buf = (char *) attr;
	int len = blob_pad_len(attr);
	int delta = len - blob_raw_len(attr);
    3257:	89 f1                	mov    %esi,%ecx

	if (delta > 0)
    3259:	7e 14                	jle    326f <blob_fill_pad+0x30>
		memset(buf + len - delta, 0, delta);
    325b:	48 63 f6             	movslq %esi,%rsi
    325e:	48 98                	cltq   
    3260:	89 c9                	mov    %ecx,%ecx
    3262:	48 29 f0             	sub    %rsi,%rax
    3265:	48 01 c2             	add    %rax,%rdx
    3268:	31 c0                	xor    %eax,%eax
    326a:	48 89 d7             	mov    %rdx,%rdi
    326d:	f3 aa                	rep stos %al,%es:(%rdi)
    326f:	c3                   	retq   

0000000000003270 <blob_add>:
	buf->head = offset_to_attr(buf, offset_head);
}

static struct blob_attr *
blob_add(struct blob_buf *buf, struct blob_attr *pos, int id, int payload)
{
    3270:	41 56                	push   %r14
    3272:	41 55                	push   %r13
	int offset = attr_to_offset(buf, pos);
	int required = (offset - BLOB_COOKIE + sizeof(struct blob_attr) + payload) - buf->buflen;
    3274:	89 c8                	mov    %ecx,%eax
	buf->head = offset_to_attr(buf, offset_head);
}

static struct blob_attr *
blob_add(struct blob_buf *buf, struct blob_attr *pos, int id, int payload)
{
    3276:	41 54                	push   %r12
    3278:	55                   	push   %rbp
}

static inline int
attr_to_offset(struct blob_buf *buf, struct blob_attr *attr)
{
	return (char *)attr - (char *) buf->buf + BLOB_COOKIE;
    3279:	48 89 f5             	mov    %rsi,%rbp
	buf->head = offset_to_attr(buf, offset_head);
}

static struct blob_attr *
blob_add(struct blob_buf *buf, struct blob_attr *pos, int id, int payload)
{
    327c:	53                   	push   %rbx
}

static inline int
attr_to_offset(struct blob_buf *buf, struct blob_attr *attr)
{
	return (char *)attr - (char *) buf->buf + BLOB_COOKIE;
    327d:	48 2b 6f 18          	sub    0x18(%rdi),%rbp
	buf->head = offset_to_attr(buf, offset_head);
}

static struct blob_attr *
blob_add(struct blob_buf *buf, struct blob_attr *pos, int id, int payload)
{
    3281:	49 89 f5             	mov    %rsi,%r13
	int offset = attr_to_offset(buf, pos);
	int required = (offset - BLOB_COOKIE + sizeof(struct blob_attr) + payload) - buf->buflen;
    3284:	2b 47 10             	sub    0x10(%rdi),%eax
	buf->head = offset_to_attr(buf, offset_head);
}

static struct blob_attr *
blob_add(struct blob_buf *buf, struct blob_attr *pos, int id, int payload)
{
    3287:	41 89 d4             	mov    %edx,%r12d
    328a:	89 cb                	mov    %ecx,%ebx
}

static inline int
attr_to_offset(struct blob_buf *buf, struct blob_attr *attr)
{
	return (char *)attr - (char *) buf->buf + BLOB_COOKIE;
    328c:	81 c5 67 45 23 01    	add    $0x1234567,%ebp

static struct blob_attr *
blob_add(struct blob_buf *buf, struct blob_attr *pos, int id, int payload)
{
	int offset = attr_to_offset(buf, pos);
	int required = (offset - BLOB_COOKIE + sizeof(struct blob_attr) + payload) - buf->buflen;
    3292:	8d b4 05 9d ba dc fe 	lea    -0x1234563(%rbp,%rax,1),%esi
	struct blob_attr *attr;

	if (required > 0) {
    3299:	85 f6                	test   %esi,%esi
    329b:	7e 17                	jle    32b4 <blob_add+0x44>
    329d:	49 89 fe             	mov    %rdi,%r14
}

static inline struct blob_attr *
offset_to_attr(struct blob_buf *buf, int offset)
{
	void *ptr = (char *)buf->buf + offset - BLOB_COOKIE;
    32a0:	48 63 ed             	movslq %ebp,%rbp
	int offset = attr_to_offset(buf, pos);
	int required = (offset - BLOB_COOKIE + sizeof(struct blob_attr) + payload) - buf->buflen;
	struct blob_attr *attr;

	if (required > 0) {
		blob_buf_grow(buf, required);
    32a3:	e8 38 f2 ff ff       	callq  24e0 <blob_buf_grow@plt>
}

static inline struct blob_attr *
offset_to_attr(struct blob_buf *buf, int offset)
{
	void *ptr = (char *)buf->buf + offset - BLOB_COOKIE;
    32a8:	49 8b 46 18          	mov    0x18(%r14),%rax
    32ac:	4c 8d ac 28 99 ba dc 	lea    -0x1234567(%rax,%rbp,1),%r13
    32b3:	fe 
}

static void
blob_init(struct blob_attr *attr, int id, unsigned int len)
{
	len &= BLOB_ATTR_LEN_MASK;
    32b4:	83 c3 04             	add    $0x4,%ebx
	} else {
		attr = pos;
	}

	blob_init(attr, id, payload + sizeof(struct blob_attr));
	blob_fill_pad(attr);
    32b7:	4c 89 ef             	mov    %r13,%rdi
}

static void
blob_init(struct blob_attr *attr, int id, unsigned int len)
{
	len &= BLOB_ATTR_LEN_MASK;
    32ba:	89 d9                	mov    %ebx,%ecx
	len |= (id << BLOB_ATTR_ID_SHIFT) & BLOB_ATTR_ID_MASK;
	attr->id_len = cpu_to_be32(len);
    32bc:	44 89 e3             	mov    %r12d,%ebx
    32bf:	c1 e3 18             	shl    $0x18,%ebx
}

static void
blob_init(struct blob_attr *attr, int id, unsigned int len)
{
	len &= BLOB_ATTR_LEN_MASK;
    32c2:	81 e1 ff ff ff 00    	and    $0xffffff,%ecx
	len |= (id << BLOB_ATTR_ID_SHIFT) & BLOB_ATTR_ID_MASK;
	attr->id_len = cpu_to_be32(len);
    32c8:	81 e3 00 00 00 7f    	and    $0x7f000000,%ebx
    32ce:	09 cb                	or     %ecx,%ebx
    32d0:	0f cb                	bswap  %ebx
    32d2:	41 89 5d 00          	mov    %ebx,0x0(%r13)
	} else {
		attr = pos;
	}

	blob_init(attr, id, payload + sizeof(struct blob_attr));
	blob_fill_pad(attr);
    32d6:	e8 f5 f0 ff ff       	callq  23d0 <blob_fill_pad@plt>
	return attr;
}
    32db:	5b                   	pop    %rbx
    32dc:	4c 89 e8             	mov    %r13,%rax
    32df:	5d                   	pop    %rbp
    32e0:	41 5c                	pop    %r12
    32e2:	41 5d                	pop    %r13
    32e4:	41 5e                	pop    %r14
    32e6:	c3                   	retq   

00000000000032e7 <blob_buf_init>:

int
blob_buf_init(struct blob_buf *buf, int id)
{
    32e7:	51                   	push   %rcx
	if (!buf->grow)
    32e8:	48 83 7f 08 00       	cmpq   $0x0,0x8(%rdi)
	return attr;
}

int
blob_buf_init(struct blob_buf *buf, int id)
{
    32ed:	89 f2                	mov    %esi,%edx
	if (!buf->grow)
    32ef:	75 0b                	jne    32fc <blob_buf_init+0x15>
		buf->grow = blob_buffer_grow;
    32f1:	48 8d 05 87 fe ff ff 	lea    -0x179(%rip),%rax        # 317f <blob_buffer_grow>
    32f8:	48 89 47 08          	mov    %rax,0x8(%rdi)

	buf->head = buf->buf;
    32fc:	48 8b 77 18          	mov    0x18(%rdi),%rsi
	if (blob_add(buf, buf->buf, id, 0) == NULL)
    3300:	31 c9                	xor    %ecx,%ecx
blob_buf_init(struct blob_buf *buf, int id)
{
	if (!buf->grow)
		buf->grow = blob_buffer_grow;

	buf->head = buf->buf;
    3302:	48 89 37             	mov    %rsi,(%rdi)
	if (blob_add(buf, buf->buf, id, 0) == NULL)
    3305:	e8 66 ff ff ff       	callq  3270 <blob_add>
		return -ENOMEM;

	return 0;
    330a:	48 83 f8 01          	cmp    $0x1,%rax
    330e:	19 c0                	sbb    %eax,%eax
    3310:	83 e0 f4             	and    $0xfffffff4,%eax
}
    3313:	5a                   	pop    %rdx
    3314:	c3                   	retq   

0000000000003315 <blob_set_raw_len>:
void
blob_set_raw_len(struct blob_attr *attr, unsigned int len)
{
	len &= BLOB_ATTR_LEN_MASK;
	attr->id_len &= ~cpu_to_be32(BLOB_ATTR_LEN_MASK);
	attr->id_len |= cpu_to_be32(len);
    3315:	0f b6 07             	movzbl (%rdi),%eax
    3318:	81 e6 ff ff ff 00    	and    $0xffffff,%esi
    331e:	0f ce                	bswap  %esi
    3320:	09 c6                	or     %eax,%esi
    3322:	89 37                	mov    %esi,(%rdi)
    3324:	c3                   	retq   

0000000000003325 <blob_new>:
}

struct blob_attr *
blob_new(struct blob_buf *buf, int id, int payload)
{
    3325:	55                   	push   %rbp
    3326:	53                   	push   %rbx
    3327:	48 89 fd             	mov    %rdi,%rbp
    332a:	51                   	push   %rcx
	struct blob_attr *attr;

	attr = blob_add(buf, blob_next(buf->head), id, payload);
    332b:	4c 8b 07             	mov    (%rdi),%r8
	attr->id_len |= cpu_to_be32(len);
}

struct blob_attr *
blob_new(struct blob_buf *buf, int id, int payload)
{
    332e:	41 89 f1             	mov    %esi,%r9d
}

static inline struct blob_attr *
blob_next(const struct blob_attr *attr)
{
	return (struct blob_attr *) ((char *) attr + blob_pad_len(attr));
    3331:	4c 89 c7             	mov    %r8,%rdi
    3334:	e8 9b fe ff ff       	callq  31d4 <blob_pad_len>
	struct blob_attr *attr;

	attr = blob_add(buf, blob_next(buf->head), id, payload);
    3339:	89 c0                	mov    %eax,%eax
    333b:	89 d1                	mov    %edx,%ecx
    333d:	48 89 ef             	mov    %rbp,%rdi
    3340:	49 8d 34 00          	lea    (%r8,%rax,1),%rsi
    3344:	44 89 ca             	mov    %r9d,%edx
    3347:	e8 24 ff ff ff       	callq  3270 <blob_add>
	if (!attr)
    334c:	48 85 c0             	test   %rax,%rax
struct blob_attr *
blob_new(struct blob_buf *buf, int id, int payload)
{
	struct blob_attr *attr;

	attr = blob_add(buf, blob_next(buf->head), id, payload);
    334f:	48 89 c3             	mov    %rax,%rbx
	if (!attr)
    3352:	74 20                	je     3374 <blob_new+0x4f>
		return NULL;

	blob_set_raw_len(buf->head, blob_pad_len(buf->head) + blob_pad_len(attr));
    3354:	48 8b 55 00          	mov    0x0(%rbp),%rdx
    3358:	48 89 d7             	mov    %rdx,%rdi
    335b:	e8 74 fe ff ff       	callq  31d4 <blob_pad_len>
    3360:	48 89 df             	mov    %rbx,%rdi
    3363:	89 c6                	mov    %eax,%esi
    3365:	e8 6a fe ff ff       	callq  31d4 <blob_pad_len>
    336a:	01 c6                	add    %eax,%esi
    336c:	48 89 d7             	mov    %rdx,%rdi
    336f:	e8 9c f1 ff ff       	callq  2510 <blob_set_raw_len@plt>
	return attr;
}
    3374:	48 89 d8             	mov    %rbx,%rax
    3377:	5a                   	pop    %rdx
    3378:	5b                   	pop    %rbx
    3379:	5d                   	pop    %rbp
    337a:	c3                   	retq   

000000000000337b <blob_put_raw>:
struct blob_attr *
blob_put_raw(struct blob_buf *buf, const void *ptr, int len)
{
	struct blob_attr *attr;

	if (len < sizeof(struct blob_attr) || !ptr)
    337b:	83 fa 03             	cmp    $0x3,%edx
    337e:	76 61                	jbe    33e1 <blob_put_raw+0x66>
    3380:	48 85 f6             	test   %rsi,%rsi
    3383:	74 5c                	je     33e1 <blob_put_raw+0x66>
	return attr;
}

struct blob_attr *
blob_put_raw(struct blob_buf *buf, const void *ptr, int len)
{
    3385:	41 55                	push   %r13
    3387:	41 54                	push   %r12
    3389:	49 89 f4             	mov    %rsi,%r12
    338c:	55                   	push   %rbp
    338d:	53                   	push   %rbx
    338e:	49 89 fd             	mov    %rdi,%r13
    3391:	51                   	push   %rcx
	struct blob_attr *attr;

	if (len < sizeof(struct blob_attr) || !ptr)
		return NULL;

	attr = blob_add(buf, blob_next(buf->head), 0, len - sizeof(struct blob_attr));
    3392:	48 8b 37             	mov    (%rdi),%rsi
    3395:	89 d3                	mov    %edx,%ebx
    3397:	48 89 f7             	mov    %rsi,%rdi
    339a:	e8 35 fe ff ff       	callq  31d4 <blob_pad_len>
    339f:	8d 4a fc             	lea    -0x4(%rdx),%ecx
    33a2:	89 c0                	mov    %eax,%eax
    33a4:	4c 89 ef             	mov    %r13,%rdi
    33a7:	48 01 c6             	add    %rax,%rsi
    33aa:	31 d2                	xor    %edx,%edx
    33ac:	e8 bf fe ff ff       	callq  3270 <blob_add>
	blob_set_raw_len(buf->head, blob_pad_len(buf->head) + len);
    33b1:	49 8b 55 00          	mov    0x0(%r13),%rdx
	struct blob_attr *attr;

	if (len < sizeof(struct blob_attr) || !ptr)
		return NULL;

	attr = blob_add(buf, blob_next(buf->head), 0, len - sizeof(struct blob_attr));
    33b5:	48 89 c5             	mov    %rax,%rbp
	blob_set_raw_len(buf->head, blob_pad_len(buf->head) + len);
    33b8:	48 89 d7             	mov    %rdx,%rdi
    33bb:	e8 14 fe ff ff       	callq  31d4 <blob_pad_len>
    33c0:	8d 34 03             	lea    (%rbx,%rax,1),%esi
    33c3:	48 89 d7             	mov    %rdx,%rdi
    33c6:	e8 45 f1 ff ff       	callq  2510 <blob_set_raw_len@plt>

__fortify_function void *
__NTH (memcpy (void *__restrict __dest, const void *__restrict __src,
	       size_t __len))
{
  return __builtin___memcpy_chk (__dest, __src, __len, __bos0 (__dest));
    33cb:	48 63 cb             	movslq %ebx,%rcx
    33ce:	48 89 ef             	mov    %rbp,%rdi
    33d1:	4c 89 e6             	mov    %r12,%rsi
    33d4:	f3 a4                	rep movsb %ds:(%rsi),%es:(%rdi)
	memcpy(attr, ptr, len);
	return attr;
    33d6:	48 89 e8             	mov    %rbp,%rax
}
    33d9:	5a                   	pop    %rdx
    33da:	5b                   	pop    %rbx
    33db:	5d                   	pop    %rbp
    33dc:	41 5c                	pop    %r12
    33de:	41 5d                	pop    %r13
    33e0:	c3                   	retq   
blob_put_raw(struct blob_buf *buf, const void *ptr, int len)
{
	struct blob_attr *attr;

	if (len < sizeof(struct blob_attr) || !ptr)
		return NULL;
    33e1:	31 c0                	xor    %eax,%eax
    33e3:	c3                   	retq   

00000000000033e4 <blob_put>:
	return attr;
}

struct blob_attr *
blob_put(struct blob_buf *buf, int id, const void *ptr, int len)
{
    33e4:	55                   	push   %rbp
    33e5:	53                   	push   %rbx
    33e6:	48 89 d5             	mov    %rdx,%rbp
    33e9:	41 50                	push   %r8
	struct blob_attr *attr;

	attr = blob_new(buf, id, len);
    33eb:	89 ca                	mov    %ecx,%edx
	return attr;
}

struct blob_attr *
blob_put(struct blob_buf *buf, int id, const void *ptr, int len)
{
    33ed:	89 cb                	mov    %ecx,%ebx
	struct blob_attr *attr;

	attr = blob_new(buf, id, len);
    33ef:	e8 ec ef ff ff       	callq  23e0 <blob_new@plt>
    33f4:	49 89 c0             	mov    %rax,%r8
	if (!attr)
		return NULL;
    33f7:	31 c0                	xor    %eax,%eax
blob_put(struct blob_buf *buf, int id, const void *ptr, int len)
{
	struct blob_attr *attr;

	attr = blob_new(buf, id, len);
	if (!attr)
    33f9:	4d 85 c0             	test   %r8,%r8
    33fc:	74 1a                	je     3418 <blob_put+0x34>
		return NULL;

	if (ptr)
    33fe:	48 85 ed             	test   %rbp,%rbp
    3401:	4c 89 c0             	mov    %r8,%rax
    3404:	74 12                	je     3418 <blob_put+0x34>
    3406:	49 8d 40 04          	lea    0x4(%r8),%rax
    340a:	48 63 cb             	movslq %ebx,%rcx
    340d:	48 89 ee             	mov    %rbp,%rsi
    3410:	48 89 c7             	mov    %rax,%rdi
    3413:	4c 89 c0             	mov    %r8,%rax
    3416:	f3 a4                	rep movsb %ds:(%rsi),%es:(%rdi)
		memcpy(blob_data(attr), ptr, len);
	return attr;
}
    3418:	5a                   	pop    %rdx
    3419:	5b                   	pop    %rbx
    341a:	5d                   	pop    %rbp
    341b:	c3                   	retq   

000000000000341c <blob_nest_start>:

void *
blob_nest_start(struct blob_buf *buf, int id)
{
    341c:	55                   	push   %rbp
    341d:	53                   	push   %rbx
    341e:	48 89 fd             	mov    %rdi,%rbp
    3421:	50                   	push   %rax
	unsigned long offset = attr_to_offset(buf, buf->head);
    3422:	48 8b 1f             	mov    (%rdi),%rbx
	buf->head = blob_new(buf, id, 0);
    3425:	31 d2                	xor    %edx,%edx
}

void *
blob_nest_start(struct blob_buf *buf, int id)
{
	unsigned long offset = attr_to_offset(buf, buf->head);
    3427:	48 2b 5f 18          	sub    0x18(%rdi),%rbx
	buf->head = blob_new(buf, id, 0);
    342b:	e8 b0 ef ff ff       	callq  23e0 <blob_new@plt>
    3430:	48 89 45 00          	mov    %rax,0x0(%rbp)
	return (void *) offset;
}
    3434:	5a                   	pop    %rdx
}

void *
blob_nest_start(struct blob_buf *buf, int id)
{
	unsigned long offset = attr_to_offset(buf, buf->head);
    3435:	81 c3 67 45 23 01    	add    $0x1234567,%ebx
    343b:	48 63 db             	movslq %ebx,%rbx
	buf->head = blob_new(buf, id, 0);
	return (void *) offset;
}
    343e:	48 89 d8             	mov    %rbx,%rax
    3441:	5b                   	pop    %rbx
    3442:	5d                   	pop    %rbp
    3443:	c3                   	retq   

0000000000003444 <blob_nest_end>:

void
blob_nest_end(struct blob_buf *buf, void *cookie)
{
    3444:	55                   	push   %rbp
    3445:	53                   	push   %rbx
}

static inline struct blob_attr *
offset_to_attr(struct blob_buf *buf, int offset)
{
	void *ptr = (char *)buf->buf + offset - BLOB_COOKIE;
    3446:	48 63 f6             	movslq %esi,%rsi
	return (void *) offset;
}

void
blob_nest_end(struct blob_buf *buf, void *cookie)
{
    3449:	50                   	push   %rax
}

static inline struct blob_attr *
offset_to_attr(struct blob_buf *buf, int offset)
{
	void *ptr = (char *)buf->buf + offset - BLOB_COOKIE;
    344a:	48 8b 47 18          	mov    0x18(%rdi),%rax
	return (void *) offset;
}

void
blob_nest_end(struct blob_buf *buf, void *cookie)
{
    344e:	48 89 fb             	mov    %rdi,%rbx
}

static inline struct blob_attr *
offset_to_attr(struct blob_buf *buf, int offset)
{
	void *ptr = (char *)buf->buf + offset - BLOB_COOKIE;
    3451:	48 8d ac 30 99 ba dc 	lea    -0x1234567(%rax,%rsi,1),%rbp
    3458:	fe 

void
blob_nest_end(struct blob_buf *buf, void *cookie)
{
	struct blob_attr *attr = offset_to_attr(buf, (unsigned long) cookie);
	blob_set_raw_len(attr, blob_pad_len(attr) + blob_len(buf->head));
    3459:	48 89 ef             	mov    %rbp,%rdi
    345c:	e8 73 fd ff ff       	callq  31d4 <blob_pad_len>
 * blob_len: returns the length of the attribute's payload
 */
static inline unsigned int
blob_len(const struct blob_attr *attr)
{
	return (be32_to_cpu(attr->id_len) & BLOB_ATTR_LEN_MASK) - sizeof(struct blob_attr);
    3461:	48 8b 13             	mov    (%rbx),%rdx
    3464:	48 89 ef             	mov    %rbp,%rdi
    3467:	8b 12                	mov    (%rdx),%edx
    3469:	0f ca                	bswap  %edx
    346b:	81 e2 ff ff ff 00    	and    $0xffffff,%edx
    3471:	8d 74 10 fc          	lea    -0x4(%rax,%rdx,1),%esi
    3475:	e8 96 f0 ff ff       	callq  2510 <blob_set_raw_len@plt>
	buf->head = attr;
    347a:	48 89 2b             	mov    %rbp,(%rbx)
}
    347d:	5a                   	pop    %rdx
    347e:	5b                   	pop    %rbx
    347f:	5d                   	pop    %rbp
    3480:	c3                   	retq   

0000000000003481 <blob_check_type>:
blob_check_type(const void *ptr, int len, int type)
{
	const char *data = ptr;

	if (type >= BLOB_ATTR_LAST)
		return false;
    3481:	31 c0                	xor    %eax,%eax
bool
blob_check_type(const void *ptr, int len, int type)
{
	const char *data = ptr;

	if (type >= BLOB_ATTR_LAST)
    3483:	83 fa 07             	cmp    $0x7,%edx
    3486:	7f 30                	jg     34b8 <blob_check_type+0x37>
		return false;

	if (type >= BLOB_ATTR_INT8 && type <= BLOB_ATTR_INT64) {
    3488:	8d 4a fc             	lea    -0x4(%rdx),%ecx
    348b:	4c 63 c2             	movslq %edx,%r8
    348e:	83 f9 03             	cmp    $0x3,%ecx
    3491:	48 8d 0d 28 2c 00 00 	lea    0x2c28(%rip),%rcx        # 60c0 <blob_type_minlen>
    3498:	77 06                	ja     34a0 <blob_check_type+0x1f>
		if (len != blob_type_minlen[type])
    349a:	42 39 34 81          	cmp    %esi,(%rcx,%r8,4)
    349e:	eb 15                	jmp    34b5 <blob_check_type+0x34>
			return false;
	} else {
		if (len < blob_type_minlen[type])
    34a0:	42 3b 34 81          	cmp    (%rcx,%r8,4),%esi
    34a4:	7c 12                	jl     34b8 <blob_check_type+0x37>
			return false;
	}

	if (type == BLOB_ATTR_STRING && data[len - 1] != 0)
    34a6:	83 fa 03             	cmp    $0x3,%edx
		return false;

	return true;
    34a9:	b0 01                	mov    $0x1,%al
	} else {
		if (len < blob_type_minlen[type])
			return false;
	}

	if (type == BLOB_ATTR_STRING && data[len - 1] != 0)
    34ab:	75 0b                	jne    34b8 <blob_check_type+0x37>
    34ad:	48 63 f6             	movslq %esi,%rsi
    34b0:	80 7c 37 ff 00       	cmpb   $0x0,-0x1(%rdi,%rsi,1)
    34b5:	0f 94 c0             	sete   %al
		return false;

	return true;
}
    34b8:	c3                   	retq   

00000000000034b9 <blob_parse>:

int
blob_parse(struct blob_attr *attr, struct blob_attr **data, const struct blob_attr_info *info, int max)
{
    34b9:	41 57                	push   %r15
    34bb:	41 56                	push   %r14
    34bd:	48 63 c9             	movslq %ecx,%rcx
    34c0:	41 55                	push   %r13
    34c2:	41 54                	push   %r12
    34c4:	49 89 fd             	mov    %rdi,%r13
    34c7:	55                   	push   %rbp
    34c8:	53                   	push   %rbx
    {
      __warn_memset_zero_len ();
      return __dest;
    }
#endif
  return __builtin___memset_chk (__dest, __ch, __len, __bos0 (__dest));
    34c9:	31 c0                	xor    %eax,%eax
    34cb:	49 89 c8             	mov    %rcx,%r8
    34ce:	48 89 f7             	mov    %rsi,%rdi
    34d1:	48 c1 e1 03          	shl    $0x3,%rcx
    34d5:	48 83 ec 28          	sub    $0x28,%rsp
    34d9:	45 31 f6             	xor    %r14d,%r14d
	struct blob_attr *pos;
	int found = 0;
	int rem;

	memset(data, 0, sizeof(struct blob_attr *) * max);
	blob_for_each_attr(pos, attr, rem) {
    34dc:	4d 85 ed             	test   %r13,%r13
    34df:	f3 aa                	rep stos %al,%es:(%rdi)
    34e1:	0f 84 fb 00 00 00    	je     35e2 <blob_parse+0x129>
    34e7:	41 8b 5d 00          	mov    0x0(%r13),%ebx
 * blob_data: returns the data pointer for an attribute
 */
static inline void *
blob_data(const struct blob_attr *attr)
{
	return (void *) attr->data;
    34eb:	49 8d 6d 04          	lea    0x4(%r13),%rbp
    34ef:	44 89 44 24 10       	mov    %r8d,0x10(%rsp)
    34f4:	49 89 d7             	mov    %rdx,%r15
    34f7:	48 89 74 24 08       	mov    %rsi,0x8(%rsp)
 * blob_len: returns the length of the attribute's payload
 */
static inline unsigned int
blob_len(const struct blob_attr *attr)
{
	return (be32_to_cpu(attr->id_len) & BLOB_ATTR_LEN_MASK) - sizeof(struct blob_attr);
    34fc:	0f cb                	bswap  %ebx
    34fe:	81 e3 ff ff ff 00    	and    $0xffffff,%ebx
    3504:	83 eb 04             	sub    $0x4,%ebx
    3507:	85 db                	test   %ebx,%ebx
    3509:	0f 8e d3 00 00 00    	jle    35e2 <blob_parse+0x129>
    350f:	48 89 ef             	mov    %rbp,%rdi
    3512:	e8 bd fc ff ff       	callq  31d4 <blob_pad_len>
    3517:	83 f8 03             	cmp    $0x3,%eax
    351a:	0f 86 c2 00 00 00    	jbe    35e2 <blob_parse+0x129>
    3520:	39 d8                	cmp    %ebx,%eax
    3522:	0f 87 ba 00 00 00    	ja     35e2 <blob_parse+0x129>
 * blob_id: returns the id of an attribute
 */
static inline unsigned int
blob_id(const struct blob_attr *attr)
{
	int id = (be32_to_cpu(attr->id_len) & BLOB_ATTR_ID_MASK) >> BLOB_ATTR_ID_SHIFT;
    3528:	8b 4d 00             	mov    0x0(%rbp),%ecx
    352b:	0f c9                	bswap  %ecx
		int id = blob_id(pos);
    352d:	41 89 cc             	mov    %ecx,%r12d
    3530:	41 81 e4 00 00 00 7f 	and    $0x7f000000,%r12d
    3537:	41 c1 ec 18          	shr    $0x18,%r12d
		int len = blob_len(pos);

		if (id >= max)
    353b:	44 39 64 24 10       	cmp    %r12d,0x10(%rsp)
    3540:	0f 8e 88 00 00 00    	jle    35ce <blob_parse+0x115>
			continue;

		if (info) {
    3546:	4d 85 ff             	test   %r15,%r15
    3549:	4d 63 e4             	movslq %r12d,%r12
    354c:	75 16                	jne    3564 <blob_parse+0xab>

			if (info[id].validate && !info[id].validate(&info[id], attr))
				continue;
		}

		if (!data[id])
    354e:	48 8b 44 24 08       	mov    0x8(%rsp),%rax
    3553:	4a 8d 04 e0          	lea    (%rax,%r12,8),%rax
			found++;
    3557:	48 83 38 01          	cmpq   $0x1,(%rax)

		data[id] = pos;
    355b:	48 89 28             	mov    %rbp,(%rax)
			if (info[id].validate && !info[id].validate(&info[id], attr))
				continue;
		}

		if (!data[id])
			found++;
    355e:	41 83 d6 00          	adc    $0x0,%r14d
    3562:	eb 6a                	jmp    35ce <blob_parse+0x115>

		if (id >= max)
			continue;

		if (info) {
			int type = info[id].type;
    3564:	4d 6b c4 18          	imul   $0x18,%r12,%r8
 * blob_len: returns the length of the attribute's payload
 */
static inline unsigned int
blob_len(const struct blob_attr *attr)
{
	return (be32_to_cpu(attr->id_len) & BLOB_ATTR_LEN_MASK) - sizeof(struct blob_attr);
    3568:	81 e1 ff ff ff 00    	and    $0xffffff,%ecx
    356e:	83 e9 04             	sub    $0x4,%ecx
    3571:	4d 01 f8             	add    %r15,%r8
    3574:	41 8b 10             	mov    (%r8),%edx

			if (type < BLOB_ATTR_LAST) {
    3577:	83 fa 07             	cmp    $0x7,%edx
    357a:	7e 0e                	jle    358a <blob_parse+0xd1>
				if (!blob_check_type(blob_data(pos), len, type))
					continue;
			}

			if (info[id].minlen && len < info[id].minlen)
    357c:	41 8b 40 04          	mov    0x4(%r8),%eax
    3580:	85 c0                	test   %eax,%eax
    3582:	74 29                	je     35ad <blob_parse+0xf4>
    3584:	39 c8                	cmp    %ecx,%eax
    3586:	77 46                	ja     35ce <blob_parse+0x115>
    3588:	eb 23                	jmp    35ad <blob_parse+0xf4>
 * blob_data: returns the data pointer for an attribute
 */
static inline void *
blob_data(const struct blob_attr *attr)
{
	return (void *) attr->data;
    358a:	48 8d 7d 04          	lea    0x4(%rbp),%rdi

		if (info) {
			int type = info[id].type;

			if (type < BLOB_ATTR_LAST) {
				if (!blob_check_type(blob_data(pos), len, type))
    358e:	89 ce                	mov    %ecx,%esi
    3590:	4c 89 44 24 18       	mov    %r8,0x18(%rsp)
    3595:	89 4c 24 14          	mov    %ecx,0x14(%rsp)
    3599:	e8 92 ed ff ff       	callq  2330 <blob_check_type@plt>
    359e:	84 c0                	test   %al,%al
    35a0:	8b 4c 24 14          	mov    0x14(%rsp),%ecx
    35a4:	4c 8b 44 24 18       	mov    0x18(%rsp),%r8
    35a9:	75 d1                	jne    357c <blob_parse+0xc3>
    35ab:	eb 21                	jmp    35ce <blob_parse+0x115>
			}

			if (info[id].minlen && len < info[id].minlen)
				continue;

			if (info[id].maxlen && len > info[id].maxlen)
    35ad:	41 8b 40 08          	mov    0x8(%r8),%eax
    35b1:	39 c8                	cmp    %ecx,%eax
    35b3:	73 04                	jae    35b9 <blob_parse+0x100>
    35b5:	85 c0                	test   %eax,%eax
    35b7:	75 15                	jne    35ce <blob_parse+0x115>
				continue;

			if (info[id].validate && !info[id].validate(&info[id], attr))
    35b9:	49 8b 40 10          	mov    0x10(%r8),%rax
    35bd:	48 85 c0             	test   %rax,%rax
    35c0:	74 8c                	je     354e <blob_parse+0x95>
    35c2:	4c 89 ee             	mov    %r13,%rsi
    35c5:	4c 89 c7             	mov    %r8,%rdi
    35c8:	ff d0                	callq  *%rax
    35ca:	84 c0                	test   %al,%al
    35cc:	75 80                	jne    354e <blob_parse+0x95>
	struct blob_attr *pos;
	int found = 0;
	int rem;

	memset(data, 0, sizeof(struct blob_attr *) * max);
	blob_for_each_attr(pos, attr, rem) {
    35ce:	48 89 ef             	mov    %rbp,%rdi
    35d1:	e8 fe fb ff ff       	callq  31d4 <blob_pad_len>
    35d6:	29 c3                	sub    %eax,%ebx
}

static inline struct blob_attr *
blob_next(const struct blob_attr *attr)
{
	return (struct blob_attr *) ((char *) attr + blob_pad_len(attr));
    35d8:	89 c0                	mov    %eax,%eax
    35da:	48 01 c5             	add    %rax,%rbp
    35dd:	e9 25 ff ff ff       	jmpq   3507 <blob_parse+0x4e>
			found++;

		data[id] = pos;
	}
	return found;
}
    35e2:	48 83 c4 28          	add    $0x28,%rsp
    35e6:	44 89 f0             	mov    %r14d,%eax
    35e9:	5b                   	pop    %rbx
    35ea:	5d                   	pop    %rbp
    35eb:	41 5c                	pop    %r12
    35ed:	41 5d                	pop    %r13
    35ef:	41 5e                	pop    %r14
    35f1:	41 5f                	pop    %r15
    35f3:	c3                   	retq   

00000000000035f4 <blob_attr_equal>:

bool
blob_attr_equal(const struct blob_attr *a1, const struct blob_attr *a2)
{
	if (!a1 && !a2)
    35f4:	48 85 ff             	test   %rdi,%rdi
    35f7:	0f 94 c2             	sete   %dl
    35fa:	48 85 f6             	test   %rsi,%rsi
    35fd:	0f 94 c0             	sete   %al
    3600:	41 88 d0             	mov    %dl,%r8b
    3603:	41 20 c0             	and    %al,%r8b
    3606:	75 2e                	jne    3636 <blob_attr_equal+0x42>
		return true;

	if (!a1 || !a2)
    3608:	08 c2                	or     %al,%dl
    360a:	75 2a                	jne    3636 <blob_attr_equal+0x42>
	return found;
}

bool
blob_attr_equal(const struct blob_attr *a1, const struct blob_attr *a2)
{
    360c:	51                   	push   %rcx
    360d:	48 89 f9             	mov    %rdi,%rcx
		return true;

	if (!a1 || !a2)
		return false;

	if (blob_pad_len(a1) != blob_pad_len(a2))
    3610:	e8 bf fb ff ff       	callq  31d4 <blob_pad_len>
    3615:	89 c2                	mov    %eax,%edx
    3617:	48 89 f7             	mov    %rsi,%rdi
    361a:	e8 b5 fb ff ff       	callq  31d4 <blob_pad_len>
    361f:	39 c2                	cmp    %eax,%edx
    3621:	75 0e                	jne    3631 <blob_attr_equal+0x3d>
		return false;

	return !memcmp(a1, a2, blob_pad_len(a1));
    3623:	48 89 cf             	mov    %rcx,%rdi
    3626:	e8 45 ef ff ff       	callq  2570 <memcmp@plt>
    362b:	85 c0                	test   %eax,%eax
    362d:	41 0f 94 c0          	sete   %r8b
}
    3631:	44 88 c0             	mov    %r8b,%al
    3634:	5a                   	pop    %rdx
    3635:	c3                   	retq   
    3636:	44 88 c0             	mov    %r8b,%al
    3639:	c3                   	retq   

000000000000363a <blob_memdup>:

struct blob_attr *
blob_memdup(struct blob_attr *attr)
{
    363a:	55                   	push   %rbp
    363b:	53                   	push   %rbx
    363c:	48 89 fd             	mov    %rdi,%rbp
    363f:	51                   	push   %rcx
	struct blob_attr *ret;
	int size = blob_pad_len(attr);
    3640:	e8 8f fb ff ff       	callq  31d4 <blob_pad_len>

	ret = malloc(size);
    3645:	48 63 d8             	movslq %eax,%rbx
    3648:	48 89 df             	mov    %rbx,%rdi
    364b:	e8 90 ef ff ff       	callq  25e0 <malloc@plt>
	if (!ret)
    3650:	48 85 c0             	test   %rax,%rax
    3653:	74 0b                	je     3660 <blob_memdup+0x26>

__fortify_function void *
__NTH (memcpy (void *__restrict __dest, const void *__restrict __src,
	       size_t __len))
{
  return __builtin___memcpy_chk (__dest, __src, __len, __bos0 (__dest));
    3655:	48 89 c7             	mov    %rax,%rdi
    3658:	48 89 ee             	mov    %rbp,%rsi
    365b:	48 89 d9             	mov    %rbx,%rcx
    365e:	f3 a4                	rep movsb %ds:(%rsi),%es:(%rdi)
		return NULL;

	memcpy(ret, attr, size);
	return ret;
}
    3660:	5a                   	pop    %rdx
    3661:	5b                   	pop    %rbx
    3662:	5d                   	pop    %rbp
    3663:	c3                   	retq   

0000000000003664 <blobmsg_data>:
static inline void *blobmsg_data(const struct blob_attr *attr)
{
	struct blobmsg_hdr *hdr = (struct blobmsg_hdr *) blob_data(attr);
	char *data = blob_data(attr);

	if (blob_is_extended(attr))
    3664:	f6 07 80             	testb  $0x80,(%rdi)
 * blob_data: returns the data pointer for an attribute
 */
static inline void *
blob_data(const struct blob_attr *attr)
{
	return (void *) attr->data;
    3667:	48 8d 47 04          	lea    0x4(%rdi),%rax
    366b:	74 15                	je     3682 <blobmsg_data+0x1e>
		data += blobmsg_hdrlen(be16_to_cpu(hdr->namelen));
    366d:	66 8b 57 04          	mov    0x4(%rdi),%dx
    3671:	86 f2                	xchg   %dh,%dl
    3673:	0f b7 d2             	movzwl %dx,%edx
    3676:	83 c2 06             	add    $0x6,%edx
    3679:	81 e2 fc ff 01 00    	and    $0x1fffc,%edx
    367f:	48 01 d0             	add    %rdx,%rax

	return data;
}
    3682:	c3                   	retq   

0000000000003683 <blobmsg_new>:
	struct blobmsg_hdr *hdr;
	int attrlen, namelen;
	char *pad_start, *pad_end;

	if (!name)
		name = "";
    3683:	48 8d 05 a6 2a 00 00 	lea    0x2aa6(%rip),%rax        # 6130 <blob_type+0x50>
    368a:	48 85 d2             	test   %rdx,%rdx
}


static struct blob_attr *
blobmsg_new(struct blob_buf *buf, int type, const char *name, int payload_len, void **data)
{
    368d:	41 57                	push   %r15
    368f:	41 56                	push   %r14
    3691:	41 55                	push   %r13
    3693:	49 89 d5             	mov    %rdx,%r13
	struct blobmsg_hdr *hdr;
	int attrlen, namelen;
	char *pad_start, *pad_end;

	if (!name)
		name = "";
    3696:	4c 0f 44 e8          	cmove  %rax,%r13
}


static struct blob_attr *
blobmsg_new(struct blob_buf *buf, int type, const char *name, int payload_len, void **data)
{
    369a:	41 54                	push   %r12
    369c:	55                   	push   %rbp
	char *pad_start, *pad_end;

	if (!name)
		name = "";

	namelen = strlen(name);
    369d:	45 31 e4             	xor    %r12d,%r12d
}


static struct blob_attr *
blobmsg_new(struct blob_buf *buf, int type, const char *name, int payload_len, void **data)
{
    36a0:	53                   	push   %rbx
    36a1:	41 51                	push   %r9
    36a3:	49 89 fa             	mov    %rdi,%r10
    36a6:	41 89 c9             	mov    %ecx,%r9d
	char *pad_start, *pad_end;

	if (!name)
		name = "";

	namelen = strlen(name);
    36a9:	4c 89 ef             	mov    %r13,%rdi
    36ac:	48 83 c9 ff          	or     $0xffffffffffffffff,%rcx
    36b0:	44 88 e0             	mov    %r12b,%al
}


static struct blob_attr *
blobmsg_new(struct blob_buf *buf, int type, const char *name, int payload_len, void **data)
{
    36b3:	4d 89 c6             	mov    %r8,%r14
	char *pad_start, *pad_end;

	if (!name)
		name = "";

	namelen = strlen(name);
    36b6:	f2 ae                	repnz scas %es:(%rdi),%al
	attrlen = blobmsg_hdrlen(namelen) + payload_len;
	attr = blob_new(buf, type, attrlen);
    36b8:	4c 89 d7             	mov    %r10,%rdi
	char *pad_start, *pad_end;

	if (!name)
		name = "";

	namelen = strlen(name);
    36bb:	48 f7 d1             	not    %rcx
    36be:	48 8d 59 ff          	lea    -0x1(%rcx),%rbx
	attrlen = blobmsg_hdrlen(namelen) + payload_len;
	attr = blob_new(buf, type, attrlen);
    36c2:	8d 53 06             	lea    0x6(%rbx),%edx
    36c5:	83 e2 fc             	and    $0xfffffffc,%edx
    36c8:	44 01 ca             	add    %r9d,%edx
    36cb:	e8 10 ed ff ff       	callq  23e0 <blob_new@plt>
	if (!attr)
		return NULL;
    36d0:	31 f6                	xor    %esi,%esi
		name = "";

	namelen = strlen(name);
	attrlen = blobmsg_hdrlen(namelen) + payload_len;
	attr = blob_new(buf, type, attrlen);
	if (!attr)
    36d2:	48 85 c0             	test   %rax,%rax
    36d5:	74 4a                	je     3721 <blobmsg_new+0x9e>
    36d7:	48 89 c5             	mov    %rax,%rbp
		return NULL;

	attr->id_len |= be32_to_cpu(BLOB_ATTR_EXTENDED);
    36da:	81 08 80 00 00 00    	orl    $0x80,(%rax)
	hdr = blob_data(attr);
	hdr->namelen = cpu_to_be16(namelen);
    36e0:	89 d8                	mov    %ebx,%eax
    36e2:	86 e0                	xchg   %ah,%al
#endif

__fortify_function char *
__NTH (strcpy (char *__restrict __dest, const char *__restrict __src))
{
  return __builtin___strcpy_chk (__dest, __src, __bos (__dest));
    36e4:	48 8d 7d 06          	lea    0x6(%rbp),%rdi
    36e8:	4c 89 ee             	mov    %r13,%rsi
    36eb:	4c 8d 7d 04          	lea    0x4(%rbp),%r15
    36ef:	66 89 45 04          	mov    %ax,0x4(%rbp)
	strcpy((char *) hdr->name, (const char *)name);
	pad_end = *data = blobmsg_data(attr);
	pad_start = (char *) &hdr->name[namelen];
    36f3:	48 63 db             	movslq %ebx,%rbx
    36f6:	e8 95 ec ff ff       	callq  2390 <strcpy@plt>

	attr->id_len |= be32_to_cpu(BLOB_ATTR_EXTENDED);
	hdr = blob_data(attr);
	hdr->namelen = cpu_to_be16(namelen);
	strcpy((char *) hdr->name, (const char *)name);
	pad_end = *data = blobmsg_data(attr);
    36fb:	48 89 ef             	mov    %rbp,%rdi
    36fe:	e8 61 ff ff ff       	callq  3664 <blobmsg_data>
	pad_start = (char *) &hdr->name[namelen];
    3703:	49 8d 54 1f 02       	lea    0x2(%r15,%rbx,1),%rdx

	attr->id_len |= be32_to_cpu(BLOB_ATTR_EXTENDED);
	hdr = blob_data(attr);
	hdr->namelen = cpu_to_be16(namelen);
	strcpy((char *) hdr->name, (const char *)name);
	pad_end = *data = blobmsg_data(attr);
    3708:	49 89 06             	mov    %rax,(%r14)
    370b:	48 89 ee             	mov    %rbp,%rsi
	pad_start = (char *) &hdr->name[namelen];
	if (pad_start < pad_end)
    370e:	48 39 d0             	cmp    %rdx,%rax
    3711:	76 0e                	jbe    3721 <blobmsg_new+0x9e>
    {
      __warn_memset_zero_len ();
      return __dest;
    }
#endif
  return __builtin___memset_chk (__dest, __ch, __len, __bos0 (__dest));
    3713:	48 29 d0             	sub    %rdx,%rax
    3716:	48 89 d7             	mov    %rdx,%rdi
    3719:	48 89 c1             	mov    %rax,%rcx
    371c:	44 88 e0             	mov    %r12b,%al
    371f:	f3 aa                	rep stos %al,%es:(%rdi)
		memset(pad_start, 0, pad_end - pad_start);

	return attr;
}
    3721:	5a                   	pop    %rdx
    3722:	48 89 f0             	mov    %rsi,%rax
    3725:	5b                   	pop    %rbx
    3726:	5d                   	pop    %rbp
    3727:	41 5c                	pop    %r12
    3729:	41 5d                	pop    %r13
    372b:	41 5e                	pop    %r14
    372d:	41 5f                	pop    %r15
    372f:	c3                   	retq   

0000000000003730 <blob_pad_len>:
 * blob_len: returns the length of the attribute's payload
 */
static inline unsigned int
blob_len(const struct blob_attr *attr)
{
	return (be32_to_cpu(attr->id_len) & BLOB_ATTR_LEN_MASK) - sizeof(struct blob_attr);
    3730:	8b 07                	mov    (%rdi),%eax
    3732:	0f c8                	bswap  %eax
 */
static inline unsigned int
blob_pad_len(const struct blob_attr *attr)
{
	int len = blob_raw_len(attr);
	len = (len + BLOB_ATTR_ALIGN - 1) & ~(BLOB_ATTR_ALIGN - 1);
    3734:	25 ff ff ff 00       	and    $0xffffff,%eax
    3739:	83 c0 03             	add    $0x3,%eax
	return len;
    373c:	83 e0 fc             	and    $0xfffffffc,%eax
}
    373f:	c3                   	retq   

0000000000003740 <blobmsg_check_attr>:
 * blob_len: returns the length of the attribute's payload
 */
static inline unsigned int
blob_len(const struct blob_attr *attr)
{
	return (be32_to_cpu(attr->id_len) & BLOB_ATTR_LEN_MASK) - sizeof(struct blob_attr);
    3740:	8b 0f                	mov    (%rdi),%ecx
    3742:	0f c9                	bswap  %ecx
    3744:	41 89 ca             	mov    %ecx,%r10d
    3747:	41 81 e2 ff ff ff 00 	and    $0xffffff,%r10d
    374e:	41 83 ea 04          	sub    $0x4,%r10d
{
	const struct blobmsg_hdr *hdr;
	const char *data;
	int id, len;

	if (blob_len(attr) < sizeof(struct blobmsg_hdr))
    3752:	41 83 fa 01          	cmp    $0x1,%r10d
    3756:	76 6b                	jbe    37c3 <blobmsg_check_attr+0x83>
		return false;

	hdr = (void *) attr->data;
	if (!hdr->namelen && name)
    3758:	66 8b 47 04          	mov    0x4(%rdi),%ax
    375c:	66 85 c0             	test   %ax,%ax
    375f:	41 0f 94 c1          	sete   %r9b
    3763:	41 20 f1             	and    %sil,%r9b
    3766:	75 5b                	jne    37c3 <blobmsg_check_attr+0x83>
#define __LITTLE_ENDIAN LITTLE_ENDIAN
#endif

static inline uint16_t __u_bswap16(uint16_t val)
{
	return ((val >> 8) & 0xffu) | ((val & 0xffu) << 8);
    3768:	86 e0                	xchg   %ah,%al
		return false;

	if (blobmsg_namelen(hdr) > blob_len(attr) - sizeof(struct blobmsg_hdr))
    376a:	44 89 d2             	mov    %r10d,%edx
    376d:	0f b7 f0             	movzwl %ax,%esi
    3770:	48 83 ea 02          	sub    $0x2,%rdx
    3774:	48 39 d6             	cmp    %rdx,%rsi
    3777:	77 4d                	ja     37c6 <blobmsg_check_attr+0x86>
		return false;

	if (hdr->name[blobmsg_namelen(hdr)] != 0)
    3779:	80 7c 37 06 00       	cmpb   $0x0,0x6(%rdi,%rsi,1)
    377e:	75 46                	jne    37c6 <blobmsg_check_attr+0x86>
 * blob_id: returns the id of an attribute
 */
static inline unsigned int
blob_id(const struct blob_attr *attr)
{
	int id = (be32_to_cpu(attr->id_len) & BLOB_ATTR_ID_MASK) >> BLOB_ATTR_ID_SHIFT;
    3780:	81 e1 00 00 00 7f    	and    $0x7f000000,%ecx
{
	return be16_to_cpu(hdr->namelen);
}

bool blobmsg_check_attr(const struct blob_attr *attr, bool name)
{
    3786:	56                   	push   %rsi
    3787:	49 89 f8             	mov    %rdi,%r8
    378a:	c1 e9 18             	shr    $0x18,%ecx
static inline int blobmsg_data_len(const struct blob_attr *attr)
{
	uint8_t *start, *end;

	start = (uint8_t *) blob_data(attr);
	end = (uint8_t *) blobmsg_data(attr);
    378d:	e8 d2 fe ff ff       	callq  3664 <blobmsg_data>

	id = blob_id(attr);
	len = blobmsg_data_len(attr);
	data = blobmsg_data(attr);

	if (id > BLOBMSG_TYPE_LAST)
    3792:	83 f9 07             	cmp    $0x7,%ecx
    3795:	77 33                	ja     37ca <blobmsg_check_attr+0x8a>
		return false;

	if (!blob_type[id])
    3797:	48 8d 15 42 29 00 00 	lea    0x2942(%rip),%rdx        # 60e0 <blob_type>
    379e:	48 63 c9             	movslq %ecx,%rcx
		return true;
    37a1:	41 b1 01             	mov    $0x1,%r9b
	data = blobmsg_data(attr);

	if (id > BLOBMSG_TYPE_LAST)
		return false;

	if (!blob_type[id])
    37a4:	8b 14 8a             	mov    (%rdx,%rcx,4),%edx
    37a7:	85 d2                	test   %edx,%edx
    37a9:	74 1f                	je     37ca <blobmsg_check_attr+0x8a>
 * blob_data: returns the data pointer for an attribute
 */
static inline void *
blob_data(const struct blob_attr *attr)
{
	return (void *) attr->data;
    37ab:	49 83 c0 04          	add    $0x4,%r8
		return true;

	return blob_check_type(data, len, blob_type[id]);
    37af:	48 89 c1             	mov    %rax,%rcx
    37b2:	44 89 d6             	mov    %r10d,%esi
    37b5:	4c 29 c1             	sub    %r8,%rcx
    37b8:	48 89 c7             	mov    %rax,%rdi
    37bb:	29 ce                	sub    %ecx,%esi
}
    37bd:	59                   	pop    %rcx
		return false;

	if (!blob_type[id])
		return true;

	return blob_check_type(data, len, blob_type[id]);
    37be:	e9 6d eb ff ff       	jmpq   2330 <blob_check_type@plt>
	const struct blobmsg_hdr *hdr;
	const char *data;
	int id, len;

	if (blob_len(attr) < sizeof(struct blobmsg_hdr))
		return false;
    37c3:	45 31 c9             	xor    %r9d,%r9d

	if (!blob_type[id])
		return true;

	return blob_check_type(data, len, blob_type[id]);
}
    37c6:	44 88 c8             	mov    %r9b,%al
    37c9:	c3                   	retq   
    37ca:	44 88 c8             	mov    %r9b,%al
    37cd:	5a                   	pop    %rdx
    37ce:	c3                   	retq   

00000000000037cf <blobmsg_check_attr_list>:

bool blobmsg_check_attr_list(const struct blob_attr *attr, int type)
{
    37cf:	41 55                	push   %r13
    37d1:	41 54                	push   %r12
    37d3:	55                   	push   %rbp
    37d4:	53                   	push   %rbx
    37d5:	51                   	push   %rcx
 * blob_id: returns the id of an attribute
 */
static inline unsigned int
blob_id(const struct blob_attr *attr)
{
	int id = (be32_to_cpu(attr->id_len) & BLOB_ATTR_ID_MASK) >> BLOB_ATTR_ID_SHIFT;
    37d6:	8b 0f                	mov    (%rdi),%ecx
    37d8:	0f c9                	bswap  %ecx
	struct blob_attr *cur;
	bool name;
	int rem;

	switch (blobmsg_type(attr)) {
    37da:	89 c8                	mov    %ecx,%eax
    37dc:	25 00 00 00 7f       	and    $0x7f000000,%eax
    37e1:	c1 e8 18             	shr    $0x18,%eax
    37e4:	83 f8 01             	cmp    $0x1,%eax
    37e7:	74 0d                	je     37f6 <blobmsg_check_attr_list+0x27>
    37e9:	83 f8 02             	cmp    $0x2,%eax
    37ec:	75 67                	jne    3855 <blobmsg_check_attr_list+0x86>
	case BLOBMSG_TYPE_TABLE:
		name = true;
    37ee:	41 bc 01 00 00 00    	mov    $0x1,%r12d
    37f4:	eb 03                	jmp    37f9 <blobmsg_check_attr_list+0x2a>
		break;
	case BLOBMSG_TYPE_ARRAY:
		name = false;
    37f6:	45 31 e4             	xor    %r12d,%r12d
    37f9:	41 89 f5             	mov    %esi,%r13d
    37fc:	e8 63 fe ff ff       	callq  3664 <blobmsg_data>

	return blob_len(attr) - (end - start);
    3801:	81 e1 ff ff ff 00    	and    $0xffffff,%ecx
static inline int blobmsg_data_len(const struct blob_attr *attr)
{
	uint8_t *start, *end;

	start = (uint8_t *) blob_data(attr);
	end = (uint8_t *) blobmsg_data(attr);
    3807:	48 89 c3             	mov    %rax,%rbx

	return blob_len(attr) - (end - start);
    380a:	8d 2c 39             	lea    (%rcx,%rdi,1),%ebp
    380d:	29 c5                	sub    %eax,%ebp
		break;
	default:
		return false;
	}

	blobmsg_for_each_attr(cur, attr, rem) {
    380f:	85 ed                	test   %ebp,%ebp
    3811:	7e 46                	jle    3859 <blobmsg_check_attr_list+0x8a>
    3813:	48 89 df             	mov    %rbx,%rdi
    3816:	e8 15 ff ff ff       	callq  3730 <blob_pad_len>
    381b:	83 f8 03             	cmp    $0x3,%eax
    381e:	76 39                	jbe    3859 <blobmsg_check_attr_list+0x8a>
    3820:	39 e8                	cmp    %ebp,%eax
    3822:	77 35                	ja     3859 <blobmsg_check_attr_list+0x8a>
    3824:	8b 03                	mov    (%rbx),%eax
    3826:	0f c8                	bswap  %eax
		if (blobmsg_type(cur) != type)
    3828:	25 00 00 00 7f       	and    $0x7f000000,%eax
    382d:	c1 e8 18             	shr    $0x18,%eax
    3830:	41 39 c5             	cmp    %eax,%r13d
    3833:	75 20                	jne    3855 <blobmsg_check_attr_list+0x86>
			return false;

		if (!blobmsg_check_attr(cur, name))
    3835:	44 89 e6             	mov    %r12d,%esi
    3838:	48 89 df             	mov    %rbx,%rdi
    383b:	e8 60 ef ff ff       	callq  27a0 <blobmsg_check_attr@plt>
    3840:	84 c0                	test   %al,%al
    3842:	74 11                	je     3855 <blobmsg_check_attr_list+0x86>
		break;
	default:
		return false;
	}

	blobmsg_for_each_attr(cur, attr, rem) {
    3844:	48 89 df             	mov    %rbx,%rdi
    3847:	e8 e4 fe ff ff       	callq  3730 <blob_pad_len>
    384c:	29 c5                	sub    %eax,%ebp
}

static inline struct blob_attr *
blob_next(const struct blob_attr *attr)
{
	return (struct blob_attr *) ((char *) attr + blob_pad_len(attr));
    384e:	89 c0                	mov    %eax,%eax
    3850:	48 01 c3             	add    %rax,%rbx
    3853:	eb ba                	jmp    380f <blobmsg_check_attr_list+0x40>
		break;
	case BLOBMSG_TYPE_ARRAY:
		name = false;
		break;
	default:
		return false;
    3855:	31 c0                	xor    %eax,%eax
    3857:	eb 02                	jmp    385b <blobmsg_check_attr_list+0x8c>

		if (!blobmsg_check_attr(cur, name))
			return false;
	}

	return true;
    3859:	b0 01                	mov    $0x1,%al
}
    385b:	5a                   	pop    %rdx
    385c:	5b                   	pop    %rbx
    385d:	5d                   	pop    %rbp
    385e:	41 5c                	pop    %r12
    3860:	41 5d                	pop    %r13
    3862:	c3                   	retq   

0000000000003863 <blobmsg_parse_array>:

int blobmsg_parse_array(const struct blobmsg_policy *policy, int policy_len,
			struct blob_attr **tb, void *data, int len)
{
    3863:	41 57                	push   %r15
    3865:	41 56                	push   %r14
    3867:	49 89 ff             	mov    %rdi,%r15
    386a:	41 55                	push   %r13
    386c:	41 54                	push   %r12
    386e:	31 c0                	xor    %eax,%eax
    3870:	55                   	push   %rbp
    3871:	53                   	push   %rbx
    3872:	48 89 cb             	mov    %rcx,%rbx
    3875:	48 63 ce             	movslq %esi,%rcx
    3878:	48 89 d7             	mov    %rdx,%rdi
    387b:	41 89 f6             	mov    %esi,%r14d
    387e:	48 c1 e1 03          	shl    $0x3,%rcx
    3882:	48 83 ec 18          	sub    $0x18,%rsp
    3886:	49 89 d5             	mov    %rdx,%r13
    3889:	f3 aa                	rep stos %al,%es:(%rdi)
    388b:	44 89 c5             	mov    %r8d,%ebp
	struct blob_attr *attr;
	int i = 0;
    388e:	45 31 e4             	xor    %r12d,%r12d

	memset(tb, 0, policy_len * sizeof(*tb));
	__blob_for_each_attr(attr, data, len) {
    3891:	85 ed                	test   %ebp,%ebp
    3893:	7f 04                	jg     3899 <blobmsg_parse_array+0x36>
		tb[i++] = attr;
		if (i == policy_len)
			break;
	}

	return 0;
    3895:	31 c0                	xor    %eax,%eax
    3897:	eb 76                	jmp    390f <blobmsg_parse_array+0xac>
{
	struct blob_attr *attr;
	int i = 0;

	memset(tb, 0, policy_len * sizeof(*tb));
	__blob_for_each_attr(attr, data, len) {
    3899:	48 89 df             	mov    %rbx,%rdi
    389c:	e8 8f fe ff ff       	callq  3730 <blob_pad_len>
    38a1:	83 f8 03             	cmp    $0x3,%eax
    38a4:	76 ef                	jbe    3895 <blobmsg_parse_array+0x32>
    38a6:	39 e8                	cmp    %ebp,%eax
    38a8:	77 eb                	ja     3895 <blobmsg_parse_array+0x32>
		if (policy[i].type != BLOBMSG_TYPE_UNSPEC &&
    38aa:	49 63 d4             	movslq %r12d,%rdx
    38ad:	48 89 d0             	mov    %rdx,%rax
    38b0:	48 c1 e0 04          	shl    $0x4,%rax
    38b4:	41 8b 4c 07 08       	mov    0x8(%r15,%rax,1),%ecx
    38b9:	85 c9                	test   %ecx,%ecx
    38bb:	74 10                	je     38cd <blobmsg_parse_array+0x6a>
 * blob_id: returns the id of an attribute
 */
static inline unsigned int
blob_id(const struct blob_attr *attr)
{
	int id = (be32_to_cpu(attr->id_len) & BLOB_ATTR_ID_MASK) >> BLOB_ATTR_ID_SHIFT;
    38bd:	8b 03                	mov    (%rbx),%eax
    38bf:	0f c8                	bswap  %eax
    38c1:	25 00 00 00 7f       	and    $0x7f000000,%eax
    38c6:	c1 e8 18             	shr    $0x18,%eax
    38c9:	39 c1                	cmp    %eax,%ecx
    38cb:	75 2e                	jne    38fb <blobmsg_parse_array+0x98>
		    blob_id(attr) != policy[i].type)
			continue;

		if (!blobmsg_check_attr(attr, false))
    38cd:	31 f6                	xor    %esi,%esi
    38cf:	48 89 df             	mov    %rbx,%rdi
    38d2:	48 89 54 24 08       	mov    %rdx,0x8(%rsp)
    38d7:	e8 c4 ee ff ff       	callq  27a0 <blobmsg_check_attr@plt>
    38dc:	84 c0                	test   %al,%al
    38de:	74 2c                	je     390c <blobmsg_parse_array+0xa9>
			return -1;

		if (tb[i])
    38e0:	48 8b 54 24 08       	mov    0x8(%rsp),%rdx
    38e5:	49 8d 44 d5 00       	lea    0x0(%r13,%rdx,8),%rax
    38ea:	48 83 38 00          	cmpq   $0x0,(%rax)
    38ee:	75 0b                	jne    38fb <blobmsg_parse_array+0x98>
			continue;

		tb[i++] = attr;
    38f0:	41 ff c4             	inc    %r12d
    38f3:	48 89 18             	mov    %rbx,(%rax)
		if (i == policy_len)
    38f6:	45 39 e6             	cmp    %r12d,%r14d
    38f9:	74 9a                	je     3895 <blobmsg_parse_array+0x32>
{
	struct blob_attr *attr;
	int i = 0;

	memset(tb, 0, policy_len * sizeof(*tb));
	__blob_for_each_attr(attr, data, len) {
    38fb:	48 89 df             	mov    %rbx,%rdi
    38fe:	e8 2d fe ff ff       	callq  3730 <blob_pad_len>
    3903:	29 c5                	sub    %eax,%ebp
}

static inline struct blob_attr *
blob_next(const struct blob_attr *attr)
{
	return (struct blob_attr *) ((char *) attr + blob_pad_len(attr));
    3905:	89 c0                	mov    %eax,%eax
    3907:	48 01 c3             	add    %rax,%rbx
    390a:	eb 85                	jmp    3891 <blobmsg_parse_array+0x2e>
		if (policy[i].type != BLOBMSG_TYPE_UNSPEC &&
		    blob_id(attr) != policy[i].type)
			continue;

		if (!blobmsg_check_attr(attr, false))
			return -1;
    390c:	83 c8 ff             	or     $0xffffffff,%eax
		if (i == policy_len)
			break;
	}

	return 0;
}
    390f:	48 83 c4 18          	add    $0x18,%rsp
    3913:	5b                   	pop    %rbx
    3914:	5d                   	pop    %rbp
    3915:	41 5c                	pop    %r12
    3917:	41 5d                	pop    %r13
    3919:	41 5e                	pop    %r14
    391b:	41 5f                	pop    %r15
    391d:	c3                   	retq   

000000000000391e <blobmsg_parse>:


int blobmsg_parse(const struct blobmsg_policy *policy, int policy_len,
                  struct blob_attr **tb, void *data, int len)
{
    391e:	55                   	push   %rbp
	pslen = alloca(policy_len);
	for (i = 0; i < policy_len; i++) {
		if (!policy[i].name)
			continue;

		pslen[i] = strlen(policy[i].name);
    391f:	49 83 c9 ff          	or     $0xffffffffffffffff,%r9
}


int blobmsg_parse(const struct blobmsg_policy *policy, int policy_len,
                  struct blob_attr **tb, void *data, int len)
{
    3923:	48 89 e5             	mov    %rsp,%rbp
    3926:	41 57                	push   %r15
    3928:	41 56                	push   %r14
    392a:	41 55                	push   %r13
    392c:	41 54                	push   %r12
    392e:	49 89 cf             	mov    %rcx,%r15
    3931:	53                   	push   %rbx
    3932:	45 89 c4             	mov    %r8d,%r12d
    3935:	49 89 d5             	mov    %rdx,%r13
    3938:	48 83 ec 38          	sub    $0x38,%rsp
    393c:	89 75 bc             	mov    %esi,-0x44(%rbp)
	struct blobmsg_hdr *hdr;
	struct blob_attr *attr;
	uint8_t *pslen;
	int i;

	memset(tb, 0, policy_len * sizeof(*tb));
    393f:	48 63 f6             	movslq %esi,%rsi
    3942:	48 8d 0c f5 00 00 00 	lea    0x0(,%rsi,8),%rcx
    3949:	00 
}


int blobmsg_parse(const struct blobmsg_policy *policy, int policy_len,
                  struct blob_attr **tb, void *data, int len)
{
    394a:	48 89 7d a8          	mov    %rdi,-0x58(%rbp)
	struct blob_attr *attr;
	uint8_t *pslen;
	int i;

	memset(tb, 0, policy_len * sizeof(*tb));
	pslen = alloca(policy_len);
    394e:	48 83 c6 1e          	add    $0x1e,%rsi
}


int blobmsg_parse(const struct blobmsg_policy *policy, int policy_len,
                  struct blob_attr **tb, void *data, int len)
{
    3952:	64 48 8b 04 25 28 00 	mov    %fs:0x28,%rax
    3959:	00 00 
    395b:	48 89 45 c8          	mov    %rax,-0x38(%rbp)
    395f:	31 c0                	xor    %eax,%eax
    3961:	48 89 d7             	mov    %rdx,%rdi
	struct blob_attr *attr;
	uint8_t *pslen;
	int i;

	memset(tb, 0, policy_len * sizeof(*tb));
	pslen = alloca(policy_len);
    3964:	48 83 e6 f0          	and    $0xfffffffffffffff0,%rsi
	for (i = 0; i < policy_len; i++) {
    3968:	4c 8b 45 a8          	mov    -0x58(%rbp),%r8
    396c:	f3 aa                	rep stos %al,%es:(%rdi)
	struct blob_attr *attr;
	uint8_t *pslen;
	int i;

	memset(tb, 0, policy_len * sizeof(*tb));
	pslen = alloca(policy_len);
    396e:	48 29 f4             	sub    %rsi,%rsp
    3971:	48 8d 5c 24 0f       	lea    0xf(%rsp),%rbx
    3976:	48 83 e3 f0          	and    $0xfffffffffffffff0,%rbx
    397a:	48 89 5d b0          	mov    %rbx,-0x50(%rbp)
	for (i = 0; i < policy_len; i++) {
    397e:	48 89 de             	mov    %rbx,%rsi
    3981:	89 f1                	mov    %esi,%ecx
    3983:	2b 4d b0             	sub    -0x50(%rbp),%ecx
    3986:	39 4d bc             	cmp    %ecx,-0x44(%rbp)
    3989:	7e 40                	jle    39cb <blobmsg_parse+0xad>
		if (!policy[i].name)
    398b:	49 8b 38             	mov    (%r8),%rdi
    398e:	48 85 ff             	test   %rdi,%rdi
    3991:	74 0d                	je     39a0 <blobmsg_parse+0x82>
			continue;

		pslen[i] = strlen(policy[i].name);
    3993:	4c 89 c9             	mov    %r9,%rcx
    3996:	f2 ae                	repnz scas %es:(%rdi),%al
    3998:	48 f7 d1             	not    %rcx
    399b:	48 ff c9             	dec    %rcx
    399e:	88 0e                	mov    %cl,(%rsi)
    39a0:	49 83 c0 10          	add    $0x10,%r8
    39a4:	48 ff c6             	inc    %rsi
    39a7:	eb d8                	jmp    3981 <blobmsg_parse+0x63>
	}

	__blob_for_each_attr(attr, data, len) {
		hdr = blob_data(attr);
		for (i = 0; i < policy_len; i++) {
			if (!policy[i].name)
    39a9:	49 83 3e 00          	cmpq   $0x0,(%r14)
    39ad:	75 4b                	jne    39fa <blobmsg_parse+0xdc>
    39af:	48 ff c3             	inc    %rbx
    39b2:	49 83 c6 10          	add    $0x10,%r14
		pslen[i] = strlen(policy[i].name);
	}

	__blob_for_each_attr(attr, data, len) {
		hdr = blob_data(attr);
		for (i = 0; i < policy_len; i++) {
    39b6:	39 5d bc             	cmp    %ebx,-0x44(%rbp)
    39b9:	7f ee                	jg     39a9 <blobmsg_parse+0x8b>
			continue;

		pslen[i] = strlen(policy[i].name);
	}

	__blob_for_each_attr(attr, data, len) {
    39bb:	4c 89 ff             	mov    %r15,%rdi
    39be:	e8 6d fd ff ff       	callq  3730 <blob_pad_len>
    39c3:	41 29 c4             	sub    %eax,%r12d
    39c6:	89 c0                	mov    %eax,%eax
    39c8:	49 01 c7             	add    %rax,%r15
    39cb:	45 85 e4             	test   %r12d,%r12d
    39ce:	0f 8e 93 00 00 00    	jle    3a67 <blobmsg_parse+0x149>
    39d4:	4c 89 ff             	mov    %r15,%rdi
    39d7:	e8 54 fd ff ff       	callq  3730 <blob_pad_len>
    39dc:	83 f8 03             	cmp    $0x3,%eax
    39df:	0f 86 82 00 00 00    	jbe    3a67 <blobmsg_parse+0x149>
    39e5:	44 39 e0             	cmp    %r12d,%eax
    39e8:	77 7d                	ja     3a67 <blobmsg_parse+0x149>
				return -1;

			if (tb[i])
				continue;

			if (strcmp(policy[i].name, (char *) hdr->name) != 0)
    39ea:	49 8d 47 06          	lea    0x6(%r15),%rax
    39ee:	4c 8b 75 a8          	mov    -0x58(%rbp),%r14
    39f2:	31 db                	xor    %ebx,%ebx
    39f4:	48 89 45 a0          	mov    %rax,-0x60(%rbp)
    39f8:	eb bc                	jmp    39b6 <blobmsg_parse+0x98>
		hdr = blob_data(attr);
		for (i = 0; i < policy_len; i++) {
			if (!policy[i].name)
				continue;

			if (policy[i].type != BLOBMSG_TYPE_UNSPEC &&
    39fa:	41 8b 76 08          	mov    0x8(%r14),%esi
    39fe:	85 f6                	test   %esi,%esi
    3a00:	74 11                	je     3a13 <blobmsg_parse+0xf5>
 * blob_id: returns the id of an attribute
 */
static inline unsigned int
blob_id(const struct blob_attr *attr)
{
	int id = (be32_to_cpu(attr->id_len) & BLOB_ATTR_ID_MASK) >> BLOB_ATTR_ID_SHIFT;
    3a02:	41 8b 07             	mov    (%r15),%eax
    3a05:	0f c8                	bswap  %eax
    3a07:	25 00 00 00 7f       	and    $0x7f000000,%eax
    3a0c:	c1 e8 18             	shr    $0x18,%eax
    3a0f:	39 c6                	cmp    %eax,%esi
    3a11:	75 9c                	jne    39af <blobmsg_parse+0x91>
			    blob_id(attr) != policy[i].type)
				continue;

			if (blobmsg_namelen(hdr) != pslen[i])
    3a13:	48 8b 55 b0          	mov    -0x50(%rbp),%rdx
    3a17:	66 41 8b 47 04       	mov    0x4(%r15),%ax
    3a1c:	0f b6 34 1a          	movzbl (%rdx,%rbx,1),%esi
    3a20:	86 e0                	xchg   %ah,%al
    3a22:	66 39 f0             	cmp    %si,%ax
    3a25:	75 88                	jne    39af <blobmsg_parse+0x91>
				continue;

			if (!blobmsg_check_attr(attr, true))
    3a27:	be 01 00 00 00       	mov    $0x1,%esi
    3a2c:	4c 89 ff             	mov    %r15,%rdi
    3a2f:	e8 6c ed ff ff       	callq  27a0 <blobmsg_check_attr@plt>
    3a34:	84 c0                	test   %al,%al
    3a36:	74 2a                	je     3a62 <blobmsg_parse+0x144>
				return -1;

			if (tb[i])
    3a38:	49 83 7c dd 00 00    	cmpq   $0x0,0x0(%r13,%rbx,8)
    3a3e:	0f 85 6b ff ff ff    	jne    39af <blobmsg_parse+0x91>
				continue;

			if (strcmp(policy[i].name, (char *) hdr->name) != 0)
    3a44:	48 8b 75 a0          	mov    -0x60(%rbp),%rsi
    3a48:	49 8b 3e             	mov    (%r14),%rdi
    3a4b:	e8 50 eb ff ff       	callq  25a0 <strcmp@plt>
    3a50:	85 c0                	test   %eax,%eax
    3a52:	0f 85 57 ff ff ff    	jne    39af <blobmsg_parse+0x91>
				continue;

			tb[i] = attr;
    3a58:	4d 89 7c dd 00       	mov    %r15,0x0(%r13,%rbx,8)
    3a5d:	e9 4d ff ff ff       	jmpq   39af <blobmsg_parse+0x91>

			if (blobmsg_namelen(hdr) != pslen[i])
				continue;

			if (!blobmsg_check_attr(attr, true))
				return -1;
    3a62:	83 c8 ff             	or     $0xffffffff,%eax
    3a65:	eb 02                	jmp    3a69 <blobmsg_parse+0x14b>

			tb[i] = attr;
		}
	}

	return 0;
    3a67:	31 c0                	xor    %eax,%eax
}
    3a69:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
    3a6d:	64 48 33 14 25 28 00 	xor    %fs:0x28,%rdx
    3a74:	00 00 
    3a76:	74 05                	je     3a7d <blobmsg_parse+0x15f>
    3a78:	e8 03 ea ff ff       	callq  2480 <__stack_chk_fail@plt>
    3a7d:	48 8d 65 d8          	lea    -0x28(%rbp),%rsp
    3a81:	5b                   	pop    %rbx
    3a82:	41 5c                	pop    %r12
    3a84:	41 5d                	pop    %r13
    3a86:	41 5e                	pop    %r14
    3a88:	41 5f                	pop    %r15
    3a8a:	5d                   	pop    %rbp
    3a8b:	c3                   	retq   

0000000000003a8c <blobmsg_open_nested>:
}


void *
blobmsg_open_nested(struct blob_buf *buf, const char *name, bool array)
{
    3a8c:	41 55                	push   %r13
    3a8e:	41 54                	push   %r12
    3a90:	49 89 fc             	mov    %rdi,%r12
    3a93:	55                   	push   %rbp
    3a94:	53                   	push   %rbx
    3a95:	48 89 f5             	mov    %rsi,%rbp
    3a98:	48 83 ec 18          	sub    $0x18,%rsp
	struct blob_attr *head = buf->head;
	int type = array ? BLOBMSG_TYPE_ARRAY : BLOBMSG_TYPE_TABLE;
	unsigned long offset = attr_to_offset(buf, buf->head);
    3a9c:	48 8b 1f             	mov    (%rdi),%rbx
}


void *
blobmsg_open_nested(struct blob_buf *buf, const char *name, bool array)
{
    3a9f:	64 48 8b 04 25 28 00 	mov    %fs:0x28,%rax
    3aa6:	00 00 
    3aa8:	48 89 44 24 08       	mov    %rax,0x8(%rsp)
    3aad:	31 c0                	xor    %eax,%eax
	struct blob_attr *head = buf->head;
	int type = array ? BLOBMSG_TYPE_ARRAY : BLOBMSG_TYPE_TABLE;
    3aaf:	80 fa 01             	cmp    $0x1,%dl
	unsigned long offset = attr_to_offset(buf, buf->head);
	void *data;

	if (!name)
		name = "";
    3ab2:	48 8d 05 77 26 00 00 	lea    0x2677(%rip),%rax        # 6130 <blob_type+0x50>

	head = blobmsg_new(buf, type, name, 0, &data);
    3ab9:	49 89 e0             	mov    %rsp,%r8

void *
blobmsg_open_nested(struct blob_buf *buf, const char *name, bool array)
{
	struct blob_attr *head = buf->head;
	int type = array ? BLOBMSG_TYPE_ARRAY : BLOBMSG_TYPE_TABLE;
    3abc:	19 f6                	sbb    %esi,%esi
	unsigned long offset = attr_to_offset(buf, buf->head);
    3abe:	48 2b 5f 18          	sub    0x18(%rdi),%rbx

void *
blobmsg_open_nested(struct blob_buf *buf, const char *name, bool array)
{
	struct blob_attr *head = buf->head;
	int type = array ? BLOBMSG_TYPE_ARRAY : BLOBMSG_TYPE_TABLE;
    3ac2:	f7 d6                	not    %esi
    3ac4:	83 c6 02             	add    $0x2,%esi
	unsigned long offset = attr_to_offset(buf, buf->head);
    3ac7:	81 c3 67 45 23 01    	add    $0x1234567,%ebx
	void *data;

	if (!name)
		name = "";
    3acd:	48 85 ed             	test   %rbp,%rbp
    3ad0:	48 0f 44 e8          	cmove  %rax,%rbp

	head = blobmsg_new(buf, type, name, 0, &data);
    3ad4:	31 c9                	xor    %ecx,%ecx
    3ad6:	48 89 ea             	mov    %rbp,%rdx
    3ad9:	e8 a5 fb ff ff       	callq  3683 <blobmsg_new>
	blob_set_raw_len(buf->head, blob_pad_len(buf->head) - blobmsg_hdrlen(strlen(name)));
    3ade:	49 8b 14 24          	mov    (%r12),%rdx
	void *data;

	if (!name)
		name = "";

	head = blobmsg_new(buf, type, name, 0, &data);
    3ae2:	49 89 c5             	mov    %rax,%r13
	blob_set_raw_len(buf->head, blob_pad_len(buf->head) - blobmsg_hdrlen(strlen(name)));
    3ae5:	48 89 d7             	mov    %rdx,%rdi
    3ae8:	e8 43 fc ff ff       	callq  3730 <blob_pad_len>
    3aed:	48 83 c9 ff          	or     $0xffffffffffffffff,%rcx
    3af1:	89 c6                	mov    %eax,%esi
    3af3:	48 89 ef             	mov    %rbp,%rdi
    3af6:	31 c0                	xor    %eax,%eax
    3af8:	f2 ae                	repnz scas %es:(%rdi),%al
    3afa:	48 89 d7             	mov    %rdx,%rdi
    3afd:	48 89 c8             	mov    %rcx,%rax
    3b00:	48 f7 d0             	not    %rax
    3b03:	83 c0 05             	add    $0x5,%eax
    3b06:	83 e0 fc             	and    $0xfffffffc,%eax
    3b09:	29 c6                	sub    %eax,%esi
    3b0b:	e8 00 ea ff ff       	callq  2510 <blob_set_raw_len@plt>
	buf->head = head;
	return (void *)offset;
}
    3b10:	48 8b 4c 24 08       	mov    0x8(%rsp),%rcx
    3b15:	64 48 33 0c 25 28 00 	xor    %fs:0x28,%rcx
    3b1c:	00 00 
	if (!name)
		name = "";

	head = blobmsg_new(buf, type, name, 0, &data);
	blob_set_raw_len(buf->head, blob_pad_len(buf->head) - blobmsg_hdrlen(strlen(name)));
	buf->head = head;
    3b1e:	4d 89 2c 24          	mov    %r13,(%r12)
	return (void *)offset;
}
    3b22:	74 05                	je     3b29 <blobmsg_open_nested+0x9d>
    3b24:	e8 57 e9 ff ff       	callq  2480 <__stack_chk_fail@plt>
    3b29:	48 83 c4 18          	add    $0x18,%rsp
    3b2d:	48 63 db             	movslq %ebx,%rbx
    3b30:	48 89 d8             	mov    %rbx,%rax
    3b33:	5b                   	pop    %rbx
    3b34:	5d                   	pop    %rbp
    3b35:	41 5c                	pop    %r12
    3b37:	41 5d                	pop    %r13
    3b39:	c3                   	retq   

0000000000003b3a <blobmsg_alloc_string_buffer>:
	va_end(ap);
}

void *
blobmsg_alloc_string_buffer(struct blob_buf *buf, const char *name, int maxlen)
{
    3b3a:	41 54                	push   %r12
    3b3c:	55                   	push   %rbp
	struct blob_attr *attr;
	void *data_dest;

	attr = blobmsg_new(buf, BLOBMSG_TYPE_STRING, name, maxlen, &data_dest);
    3b3d:	89 d1                	mov    %edx,%ecx
	va_end(ap);
}

void *
blobmsg_alloc_string_buffer(struct blob_buf *buf, const char *name, int maxlen)
{
    3b3f:	53                   	push   %rbx
    3b40:	89 d5                	mov    %edx,%ebp
	struct blob_attr *attr;
	void *data_dest;

	attr = blobmsg_new(buf, BLOBMSG_TYPE_STRING, name, maxlen, &data_dest);
    3b42:	48 89 f2             	mov    %rsi,%rdx
    3b45:	be 03 00 00 00       	mov    $0x3,%esi
	va_end(ap);
}

void *
blobmsg_alloc_string_buffer(struct blob_buf *buf, const char *name, int maxlen)
{
    3b4a:	49 89 fc             	mov    %rdi,%r12
    3b4d:	48 83 ec 10          	sub    $0x10,%rsp
	struct blob_attr *attr;
	void *data_dest;

	attr = blobmsg_new(buf, BLOBMSG_TYPE_STRING, name, maxlen, &data_dest);
    3b51:	49 89 e0             	mov    %rsp,%r8
	va_end(ap);
}

void *
blobmsg_alloc_string_buffer(struct blob_buf *buf, const char *name, int maxlen)
{
    3b54:	64 48 8b 04 25 28 00 	mov    %fs:0x28,%rax
    3b5b:	00 00 
    3b5d:	48 89 44 24 08       	mov    %rax,0x8(%rsp)
    3b62:	31 c0                	xor    %eax,%eax
	struct blob_attr *attr;
	void *data_dest;

	attr = blobmsg_new(buf, BLOBMSG_TYPE_STRING, name, maxlen, &data_dest);
    3b64:	e8 1a fb ff ff       	callq  3683 <blobmsg_new>
    3b69:	48 89 c3             	mov    %rax,%rbx
    3b6c:	31 c0                	xor    %eax,%eax
	if (!attr)
    3b6e:	48 85 db             	test   %rbx,%rbx
    3b71:	74 44                	je     3bb7 <blobmsg_alloc_string_buffer+0x7d>
		return NULL;

	data_dest = blobmsg_data(attr);
    3b73:	48 89 df             	mov    %rbx,%rdi
    3b76:	e8 e9 fa ff ff       	callq  3664 <blobmsg_data>
	blob_set_raw_len(buf->head, blob_pad_len(buf->head) - blob_pad_len(attr));
    3b7b:	49 8b 14 24          	mov    (%r12),%rdx

	attr = blobmsg_new(buf, BLOBMSG_TYPE_STRING, name, maxlen, &data_dest);
	if (!attr)
		return NULL;

	data_dest = blobmsg_data(attr);
    3b7f:	48 89 04 24          	mov    %rax,(%rsp)
	blob_set_raw_len(buf->head, blob_pad_len(buf->head) - blob_pad_len(attr));
    3b83:	48 89 d7             	mov    %rdx,%rdi
    3b86:	e8 a5 fb ff ff       	callq  3730 <blob_pad_len>
    3b8b:	48 89 df             	mov    %rbx,%rdi
    3b8e:	89 c6                	mov    %eax,%esi
    3b90:	e8 9b fb ff ff       	callq  3730 <blob_pad_len>
    3b95:	29 c6                	sub    %eax,%esi
    3b97:	48 89 d7             	mov    %rdx,%rdi
    3b9a:	e8 71 e9 ff ff       	callq  2510 <blob_set_raw_len@plt>
 * blob_len: returns the length of the attribute's payload
 */
static inline unsigned int
blob_len(const struct blob_attr *attr)
{
	return (be32_to_cpu(attr->id_len) & BLOB_ATTR_LEN_MASK) - sizeof(struct blob_attr);
    3b9f:	8b 33                	mov    (%rbx),%esi
	blob_set_raw_len(attr, blob_raw_len(attr) - maxlen);
    3ba1:	48 89 df             	mov    %rbx,%rdi
    3ba4:	0f ce                	bswap  %esi
    3ba6:	81 e6 ff ff ff 00    	and    $0xffffff,%esi
    3bac:	29 ee                	sub    %ebp,%esi
    3bae:	e8 5d e9 ff ff       	callq  2510 <blob_set_raw_len@plt>

	return data_dest;
    3bb3:	48 8b 04 24          	mov    (%rsp),%rax
}
    3bb7:	48 8b 4c 24 08       	mov    0x8(%rsp),%rcx
    3bbc:	64 48 33 0c 25 28 00 	xor    %fs:0x28,%rcx
    3bc3:	00 00 
    3bc5:	74 05                	je     3bcc <blobmsg_alloc_string_buffer+0x92>
    3bc7:	e8 b4 e8 ff ff       	callq  2480 <__stack_chk_fail@plt>
    3bcc:	48 83 c4 10          	add    $0x10,%rsp
    3bd0:	5b                   	pop    %rbx
    3bd1:	5d                   	pop    %rbp
    3bd2:	41 5c                	pop    %r12
    3bd4:	c3                   	retq   

0000000000003bd5 <blobmsg_realloc_string_buffer>:

void *
blobmsg_realloc_string_buffer(struct blob_buf *buf, int maxlen)
{
    3bd5:	53                   	push   %rbx
	struct blob_attr *attr = blob_next(buf->head);
    3bd6:	48 8b 17             	mov    (%rdi),%rdx
	return data_dest;
}

void *
blobmsg_realloc_string_buffer(struct blob_buf *buf, int maxlen)
{
    3bd9:	48 89 fb             	mov    %rdi,%rbx
}

static inline struct blob_attr *
blob_next(const struct blob_attr *attr)
{
	return (struct blob_attr *) ((char *) attr + blob_pad_len(attr));
    3bdc:	48 89 d7             	mov    %rdx,%rdi
    3bdf:	e8 4c fb ff ff       	callq  3730 <blob_pad_len>
    3be4:	89 c0                	mov    %eax,%eax
    3be6:	48 01 c2             	add    %rax,%rdx
	struct blob_attr *attr = blob_next(buf->head);
	int offset = attr_to_offset(buf, blob_next(buf->head)) + blob_pad_len(attr) - BLOB_COOKIE;
    3be9:	48 89 d7             	mov    %rdx,%rdi
    3bec:	e8 3f fb ff ff       	callq  3730 <blob_pad_len>
	int required = maxlen - (buf->buflen - offset);
    3bf1:	48 89 d1             	mov    %rdx,%rcx
    3bf4:	48 2b 4b 18          	sub    0x18(%rbx),%rcx
    3bf8:	01 c8                	add    %ecx,%eax
    3bfa:	01 c6                	add    %eax,%esi
    3bfc:	2b 73 10             	sub    0x10(%rbx),%esi

	if (required <= 0)
    3bff:	85 f6                	test   %esi,%esi
    3c01:	7e 18                	jle    3c1b <blobmsg_realloc_string_buffer+0x46>
		goto out;

	blob_buf_grow(buf, required);
    3c03:	48 89 df             	mov    %rbx,%rdi
    3c06:	e8 d5 e8 ff ff       	callq  24e0 <blob_buf_grow@plt>
	attr = blob_next(buf->head);
    3c0b:	48 8b 13             	mov    (%rbx),%rdx
    3c0e:	48 89 d7             	mov    %rdx,%rdi
    3c11:	e8 1a fb ff ff       	callq  3730 <blob_pad_len>
    3c16:	89 c0                	mov    %eax,%eax
    3c18:	48 01 c2             	add    %rax,%rdx

out:
	return blobmsg_data(attr);
}
    3c1b:	5b                   	pop    %rbx

	blob_buf_grow(buf, required);
	attr = blob_next(buf->head);

out:
	return blobmsg_data(attr);
    3c1c:	48 89 d7             	mov    %rdx,%rdi
    3c1f:	e9 40 fa ff ff       	jmpq   3664 <blobmsg_data>

0000000000003c24 <blobmsg_add_string_buffer>:
}

void
blobmsg_add_string_buffer(struct blob_buf *buf)
{
    3c24:	55                   	push   %rbp
    3c25:	53                   	push   %rbx
    3c26:	48 89 fd             	mov    %rdi,%rbp
    3c29:	50                   	push   %rax
	struct blob_attr *attr;
	int len, attrlen;

	attr = blob_next(buf->head);
    3c2a:	48 8b 1f             	mov    (%rdi),%rbx
    3c2d:	48 89 df             	mov    %rbx,%rdi
    3c30:	e8 fb fa ff ff       	callq  3730 <blob_pad_len>
    3c35:	89 c0                	mov    %eax,%eax
    3c37:	48 01 c3             	add    %rax,%rbx
	len = strlen(blobmsg_data(attr)) + 1;
    3c3a:	48 89 df             	mov    %rbx,%rdi
    3c3d:	e8 22 fa ff ff       	callq  3664 <blobmsg_data>
 * blob_len: returns the length of the attribute's payload
 */
static inline unsigned int
blob_len(const struct blob_attr *attr)
{
	return (be32_to_cpu(attr->id_len) & BLOB_ATTR_LEN_MASK) - sizeof(struct blob_attr);
    3c42:	8b 33                	mov    (%rbx),%esi
    3c44:	48 89 c7             	mov    %rax,%rdi
    3c47:	48 83 c9 ff          	or     $0xffffffffffffffff,%rcx
    3c4b:	31 c0                	xor    %eax,%eax
    3c4d:	f2 ae                	repnz scas %es:(%rdi),%al
    3c4f:	0f ce                	bswap  %esi

	attrlen = blob_raw_len(attr) + len;
	blob_set_raw_len(attr, attrlen);
    3c51:	48 89 df             	mov    %rbx,%rdi
{
	struct blob_attr *attr;
	int len, attrlen;

	attr = blob_next(buf->head);
	len = strlen(blobmsg_data(attr)) + 1;
    3c54:	48 89 c8             	mov    %rcx,%rax

	attrlen = blob_raw_len(attr) + len;
	blob_set_raw_len(attr, attrlen);
    3c57:	81 e6 ff ff ff 00    	and    $0xffffff,%esi
{
	struct blob_attr *attr;
	int len, attrlen;

	attr = blob_next(buf->head);
	len = strlen(blobmsg_data(attr)) + 1;
    3c5d:	48 f7 d0             	not    %rax

	attrlen = blob_raw_len(attr) + len;
	blob_set_raw_len(attr, attrlen);
    3c60:	01 c6                	add    %eax,%esi
    3c62:	e8 a9 e8 ff ff       	callq  2510 <blob_set_raw_len@plt>
	blob_fill_pad(attr);
    3c67:	48 89 df             	mov    %rbx,%rdi
    3c6a:	e8 61 e7 ff ff       	callq  23d0 <blob_fill_pad@plt>

	blob_set_raw_len(buf->head, blob_raw_len(buf->head) + blob_pad_len(attr));
    3c6f:	48 8b 55 00          	mov    0x0(%rbp),%rdx
    3c73:	48 89 df             	mov    %rbx,%rdi
    3c76:	8b 32                	mov    (%rdx),%esi
    3c78:	0f ce                	bswap  %esi
    3c7a:	e8 b1 fa ff ff       	callq  3730 <blob_pad_len>
    3c7f:	48 89 d7             	mov    %rdx,%rdi
    3c82:	81 e6 ff ff ff 00    	and    $0xffffff,%esi
}
    3c88:	5a                   	pop    %rdx
    3c89:	5b                   	pop    %rbx
    3c8a:	5d                   	pop    %rbp

	attrlen = blob_raw_len(attr) + len;
	blob_set_raw_len(attr, attrlen);
	blob_fill_pad(attr);

	blob_set_raw_len(buf->head, blob_raw_len(buf->head) + blob_pad_len(attr));
    3c8b:	01 c6                	add    %eax,%esi
    3c8d:	e9 7e e8 ff ff       	jmpq   2510 <blob_set_raw_len@plt>

0000000000003c92 <blobmsg_vprintf>:
	return (void *)offset;
}

void
blobmsg_vprintf(struct blob_buf *buf, const char *name, const char *format, va_list arg)
{
    3c92:	41 55                	push   %r13
    3c94:	41 54                	push   %r12
    3c96:	49 89 f4             	mov    %rsi,%r12
    3c99:	55                   	push   %rbp
    3c9a:	53                   	push   %rbx
    3c9b:	48 89 cb             	mov    %rcx,%rbx
    3c9e:	48 89 fd             	mov    %rdi,%rbp
	va_list arg2;
	char cbuf;
	int len;

	va_copy(arg2, arg);
    3ca1:	b9 06 00 00 00       	mov    $0x6,%ecx
    3ca6:	48 89 de             	mov    %rbx,%rsi
	return (void *)offset;
}

void
blobmsg_vprintf(struct blob_buf *buf, const char *name, const char *format, va_list arg)
{
    3ca9:	48 83 ec 38          	sub    $0x38,%rsp

__fortify_function int
__NTH (vsnprintf (char *__restrict __s, size_t __n,
		  const char *__restrict __fmt, _G_va_list __ap))
{
  return __builtin___vsnprintf_chk (__s, __n, __USE_FORTIFY_LEVEL - 1,
    3cad:	49 89 d0             	mov    %rdx,%r8
    3cb0:	49 89 d5             	mov    %rdx,%r13
	va_list arg2;
	char cbuf;
	int len;

	va_copy(arg2, arg);
    3cb3:	4c 8d 4c 24 10       	lea    0x10(%rsp),%r9
    3cb8:	ba 01 00 00 00       	mov    $0x1,%edx
	return (void *)offset;
}

void
blobmsg_vprintf(struct blob_buf *buf, const char *name, const char *format, va_list arg)
{
    3cbd:	64 48 8b 04 25 28 00 	mov    %fs:0x28,%rax
    3cc4:	00 00 
    3cc6:	48 89 44 24 28       	mov    %rax,0x28(%rsp)
    3ccb:	31 c0                	xor    %eax,%eax
	va_list arg2;
	char cbuf;
	int len;

	va_copy(arg2, arg);
    3ccd:	4c 89 cf             	mov    %r9,%rdi
    3cd0:	f3 a5                	rep movsl %ds:(%rsi),%es:(%rdi)
    3cd2:	48 8d 7c 24 0f       	lea    0xf(%rsp),%rdi
    3cd7:	b9 01 00 00 00       	mov    $0x1,%ecx
    3cdc:	be 01 00 00 00       	mov    $0x1,%esi
    3ce1:	e8 2a e9 ff ff       	callq  2610 <__vsnprintf_chk@plt>
	len = vsnprintf(&cbuf, sizeof(cbuf), format, arg2);
	va_end(arg2);

	vsprintf(blobmsg_alloc_string_buffer(buf, name, len + 1), format, arg);
    3ce6:	8d 50 01             	lea    0x1(%rax),%edx
    3ce9:	4c 89 e6             	mov    %r12,%rsi
    3cec:	48 89 ef             	mov    %rbp,%rdi
    3cef:	e8 0c e8 ff ff       	callq  2500 <blobmsg_alloc_string_buffer@plt>

__fortify_function int
__NTH (vsprintf (char *__restrict __s, const char *__restrict __fmt,
		 _G_va_list __ap))
{
  return __builtin___vsprintf_chk (__s, __USE_FORTIFY_LEVEL - 1,
    3cf4:	48 83 ca ff          	or     $0xffffffffffffffff,%rdx
    3cf8:	49 89 d8             	mov    %rbx,%r8
    3cfb:	4c 89 e9             	mov    %r13,%rcx
    3cfe:	be 01 00 00 00       	mov    $0x1,%esi
    3d03:	48 89 c7             	mov    %rax,%rdi
    3d06:	e8 85 ea ff ff       	callq  2790 <__vsprintf_chk@plt>
	blobmsg_add_string_buffer(buf);
    3d0b:	48 89 ef             	mov    %rbp,%rdi
    3d0e:	e8 9d e8 ff ff       	callq  25b0 <blobmsg_add_string_buffer@plt>
}
    3d13:	48 8b 44 24 28       	mov    0x28(%rsp),%rax
    3d18:	64 48 33 04 25 28 00 	xor    %fs:0x28,%rax
    3d1f:	00 00 
    3d21:	74 05                	je     3d28 <blobmsg_vprintf+0x96>
    3d23:	e8 58 e7 ff ff       	callq  2480 <__stack_chk_fail@plt>
    3d28:	48 83 c4 38          	add    $0x38,%rsp
    3d2c:	5b                   	pop    %rbx
    3d2d:	5d                   	pop    %rbp
    3d2e:	41 5c                	pop    %r12
    3d30:	41 5d                	pop    %r13
    3d32:	c3                   	retq   

0000000000003d33 <blobmsg_printf>:

void
blobmsg_printf(struct blob_buf *buf, const char *name, const char *format, ...)
{
    3d33:	48 81 ec d8 00 00 00 	sub    $0xd8,%rsp
    3d3a:	84 c0                	test   %al,%al
    3d3c:	48 89 4c 24 38       	mov    %rcx,0x38(%rsp)
    3d41:	4c 89 44 24 40       	mov    %r8,0x40(%rsp)
    3d46:	4c 89 4c 24 48       	mov    %r9,0x48(%rsp)
    3d4b:	74 37                	je     3d84 <blobmsg_printf+0x51>
    3d4d:	0f 29 44 24 50       	movaps %xmm0,0x50(%rsp)
    3d52:	0f 29 4c 24 60       	movaps %xmm1,0x60(%rsp)
    3d57:	0f 29 54 24 70       	movaps %xmm2,0x70(%rsp)
    3d5c:	0f 29 9c 24 80 00 00 	movaps %xmm3,0x80(%rsp)
    3d63:	00 
    3d64:	0f 29 a4 24 90 00 00 	movaps %xmm4,0x90(%rsp)
    3d6b:	00 
    3d6c:	0f 29 ac 24 a0 00 00 	movaps %xmm5,0xa0(%rsp)
    3d73:	00 
    3d74:	0f 29 b4 24 b0 00 00 	movaps %xmm6,0xb0(%rsp)
    3d7b:	00 
    3d7c:	0f 29 bc 24 c0 00 00 	movaps %xmm7,0xc0(%rsp)
    3d83:	00 
    3d84:	64 48 8b 04 25 28 00 	mov    %fs:0x28,%rax
    3d8b:	00 00 
    3d8d:	48 89 44 24 18       	mov    %rax,0x18(%rsp)
    3d92:	31 c0                	xor    %eax,%eax
	va_list ap;

	va_start(ap, format);
    3d94:	48 8d 84 24 e0 00 00 	lea    0xe0(%rsp),%rax
    3d9b:	00 
	blobmsg_vprintf(buf, name, format, ap);
    3d9c:	48 89 e1             	mov    %rsp,%rcx
void
blobmsg_printf(struct blob_buf *buf, const char *name, const char *format, ...)
{
	va_list ap;

	va_start(ap, format);
    3d9f:	48 89 44 24 08       	mov    %rax,0x8(%rsp)
    3da4:	48 8d 44 24 20       	lea    0x20(%rsp),%rax
    3da9:	c7 04 24 18 00 00 00 	movl   $0x18,(%rsp)
    3db0:	c7 44 24 04 30 00 00 	movl   $0x30,0x4(%rsp)
    3db7:	00 
    3db8:	48 89 44 24 10       	mov    %rax,0x10(%rsp)
	blobmsg_vprintf(buf, name, format, ap);
    3dbd:	e8 ee e8 ff ff       	callq  26b0 <blobmsg_vprintf@plt>
	va_end(ap);
}
    3dc2:	48 8b 44 24 18       	mov    0x18(%rsp),%rax
    3dc7:	64 48 33 04 25 28 00 	xor    %fs:0x28,%rax
    3dce:	00 00 
    3dd0:	74 05                	je     3dd7 <blobmsg_printf+0xa4>
    3dd2:	e8 a9 e6 ff ff       	callq  2480 <__stack_chk_fail@plt>
    3dd7:	48 81 c4 d8 00 00 00 	add    $0xd8,%rsp
    3dde:	c3                   	retq   

0000000000003ddf <blobmsg_add_field>:
}

int
blobmsg_add_field(struct blob_buf *buf, int type, const char *name,
                  const void *data, int len)
{
    3ddf:	55                   	push   %rbp
    3de0:	53                   	push   %rbx
    3de1:	44 89 c3             	mov    %r8d,%ebx
    3de4:	48 89 cd             	mov    %rcx,%rbp
	struct blob_attr *attr;
	void *data_dest;

	attr = blobmsg_new(buf, type, name, len, &data_dest);
    3de7:	89 d9                	mov    %ebx,%ecx
}

int
blobmsg_add_field(struct blob_buf *buf, int type, const char *name,
                  const void *data, int len)
{
    3de9:	48 83 ec 18          	sub    $0x18,%rsp
	struct blob_attr *attr;
	void *data_dest;

	attr = blobmsg_new(buf, type, name, len, &data_dest);
    3ded:	49 89 e0             	mov    %rsp,%r8
}

int
blobmsg_add_field(struct blob_buf *buf, int type, const char *name,
                  const void *data, int len)
{
    3df0:	64 48 8b 04 25 28 00 	mov    %fs:0x28,%rax
    3df7:	00 00 
    3df9:	48 89 44 24 08       	mov    %rax,0x8(%rsp)
    3dfe:	31 c0                	xor    %eax,%eax
	struct blob_attr *attr;
	void *data_dest;

	attr = blobmsg_new(buf, type, name, len, &data_dest);
    3e00:	e8 7e f8 ff ff       	callq  3683 <blobmsg_new>
	if (!attr)
		return -1;
    3e05:	83 ca ff             	or     $0xffffffff,%edx
{
	struct blob_attr *attr;
	void *data_dest;

	attr = blobmsg_new(buf, type, name, len, &data_dest);
	if (!attr)
    3e08:	48 85 c0             	test   %rax,%rax
    3e0b:	74 11                	je     3e1e <blobmsg_add_field+0x3f>
		return -1;

	if (len > 0)
		memcpy(data_dest, data, len);

	return 0;
    3e0d:	31 d2                	xor    %edx,%edx

	attr = blobmsg_new(buf, type, name, len, &data_dest);
	if (!attr)
		return -1;

	if (len > 0)
    3e0f:	85 db                	test   %ebx,%ebx
    3e11:	7e 0b                	jle    3e1e <blobmsg_add_field+0x3f>

__fortify_function void *
__NTH (memcpy (void *__restrict __dest, const void *__restrict __src,
	       size_t __len))
{
  return __builtin___memcpy_chk (__dest, __src, __len, __bos0 (__dest));
    3e13:	89 d9                	mov    %ebx,%ecx
    3e15:	48 8b 3c 24          	mov    (%rsp),%rdi
    3e19:	48 89 ee             	mov    %rbp,%rsi
    3e1c:	f3 a4                	rep movsb %ds:(%rsi),%es:(%rdi)
		memcpy(data_dest, data, len);

	return 0;
}
    3e1e:	48 8b 4c 24 08       	mov    0x8(%rsp),%rcx
    3e23:	64 48 33 0c 25 28 00 	xor    %fs:0x28,%rcx
    3e2a:	00 00 
    3e2c:	89 d0                	mov    %edx,%eax
    3e2e:	74 05                	je     3e35 <blobmsg_add_field+0x56>
    3e30:	e8 4b e6 ff ff       	callq  2480 <__stack_chk_fail@plt>
    3e35:	48 83 c4 18          	add    $0x18,%rsp
    3e39:	5b                   	pop    %rbx
    3e3a:	5d                   	pop    %rbp
    3e3b:	c3                   	retq   

0000000000003e3c <uloop_handle_sigint>:

}

static void uloop_handle_sigint(int signo)
{
	uloop_cancelled = true;
    3e3c:	48 8b 05 85 41 20 00 	mov    0x204185(%rip),%rax        # 207fc8 <_DYNAMIC+0x1e8>
    3e43:	c6 00 01             	movb   $0x1,(%rax)
    3e46:	c3                   	retq   

0000000000003e47 <uloop_sigchld>:
}

static void uloop_sigchld(int signo)
{
	do_sigchld = true;
    3e47:	c6 05 f2 46 20 00 01 	movb   $0x1,0x2046f2(%rip)        # 208540 <do_sigchld>
    3e4e:	c3                   	retq   

0000000000003e4f <uloop_gettime>:

	return 0;
}

static void uloop_gettime(struct timeval *tv)
{
    3e4f:	53                   	push   %rbx
    3e50:	48 89 fb             	mov    %rdi,%rbx
	struct timespec ts;

	clock_gettime(CLOCK_MONOTONIC, &ts);
    3e53:	bf 01 00 00 00       	mov    $0x1,%edi

	return 0;
}

static void uloop_gettime(struct timeval *tv)
{
    3e58:	48 83 ec 20          	sub    $0x20,%rsp
	struct timespec ts;

	clock_gettime(CLOCK_MONOTONIC, &ts);
    3e5c:	48 8d 74 24 08       	lea    0x8(%rsp),%rsi

	return 0;
}

static void uloop_gettime(struct timeval *tv)
{
    3e61:	64 48 8b 04 25 28 00 	mov    %fs:0x28,%rax
    3e68:	00 00 
    3e6a:	48 89 44 24 18       	mov    %rax,0x18(%rsp)
    3e6f:	31 c0                	xor    %eax,%eax
	struct timespec ts;

	clock_gettime(CLOCK_MONOTONIC, &ts);
    3e71:	e8 8a e5 ff ff       	callq  2400 <clock_gettime@plt>
	tv->tv_sec = ts.tv_sec;
    3e76:	48 8b 44 24 08       	mov    0x8(%rsp),%rax
	tv->tv_usec = ts.tv_nsec / 1000;
    3e7b:	b9 e8 03 00 00       	mov    $0x3e8,%ecx
static void uloop_gettime(struct timeval *tv)
{
	struct timespec ts;

	clock_gettime(CLOCK_MONOTONIC, &ts);
	tv->tv_sec = ts.tv_sec;
    3e80:	48 89 03             	mov    %rax,(%rbx)
	tv->tv_usec = ts.tv_nsec / 1000;
    3e83:	48 8b 44 24 10       	mov    0x10(%rsp),%rax
    3e88:	48 99                	cqto   
    3e8a:	48 f7 f9             	idiv   %rcx
    3e8d:	48 89 43 08          	mov    %rax,0x8(%rbx)
}
    3e91:	48 8b 44 24 18       	mov    0x18(%rsp),%rax
    3e96:	64 48 33 04 25 28 00 	xor    %fs:0x28,%rax
    3e9d:	00 00 
    3e9f:	74 05                	je     3ea6 <uloop_gettime+0x57>
    3ea1:	e8 da e5 ff ff       	callq  2480 <__stack_chk_fail@plt>
    3ea6:	48 83 c4 20          	add    $0x20,%rsp
    3eaa:	5b                   	pop    %rbx
    3eab:	c3                   	retq   

0000000000003eac <uloop_setup_signals>:
{
	do_sigchld = true;
}

static void uloop_setup_signals(bool add)
{
    3eac:	55                   	push   %rbp
    3ead:	53                   	push   %rbx
    3eae:	89 fd                	mov    %edi,%ebp
    {
      __warn_memset_zero_len ();
      return __dest;
    }
#endif
  return __builtin___memset_chk (__dest, __ch, __len, __bos0 (__dest));
    3eb0:	b9 26 00 00 00       	mov    $0x26,%ecx
    3eb5:	48 81 ec a8 00 00 00 	sub    $0xa8,%rsp
    3ebc:	64 48 8b 04 25 28 00 	mov    %fs:0x28,%rax
    3ec3:	00 00 
    3ec5:	48 89 84 24 98 00 00 	mov    %rax,0x98(%rsp)
    3ecc:	00 
    3ecd:	31 c0                	xor    %eax,%eax
    3ecf:	48 89 e7             	mov    %rsp,%rdi
	static struct sigaction old_sigint, old_sigchld;
	struct sigaction s;

	memset(&s, 0, sizeof(struct sigaction));

	if (add) {
    3ed2:	40 84 ed             	test   %bpl,%bpl
    3ed5:	48 89 e3             	mov    %rsp,%rbx
    3ed8:	f3 ab                	rep stos %eax,%es:(%rdi)
    3eda:	74 0d                	je     3ee9 <uloop_setup_signals+0x3d>
		s.sa_handler = uloop_handle_sigint;
    3edc:	48 8d 05 59 ff ff ff 	lea    -0xa7(%rip),%rax        # 3e3c <uloop_handle_sigint>
    3ee3:	48 89 04 24          	mov    %rax,(%rsp)
    3ee7:	eb 11                	jmp    3efa <uloop_setup_signals+0x4e>
		s.sa_flags = 0;
	} else {
		s = old_sigint;
    3ee9:	48 8d 35 90 44 20 00 	lea    0x204490(%rip),%rsi        # 208380 <old_sigint.5039>
    3ef0:	b9 26 00 00 00       	mov    $0x26,%ecx
    3ef5:	48 89 e7             	mov    %rsp,%rdi
    3ef8:	f3 a5                	rep movsl %ds:(%rsi),%es:(%rdi)
	}

	sigaction(SIGINT, &s, &old_sigint);
    3efa:	48 8d 15 7f 44 20 00 	lea    0x20447f(%rip),%rdx        # 208380 <old_sigint.5039>
    3f01:	48 89 de             	mov    %rbx,%rsi
    3f04:	bf 02 00 00 00       	mov    $0x2,%edi
    3f09:	e8 92 e4 ff ff       	callq  23a0 <sigaction@plt>

	if (!uloop_handle_sigchld)
    3f0e:	48 8b 05 a3 40 20 00 	mov    0x2040a3(%rip),%rax        # 207fb8 <_DYNAMIC+0x1d8>
    3f15:	80 38 00             	cmpb   $0x0,(%rax)
    3f18:	74 37                	je     3f51 <uloop_setup_signals+0xa5>
		return;

	if (add)
    3f1a:	40 84 ed             	test   %bpl,%bpl
    3f1d:	74 0d                	je     3f2c <uloop_setup_signals+0x80>
		s.sa_handler = uloop_sigchld;
    3f1f:	48 8d 05 21 ff ff ff 	lea    -0xdf(%rip),%rax        # 3e47 <uloop_sigchld>
    3f26:	48 89 04 24          	mov    %rax,(%rsp)
    3f2a:	eb 11                	jmp    3f3d <uloop_setup_signals+0x91>
	else
		s = old_sigchld;
    3f2c:	48 8d 35 ad 43 20 00 	lea    0x2043ad(%rip),%rsi        # 2082e0 <old_sigchld.5040>
    3f33:	b9 26 00 00 00       	mov    $0x26,%ecx
    3f38:	48 89 df             	mov    %rbx,%rdi
    3f3b:	f3 a5                	rep movsl %ds:(%rsi),%es:(%rdi)

	sigaction(SIGCHLD, &s, &old_sigchld);
    3f3d:	48 8d 15 9c 43 20 00 	lea    0x20439c(%rip),%rdx        # 2082e0 <old_sigchld.5040>
    3f44:	48 89 de             	mov    %rbx,%rsi
    3f47:	bf 11 00 00 00       	mov    $0x11,%edi
    3f4c:	e8 4f e4 ff ff       	callq  23a0 <sigaction@plt>
}
    3f51:	48 8b 84 24 98 00 00 	mov    0x98(%rsp),%rax
    3f58:	00 
    3f59:	64 48 33 04 25 28 00 	xor    %fs:0x28,%rax
    3f60:	00 00 
    3f62:	74 05                	je     3f69 <uloop_setup_signals+0xbd>
    3f64:	e8 17 e5 ff ff       	callq  2480 <__stack_chk_fail@plt>
    3f69:	48 81 c4 a8 00 00 00 	add    $0xa8,%rsp
    3f70:	5b                   	pop    %rbx
    3f71:	5d                   	pop    %rbp
    3f72:	c3                   	retq   

0000000000003f73 <uloop_init>:
#ifndef EPOLLRDHUP
#define EPOLLRDHUP 0x2000
#endif

int uloop_init(void)
{
    3f73:	53                   	push   %rbx
	if (poll_fd >= 0)
		return 0;
    3f74:	31 db                	xor    %ebx,%ebx
#define EPOLLRDHUP 0x2000
#endif

int uloop_init(void)
{
	if (poll_fd >= 0)
    3f76:	83 3d ff 42 20 00 00 	cmpl   $0x0,0x2042ff(%rip)        # 20827c <poll_fd>
    3f7d:	79 3e                	jns    3fbd <uloop_init+0x4a>
		return 0;

	poll_fd = epoll_create(32);
    3f7f:	bf 20 00 00 00       	mov    $0x20,%edi
    3f84:	e8 97 e7 ff ff       	callq  2720 <epoll_create@plt>
	if (poll_fd < 0)
    3f89:	85 c0                	test   %eax,%eax
int uloop_init(void)
{
	if (poll_fd >= 0)
		return 0;

	poll_fd = epoll_create(32);
    3f8b:	89 05 eb 42 20 00    	mov    %eax,0x2042eb(%rip)        # 20827c <poll_fd>
	if (poll_fd < 0)
    3f91:	78 27                	js     3fba <uloop_init+0x47>
		return -1;

	fcntl(poll_fd, F_SETFD, fcntl(poll_fd, F_GETFD) | FD_CLOEXEC);
    3f93:	89 c7                	mov    %eax,%edi
    3f95:	be 01 00 00 00       	mov    $0x1,%esi
    3f9a:	31 c0                	xor    %eax,%eax
    3f9c:	e8 4f e4 ff ff       	callq  23f0 <fcntl@plt>
    3fa1:	8b 3d d5 42 20 00    	mov    0x2042d5(%rip),%edi        # 20827c <poll_fd>
    3fa7:	83 c8 01             	or     $0x1,%eax
    3faa:	be 02 00 00 00       	mov    $0x2,%esi
    3faf:	89 c2                	mov    %eax,%edx
    3fb1:	31 c0                	xor    %eax,%eax
    3fb3:	e8 38 e4 ff ff       	callq  23f0 <fcntl@plt>
	return 0;
    3fb8:	eb 03                	jmp    3fbd <uloop_init+0x4a>
	if (poll_fd >= 0)
		return 0;

	poll_fd = epoll_create(32);
	if (poll_fd < 0)
		return -1;
    3fba:	83 cb ff             	or     $0xffffffff,%ebx

	fcntl(poll_fd, F_SETFD, fcntl(poll_fd, F_GETFD) | FD_CLOEXEC);
	return 0;
}
    3fbd:	89 d8                	mov    %ebx,%eax
    3fbf:	5b                   	pop    %rbx
    3fc0:	c3                   	retq   

0000000000003fc1 <uloop_fd_delete>:

int uloop_fd_delete(struct uloop_fd *fd)
{
	int i;

	for (i = 0; i < cur_nfds; i++) {
    3fc1:	8b 0d d1 44 20 00    	mov    0x2044d1(%rip),%ecx        # 208498 <cur_nfds>
		if (cur_fds[cur_fd + i].fd != fd)
    3fc7:	8b 35 cf 44 20 00    	mov    0x2044cf(%rip),%esi        # 20849c <cur_fd>
    3fcd:	4c 8d 05 cc 44 20 00 	lea    0x2044cc(%rip),%r8        # 2084a0 <cur_fds>

int uloop_fd_delete(struct uloop_fd *fd)
{
	int i;

	for (i = 0; i < cur_nfds; i++) {
    3fd4:	31 d2                	xor    %edx,%edx
    3fd6:	39 ca                	cmp    %ecx,%edx
    3fd8:	7d 1c                	jge    3ff6 <uloop_fd_delete+0x35>
    3fda:	8d 04 16             	lea    (%rsi,%rdx,1),%eax
		if (cur_fds[cur_fd + i].fd != fd)
    3fdd:	48 98                	cltq   
    3fdf:	48 c1 e0 04          	shl    $0x4,%rax
    3fe3:	4c 01 c0             	add    %r8,%rax
    3fe6:	48 39 38             	cmp    %rdi,(%rax)
    3fe9:	75 07                	jne    3ff2 <uloop_fd_delete+0x31>
			continue;

		cur_fds[cur_fd + i].fd = NULL;
    3feb:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)

int uloop_fd_delete(struct uloop_fd *fd)
{
	int i;

	for (i = 0; i < cur_nfds; i++) {
    3ff2:	ff c2                	inc    %edx
    3ff4:	eb e0                	jmp    3fd6 <uloop_fd_delete+0x15>
			continue;

		cur_fds[cur_fd + i].fd = NULL;
	}

	if (!fd->registered)
    3ff6:	80 7f 0e 00          	cmpb   $0x0,0xe(%rdi)
    3ffa:	74 42                	je     403e <uloop_fd_delete+0x7d>

	/*
	 * Do not buffer events for level-triggered fds, they will keep firing.
	 * Caller needs to take care of recursion issues.
	 */
	if (!(fd->flags & ULOOP_EDGE_TRIGGER))
    3ffc:	f6 47 0f 04          	testb  $0x4,0xf(%rdi)
	}

	if (!fd->registered)
		return 0;

	fd->registered = false;
    4000:	c6 47 0e 00          	movb   $0x0,0xe(%rdi)
	 * Caller needs to take care of recursion issues.
	 */
	if (!(fd->flags & ULOOP_EDGE_TRIGGER))
		return false;

	for (cur = fd_stack; cur; cur = cur->next) {
    4004:	48 8b 05 3d 45 20 00 	mov    0x20453d(%rip),%rax        # 208548 <fd_stack>

	/*
	 * Do not buffer events for level-triggered fds, they will keep firing.
	 * Caller needs to take care of recursion issues.
	 */
	if (!(fd->flags & ULOOP_EDGE_TRIGGER))
    400b:	74 18                	je     4025 <uloop_fd_delete+0x64>
		return false;

	for (cur = fd_stack; cur; cur = cur->next) {
    400d:	48 85 c0             	test   %rax,%rax
    4010:	74 13                	je     4025 <uloop_fd_delete+0x64>
		if (cur->fd != fd)
    4012:	48 3b 78 08          	cmp    0x8(%rax),%rdi
    4016:	74 05                	je     401d <uloop_fd_delete+0x5c>
	 * Caller needs to take care of recursion issues.
	 */
	if (!(fd->flags & ULOOP_EDGE_TRIGGER))
		return false;

	for (cur = fd_stack; cur; cur = cur->next) {
    4018:	48 8b 00             	mov    (%rax),%rax
    401b:	eb f0                	jmp    400d <uloop_fd_delete+0x4c>
		if (cur->fd != fd)
			continue;

		if (events < 0)
			cur->fd = NULL;
    401d:	48 c7 40 08 00 00 00 	movq   $0x0,0x8(%rax)
    4024:	00 

static struct epoll_event events[ULOOP_MAX_EVENTS];

static int __uloop_fd_delete(struct uloop_fd *sock)
{
	sock->flags = 0;
    4025:	c6 47 0f 00          	movb   $0x0,0xf(%rdi)
	return epoll_ctl(poll_fd, EPOLL_CTL_DEL, sock->fd, 0);
    4029:	8b 57 08             	mov    0x8(%rdi),%edx
    402c:	31 c9                	xor    %ecx,%ecx
    402e:	8b 3d 48 42 20 00    	mov    0x204248(%rip),%edi        # 20827c <poll_fd>
    4034:	be 02 00 00 00       	mov    $0x2,%esi
    4039:	e9 12 e5 ff ff       	jmpq   2550 <epoll_ctl@plt>
		return 0;

	fd->registered = false;
	uloop_fd_stack_event(fd, -1);
	return __uloop_fd_delete(fd);
}
    403e:	31 c0                	xor    %eax,%eax
    4040:	c3                   	retq   

0000000000004041 <uloop_fd_add>:
		return;
	}
}

int uloop_fd_add(struct uloop_fd *sock, unsigned int flags)
{
    4041:	55                   	push   %rbp
    4042:	53                   	push   %rbx
    4043:	48 89 fb             	mov    %rdi,%rbx
    4046:	48 83 ec 28          	sub    $0x28,%rsp
    404a:	64 48 8b 04 25 28 00 	mov    %fs:0x28,%rax
    4051:	00 00 
    4053:	48 89 44 24 18       	mov    %rax,0x18(%rsp)
    4058:	31 c0                	xor    %eax,%eax
	unsigned int fl;
	int ret;

	if (!(flags & (ULOOP_READ | ULOOP_WRITE)))
    405a:	40 f6 c6 03          	test   $0x3,%sil
    405e:	75 0a                	jne    406a <uloop_fd_add+0x29>
		return uloop_fd_delete(sock);
    4060:	e8 db e6 ff ff       	callq  2740 <uloop_fd_delete@plt>
    4065:	e9 9d 00 00 00       	jmpq   4107 <uloop_fd_add+0xc6>

	if (!sock->registered && !(flags & ULOOP_BLOCKING)) {
    406a:	80 7f 0e 00          	cmpb   $0x0,0xe(%rdi)
    406e:	89 f5                	mov    %esi,%ebp
    4070:	75 2b                	jne    409d <uloop_fd_add+0x5c>
    4072:	40 f6 c6 08          	test   $0x8,%sil
    4076:	75 25                	jne    409d <uloop_fd_add+0x5c>
		fl = fcntl(sock->fd, F_GETFL, 0);
    4078:	8b 7f 08             	mov    0x8(%rdi),%edi
    407b:	31 d2                	xor    %edx,%edx
    407d:	be 03 00 00 00       	mov    $0x3,%esi
    4082:	31 c0                	xor    %eax,%eax
    4084:	e8 67 e3 ff ff       	callq  23f0 <fcntl@plt>
		fl |= O_NONBLOCK;
		fcntl(sock->fd, F_SETFL, fl);
    4089:	8b 7b 08             	mov    0x8(%rbx),%edi
    408c:	80 cc 08             	or     $0x8,%ah
    408f:	be 04 00 00 00       	mov    $0x4,%esi
    4094:	89 c2                	mov    %eax,%edx
    4096:	31 c0                	xor    %eax,%eax
    4098:	e8 53 e3 ff ff       	callq  23f0 <fcntl@plt>
}

static int register_poll(struct uloop_fd *fd, unsigned int flags)
{
	struct epoll_event ev;
	int op = fd->registered ? EPOLL_CTL_MOD : EPOLL_CTL_ADD;
    409d:	80 7b 0e 01          	cmpb   $0x1,0xe(%rbx)
    40a1:	4c 8d 44 24 0c       	lea    0xc(%rsp),%r8
    40a6:	b9 03 00 00 00       	mov    $0x3,%ecx
    40ab:	4c 89 c7             	mov    %r8,%rdi
    40ae:	19 f6                	sbb    %esi,%esi
    40b0:	31 c0                	xor    %eax,%eax
    40b2:	83 e6 fe             	and    $0xfffffffe,%esi
    40b5:	83 c6 03             	add    $0x3,%esi

	memset(&ev, 0, sizeof(struct epoll_event));

	if (flags & ULOOP_READ)
    40b8:	40 f6 c5 01          	test   $0x1,%bpl
    40bc:	f3 ab                	rep stos %eax,%es:(%rdi)
    40be:	74 08                	je     40c8 <uloop_fd_add+0x87>
		ev.events |= EPOLLIN | EPOLLRDHUP;
    40c0:	c7 44 24 0c 01 20 00 	movl   $0x2001,0xc(%rsp)
    40c7:	00 

	if (flags & ULOOP_WRITE)
    40c8:	40 f6 c5 02          	test   $0x2,%bpl
    40cc:	74 05                	je     40d3 <uloop_fd_add+0x92>
		ev.events |= EPOLLOUT;
    40ce:	83 4c 24 0c 04       	orl    $0x4,0xc(%rsp)

	if (flags & ULOOP_EDGE_TRIGGER)
    40d3:	40 f6 c5 04          	test   $0x4,%bpl
    40d7:	74 08                	je     40e1 <uloop_fd_add+0xa0>
		ev.events |= EPOLLET;
    40d9:	81 4c 24 0c 00 00 00 	orl    $0x80000000,0xc(%rsp)
    40e0:	80 

	ev.data.fd = fd->fd;
    40e1:	8b 53 08             	mov    0x8(%rbx),%edx
	ev.data.ptr = fd;
	fd->flags = flags;

	return epoll_ctl(poll_fd, op, fd->fd, &ev);
    40e4:	4c 89 c1             	mov    %r8,%rcx
    40e7:	8b 3d 8f 41 20 00    	mov    0x20418f(%rip),%edi        # 20827c <poll_fd>
	if (flags & ULOOP_EDGE_TRIGGER)
		ev.events |= EPOLLET;

	ev.data.fd = fd->fd;
	ev.data.ptr = fd;
	fd->flags = flags;
    40ed:	40 88 6b 0f          	mov    %bpl,0xf(%rbx)

	if (flags & ULOOP_EDGE_TRIGGER)
		ev.events |= EPOLLET;

	ev.data.fd = fd->fd;
	ev.data.ptr = fd;
    40f1:	48 89 5c 24 10       	mov    %rbx,0x10(%rsp)
	fd->flags = flags;

	return epoll_ctl(poll_fd, op, fd->fd, &ev);
    40f6:	e8 55 e4 ff ff       	callq  2550 <epoll_ctl@plt>
		fl |= O_NONBLOCK;
		fcntl(sock->fd, F_SETFL, fl);
	}

	ret = register_poll(sock, flags);
	if (ret < 0)
    40fb:	85 c0                	test   %eax,%eax
    40fd:	78 08                	js     4107 <uloop_fd_add+0xc6>
		goto out;

	sock->registered = true;
    40ff:	c6 43 0e 01          	movb   $0x1,0xe(%rbx)
	sock->eof = false;
    4103:	c6 43 0c 00          	movb   $0x0,0xc(%rbx)

out:
	return ret;
}
    4107:	48 8b 4c 24 18       	mov    0x18(%rsp),%rcx
    410c:	64 48 33 0c 25 28 00 	xor    %fs:0x28,%rcx
    4113:	00 00 
    4115:	74 05                	je     411c <uloop_fd_add+0xdb>
    4117:	e8 64 e3 ff ff       	callq  2480 <__stack_chk_fail@plt>
    411c:	48 83 c4 28          	add    $0x28,%rsp
    4120:	5b                   	pop    %rbx
    4121:	5d                   	pop    %rbp
    4122:	c3                   	retq   

0000000000004123 <uloop_timeout_add>:
{
	struct uloop_timeout *tmp;
	struct list_head *h = &timeouts;

	if (timeout->pending)
		return -1;
    4123:	83 c8 ff             	or     $0xffffffff,%eax
int uloop_timeout_add(struct uloop_timeout *timeout)
{
	struct uloop_timeout *tmp;
	struct list_head *h = &timeouts;

	if (timeout->pending)
    4126:	80 7f 10 00          	cmpb   $0x0,0x10(%rdi)
    412a:	75 57                	jne    4183 <uloop_timeout_add+0x60>
		return -1;

	list_for_each_entry(tmp, &timeouts, list) {
    412c:	48 8b 0d 5d 41 20 00 	mov    0x20415d(%rip),%rcx        # 208290 <timeouts>
    4133:	4c 8d 0d 56 41 20 00 	lea    0x204156(%rip),%r9        # 208290 <timeouts>
		if (tv_diff(&tmp->time, &timeout->time) > 0) {
    413a:	41 b8 e8 03 00 00    	mov    $0x3e8,%r8d
	struct list_head *h = &timeouts;

	if (timeout->pending)
		return -1;

	list_for_each_entry(tmp, &timeouts, list) {
    4140:	4c 39 c9             	cmp    %r9,%rcx
    4143:	74 26                	je     416b <uloop_timeout_add+0x48>
		if (tv_diff(&tmp->time, &timeout->time) > 0) {
    4145:	48 8b 41 20          	mov    0x20(%rcx),%rax
    4149:	48 2b 47 20          	sub    0x20(%rdi),%rax
    414d:	69 f0 e8 03 00 00    	imul   $0x3e8,%eax,%esi
    4153:	48 8b 41 28          	mov    0x28(%rcx),%rax
    4157:	48 2b 47 28          	sub    0x28(%rdi),%rax
    415b:	48 99                	cqto   
    415d:	49 f7 f8             	idiv   %r8
    4160:	01 f0                	add    %esi,%eax
    4162:	85 c0                	test   %eax,%eax
    4164:	7f 05                	jg     416b <uloop_timeout_add+0x48>
	struct list_head *h = &timeouts;

	if (timeout->pending)
		return -1;

	list_for_each_entry(tmp, &timeouts, list) {
    4166:	48 8b 09             	mov    (%rcx),%rcx
    4169:	eb d5                	jmp    4140 <uloop_timeout_add+0x1d>
}

static inline void
list_add_tail(struct list_head *_new, struct list_head *head)
{
	_list_add(_new, head->prev, head);
    416b:	48 8b 41 08          	mov    0x8(%rcx),%rax
static inline void
_list_add(struct list_head *_new, struct list_head *prev,
    struct list_head *next)
{

	next->prev = _new;
    416f:	48 89 79 08          	mov    %rdi,0x8(%rcx)
	_new->next = next;
    4173:	48 89 0f             	mov    %rcx,(%rdi)
	_new->prev = prev;
    4176:	48 89 47 08          	mov    %rax,0x8(%rdi)
	prev->next = _new;
    417a:	48 89 38             	mov    %rdi,(%rax)
	}

	list_add_tail(&timeout->list, h);
	timeout->pending = true;

	return 0;
    417d:	31 c0                	xor    %eax,%eax
			break;
		}
	}

	list_add_tail(&timeout->list, h);
	timeout->pending = true;
    417f:	c6 47 10 01          	movb   $0x1,0x10(%rdi)

	return 0;
}
    4183:	c3                   	retq   

0000000000004184 <uloop_timeout_cancel>:
}

int uloop_timeout_cancel(struct uloop_timeout *timeout)
{
	if (!timeout->pending)
		return -1;
    4184:	83 c8 ff             	or     $0xffffffff,%eax
	return uloop_timeout_add(timeout);
}

int uloop_timeout_cancel(struct uloop_timeout *timeout)
{
	if (!timeout->pending)
    4187:	80 7f 10 00          	cmpb   $0x0,0x10(%rdi)
    418b:	74 27                	je     41b4 <uloop_timeout_cancel+0x30>
}

static inline void
_list_del(struct list_head *entry)
{
	entry->next->prev = entry->prev;
    418d:	48 8b 07             	mov    (%rdi),%rax
    4190:	48 8b 57 08          	mov    0x8(%rdi),%rdx
    4194:	48 89 50 08          	mov    %rdx,0x8(%rax)
	entry->prev->next = entry->next;
    4198:	48 8b 57 08          	mov    0x8(%rdi),%rdx
    419c:	48 89 02             	mov    %rax,(%rdx)

static inline void
list_del(struct list_head *entry)
{
	_list_del(entry);
	entry->next = entry->prev = NULL;
    419f:	48 c7 47 08 00 00 00 	movq   $0x0,0x8(%rdi)
    41a6:	00 
		return -1;

	list_del(&timeout->list);
	timeout->pending = false;

	return 0;
    41a7:	31 c0                	xor    %eax,%eax
    41a9:	48 c7 07 00 00 00 00 	movq   $0x0,(%rdi)
{
	if (!timeout->pending)
		return -1;

	list_del(&timeout->list);
	timeout->pending = false;
    41b0:	c6 47 10 00          	movb   $0x0,0x10(%rdi)

	return 0;
}
    41b4:	c3                   	retq   

00000000000041b5 <uloop_timeout_set>:
	tv->tv_sec = ts.tv_sec;
	tv->tv_usec = ts.tv_nsec / 1000;
}

int uloop_timeout_set(struct uloop_timeout *timeout, int msecs)
{
    41b5:	55                   	push   %rbp
    41b6:	53                   	push   %rbx
    41b7:	48 89 fd             	mov    %rdi,%rbp
    41ba:	52                   	push   %rdx
	struct timeval *time = &timeout->time;

	if (timeout->pending)
    41bb:	80 7f 10 00          	cmpb   $0x0,0x10(%rdi)
	tv->tv_sec = ts.tv_sec;
	tv->tv_usec = ts.tv_nsec / 1000;
}

int uloop_timeout_set(struct uloop_timeout *timeout, int msecs)
{
    41bf:	89 f3                	mov    %esi,%ebx
	struct timeval *time = &timeout->time;

	if (timeout->pending)
    41c1:	74 05                	je     41c8 <uloop_timeout_set+0x13>
		uloop_timeout_cancel(timeout);
    41c3:	e8 98 e5 ff ff       	callq  2760 <uloop_timeout_cancel@plt>

	uloop_gettime(&timeout->time);
    41c8:	48 8d 7d 20          	lea    0x20(%rbp),%rdi
    41cc:	e8 7e fc ff ff       	callq  3e4f <uloop_gettime>

	time->tv_sec += msecs / 1000;
    41d1:	89 d8                	mov    %ebx,%eax
    41d3:	b9 e8 03 00 00       	mov    $0x3e8,%ecx
    41d8:	99                   	cltd   
    41d9:	f7 f9                	idiv   %ecx
    41db:	48 63 d8             	movslq %eax,%rbx
    41de:	48 03 5d 20          	add    0x20(%rbp),%rbx
	time->tv_usec += (msecs % 1000) * 1000;
    41e2:	69 c2 e8 03 00 00    	imul   $0x3e8,%edx,%eax
    41e8:	48 98                	cltq   
    41ea:	48 03 45 28          	add    0x28(%rbp),%rax
	if (timeout->pending)
		uloop_timeout_cancel(timeout);

	uloop_gettime(&timeout->time);

	time->tv_sec += msecs / 1000;
    41ee:	48 89 5d 20          	mov    %rbx,0x20(%rbp)
	time->tv_usec += (msecs % 1000) * 1000;

	if (time->tv_usec > 1000000) {
    41f2:	48 3d 40 42 0f 00    	cmp    $0xf4240,%rax
		uloop_timeout_cancel(timeout);

	uloop_gettime(&timeout->time);

	time->tv_sec += msecs / 1000;
	time->tv_usec += (msecs % 1000) * 1000;
    41f8:	48 89 45 28          	mov    %rax,0x28(%rbp)

	if (time->tv_usec > 1000000) {
    41fc:	7e 15                	jle    4213 <uloop_timeout_set+0x5e>
		time->tv_sec++;
		time->tv_usec %= 1000000;
    41fe:	b9 40 42 0f 00       	mov    $0xf4240,%ecx
    4203:	48 99                	cqto   

	time->tv_sec += msecs / 1000;
	time->tv_usec += (msecs % 1000) * 1000;

	if (time->tv_usec > 1000000) {
		time->tv_sec++;
    4205:	48 ff c3             	inc    %rbx
		time->tv_usec %= 1000000;
    4208:	48 f7 f9             	idiv   %rcx

	time->tv_sec += msecs / 1000;
	time->tv_usec += (msecs % 1000) * 1000;

	if (time->tv_usec > 1000000) {
		time->tv_sec++;
    420b:	48 89 5d 20          	mov    %rbx,0x20(%rbp)
		time->tv_usec %= 1000000;
    420f:	48 89 55 28          	mov    %rdx,0x28(%rbp)
	}

	return uloop_timeout_add(timeout);
}
    4213:	58                   	pop    %rax
	if (time->tv_usec > 1000000) {
		time->tv_sec++;
		time->tv_usec %= 1000000;
	}

	return uloop_timeout_add(timeout);
    4214:	48 89 ef             	mov    %rbp,%rdi
}
    4217:	5b                   	pop    %rbx
    4218:	5d                   	pop    %rbp
	if (time->tv_usec > 1000000) {
		time->tv_sec++;
		time->tv_usec %= 1000000;
	}

	return uloop_timeout_add(timeout);
    4219:	e9 92 e2 ff ff       	jmpq   24b0 <uloop_timeout_add@plt>

000000000000421e <uloop_timeout_remaining>:

	return 0;
}

int uloop_timeout_remaining(struct uloop_timeout *timeout)
{
    421e:	53                   	push   %rbx
    421f:	48 83 ec 20          	sub    $0x20,%rsp
    4223:	64 48 8b 04 25 28 00 	mov    %fs:0x28,%rax
    422a:	00 00 
    422c:	48 89 44 24 18       	mov    %rax,0x18(%rsp)
    4231:	31 c0                	xor    %eax,%eax
    4233:	83 c8 ff             	or     $0xffffffff,%eax
	struct timeval now;

	if (!timeout->pending)
    4236:	80 7f 10 00          	cmpb   $0x0,0x10(%rdi)
    423a:	74 31                	je     426d <uloop_timeout_remaining+0x4f>
    423c:	48 89 fb             	mov    %rdi,%rbx
		return -1;

	uloop_gettime(&now);
    423f:	48 8d 7c 24 08       	lea    0x8(%rsp),%rdi
    4244:	e8 06 fc ff ff       	callq  3e4f <uloop_gettime>
}

static int tv_diff(struct timeval *t1, struct timeval *t2)
{
	return
		(t1->tv_sec - t2->tv_sec) * 1000 +
    4249:	48 8b 43 20          	mov    0x20(%rbx),%rax
    424d:	48 2b 44 24 08       	sub    0x8(%rsp),%rax
    4252:	be e8 03 00 00       	mov    $0x3e8,%esi
    4257:	69 c8 e8 03 00 00    	imul   $0x3e8,%eax,%ecx
    425d:	48 8b 43 28          	mov    0x28(%rbx),%rax
    4261:	48 2b 44 24 10       	sub    0x10(%rsp),%rax
    4266:	48 99                	cqto   
    4268:	48 f7 fe             	idiv   %rsi
    426b:	01 c8                	add    %ecx,%eax
		return -1;

	uloop_gettime(&now);

	return tv_diff(&timeout->time, &now);
}
    426d:	48 8b 54 24 18       	mov    0x18(%rsp),%rdx
    4272:	64 48 33 14 25 28 00 	xor    %fs:0x28,%rdx
    4279:	00 00 
    427b:	74 05                	je     4282 <uloop_timeout_remaining+0x64>
    427d:	e8 fe e1 ff ff       	callq  2480 <__stack_chk_fail@plt>
    4282:	48 83 c4 20          	add    $0x20,%rsp
    4286:	5b                   	pop    %rbx
    4287:	c3                   	retq   

0000000000004288 <uloop_process_add>:
{
	struct uloop_process *tmp;
	struct list_head *h = &processes;

	if (p->pending)
		return -1;
    4288:	83 c8 ff             	or     $0xffffffff,%eax
int uloop_process_add(struct uloop_process *p)
{
	struct uloop_process *tmp;
	struct list_head *h = &processes;

	if (p->pending)
    428b:	80 7f 10 00          	cmpb   $0x0,0x10(%rdi)
    428f:	75 38                	jne    42c9 <uloop_process_add+0x41>
		return -1;

	list_for_each_entry(tmp, &processes, list) {
    4291:	48 8b 05 e8 3f 20 00 	mov    0x203fe8(%rip),%rax        # 208280 <processes>
    4298:	48 8d 15 e1 3f 20 00 	lea    0x203fe1(%rip),%rdx        # 208280 <processes>
    429f:	48 39 d0             	cmp    %rdx,%rax
    42a2:	74 0d                	je     42b1 <uloop_process_add+0x29>
		if (tmp->pid > p->pid) {
    42a4:	8b 4f 20             	mov    0x20(%rdi),%ecx
    42a7:	39 48 20             	cmp    %ecx,0x20(%rax)
    42aa:	7f 05                	jg     42b1 <uloop_process_add+0x29>
	struct list_head *h = &processes;

	if (p->pending)
		return -1;

	list_for_each_entry(tmp, &processes, list) {
    42ac:	48 8b 00             	mov    (%rax),%rax
    42af:	eb ee                	jmp    429f <uloop_process_add+0x17>
}

static inline void
list_add_tail(struct list_head *_new, struct list_head *head)
{
	_list_add(_new, head->prev, head);
    42b1:	48 8b 50 08          	mov    0x8(%rax),%rdx
static inline void
_list_add(struct list_head *_new, struct list_head *prev,
    struct list_head *next)
{

	next->prev = _new;
    42b5:	48 89 78 08          	mov    %rdi,0x8(%rax)
	_new->next = next;
    42b9:	48 89 07             	mov    %rax,(%rdi)
	}

	list_add_tail(&p->list, h);
	p->pending = true;

	return 0;
    42bc:	31 c0                	xor    %eax,%eax
	_new->prev = prev;
    42be:	48 89 57 08          	mov    %rdx,0x8(%rdi)
	prev->next = _new;
    42c2:	48 89 3a             	mov    %rdi,(%rdx)
			break;
		}
	}

	list_add_tail(&p->list, h);
	p->pending = true;
    42c5:	c6 47 10 01          	movb   $0x1,0x10(%rdi)

	return 0;
}
    42c9:	c3                   	retq   

00000000000042ca <uloop_process_delete>:

int uloop_process_delete(struct uloop_process *p)
{
	if (!p->pending)
		return -1;
    42ca:	83 c8 ff             	or     $0xffffffff,%eax
	return 0;
}

int uloop_process_delete(struct uloop_process *p)
{
	if (!p->pending)
    42cd:	80 7f 10 00          	cmpb   $0x0,0x10(%rdi)
    42d1:	74 27                	je     42fa <uloop_process_delete+0x30>
}

static inline void
_list_del(struct list_head *entry)
{
	entry->next->prev = entry->prev;
    42d3:	48 8b 07             	mov    (%rdi),%rax
    42d6:	48 8b 57 08          	mov    0x8(%rdi),%rdx
    42da:	48 89 50 08          	mov    %rdx,0x8(%rax)
	entry->prev->next = entry->next;
    42de:	48 8b 57 08          	mov    0x8(%rdi),%rdx
    42e2:	48 89 02             	mov    %rax,(%rdx)

static inline void
list_del(struct list_head *entry)
{
	_list_del(entry);
	entry->next = entry->prev = NULL;
    42e5:	48 c7 47 08 00 00 00 	movq   $0x0,0x8(%rdi)
    42ec:	00 
		return -1;

	list_del(&p->list);
	p->pending = false;

	return 0;
    42ed:	31 c0                	xor    %eax,%eax
    42ef:	48 c7 07 00 00 00 00 	movq   $0x0,(%rdi)
{
	if (!p->pending)
		return -1;

	list_del(&p->list);
	p->pending = false;
    42f6:	c6 47 10 00          	movb   $0x0,0x10(%rdi)

	return 0;
}
    42fa:	c3                   	retq   

00000000000042fb <uloop_run>:
	list_for_each_entry_safe(p, tmp, &processes, list)
		uloop_process_delete(p);
}

void uloop_run(void)
{
    42fb:	41 57                	push   %r15
    42fd:	41 56                	push   %r14
    42ff:	41 55                	push   %r13
    4301:	41 54                	push   %r12
    4303:	55                   	push   %rbp
    4304:	53                   	push   %rbx
    4305:	48 83 ec 48          	sub    $0x48,%rsp
    4309:	64 48 8b 04 25 28 00 	mov    %fs:0x28,%rax
    4310:	00 00 
    4312:	48 89 44 24 38       	mov    %rax,0x38(%rsp)
    4317:	31 c0                	xor    %eax,%eax

	/*
	 * Handlers are only updated for the first call to uloop_run() (and restored
	 * when this call is done).
	 */
	if (!recursive_calls++)
    4319:	8b 05 f9 40 20 00    	mov    0x2040f9(%rip),%eax        # 208418 <recursive_calls.5089>
    431f:	8d 50 01             	lea    0x1(%rax),%edx
    4322:	85 c0                	test   %eax,%eax
    4324:	89 15 ee 40 20 00    	mov    %edx,0x2040ee(%rip)        # 208418 <recursive_calls.5089>
    432a:	75 0a                	jne    4336 <uloop_run+0x3b>
		uloop_setup_signals(true);
    432c:	bf 01 00 00 00       	mov    $0x1,%edi
    4331:	e8 76 fb ff ff       	callq  3eac <uloop_setup_signals>

	while(!uloop_cancelled)
	{
		uloop_gettime(&tv);
    4336:	4c 8d 64 24 10       	lea    0x10(%rsp),%r12
	int ret;

	do_sigchld = false;

	while (1) {
		pid = waitpid(-1, &ret, WNOHANG);
    433b:	48 8d 5c 24 20       	lea    0x20(%rsp),%rbx
	 * when this call is done).
	 */
	if (!recursive_calls++)
		uloop_setup_signals(true);

	while(!uloop_cancelled)
    4340:	48 8b 05 81 3c 20 00 	mov    0x203c81(%rip),%rax        # 207fc8 <_DYNAMIC+0x1e8>
    4347:	80 38 00             	cmpb   $0x0,(%rax)
    434a:	75 67                	jne    43b3 <uloop_run+0xb8>
	{
		uloop_gettime(&tv);
    434c:	4c 89 e7             	mov    %r12,%rdi
    434f:	e8 fb fa ff ff       	callq  3e4f <uloop_gettime>
}

static inline bool
list_empty(const struct list_head *head)
{
	return (head->next == head);
    4354:	4c 8b 35 35 3f 20 00 	mov    0x203f35(%rip),%r14        # 208290 <timeouts>

static void uloop_process_timeouts(struct timeval *tv)
{
	struct uloop_timeout *t;

	while (!list_empty(&timeouts)) {
    435b:	48 8d 05 2e 3f 20 00 	lea    0x203f2e(%rip),%rax        # 208290 <timeouts>
    4362:	49 39 c6             	cmp    %rax,%r14
    4365:	74 40                	je     43a7 <uloop_run+0xac>
		t = list_first_entry(&timeouts, struct uloop_timeout, list);

		if (tv_diff(&t->time, tv) > 0)
    4367:	49 8b 46 20          	mov    0x20(%r14),%rax
    436b:	48 2b 44 24 10       	sub    0x10(%rsp),%rax
    4370:	be e8 03 00 00       	mov    $0x3e8,%esi
    4375:	69 c8 e8 03 00 00    	imul   $0x3e8,%eax,%ecx
    437b:	49 8b 46 28          	mov    0x28(%r14),%rax
    437f:	48 2b 44 24 18       	sub    0x18(%rsp),%rax
    4384:	48 99                	cqto   
    4386:	48 f7 fe             	idiv   %rsi
    4389:	01 c8                	add    %ecx,%eax
    438b:	85 c0                	test   %eax,%eax
    438d:	7f 18                	jg     43a7 <uloop_run+0xac>
			break;

		uloop_timeout_cancel(t);
    438f:	4c 89 f7             	mov    %r14,%rdi
    4392:	e8 c9 e3 ff ff       	callq  2760 <uloop_timeout_cancel@plt>
		if (t->cb)
    4397:	49 8b 46 18          	mov    0x18(%r14),%rax
    439b:	48 85 c0             	test   %rax,%rax
    439e:	74 b4                	je     4354 <uloop_run+0x59>
			t->cb(t);
    43a0:	4c 89 f7             	mov    %r14,%rdi
    43a3:	ff d0                	callq  *%rax
    43a5:	eb ad                	jmp    4354 <uloop_run+0x59>

	while(!uloop_cancelled)
	{
		uloop_gettime(&tv);
		uloop_process_timeouts(&tv);
		if (uloop_cancelled)
    43a7:	48 8b 05 1a 3c 20 00 	mov    0x203c1a(%rip),%rax        # 207fc8 <_DYNAMIC+0x1e8>
    43ae:	80 38 00             	cmpb   $0x0,(%rax)
    43b1:	74 18                	je     43cb <uloop_run+0xd0>
			uloop_handle_processes();
		uloop_gettime(&tv);
		uloop_run_events(uloop_get_next_timeout(&tv));
	}

	if (!--recursive_calls)
    43b3:	ff 0d 5f 40 20 00    	decl   0x20405f(%rip)        # 208418 <recursive_calls.5089>
    43b9:	0f 85 47 02 00 00    	jne    4606 <uloop_run+0x30b>
		uloop_setup_signals(false);
    43bf:	31 ff                	xor    %edi,%edi
    43c1:	e8 e6 fa ff ff       	callq  3eac <uloop_setup_signals>
}
    43c6:	e9 3b 02 00 00       	jmpq   4606 <uloop_run+0x30b>
		uloop_gettime(&tv);
		uloop_process_timeouts(&tv);
		if (uloop_cancelled)
			break;

		if (do_sigchld)
    43cb:	80 3d 6e 41 20 00 00 	cmpb   $0x0,0x20416e(%rip)        # 208540 <do_sigchld>
    43d2:	74 57                	je     442b <uloop_run+0x130>
{
	struct uloop_process *p, *tmp;
	pid_t pid;
	int ret;

	do_sigchld = false;
    43d4:	c6 05 65 41 20 00 00 	movb   $0x0,0x204165(%rip)        # 208540 <do_sigchld>

	while (1) {
		pid = waitpid(-1, &ret, WNOHANG);
    43db:	83 cf ff             	or     $0xffffffff,%edi
    43de:	ba 01 00 00 00       	mov    $0x1,%edx
    43e3:	48 89 de             	mov    %rbx,%rsi
    43e6:	e8 e5 e2 ff ff       	callq  26d0 <waitpid@plt>
		if (pid <= 0)
    43eb:	85 c0                	test   %eax,%eax
	int ret;

	do_sigchld = false;

	while (1) {
		pid = waitpid(-1, &ret, WNOHANG);
    43ed:	89 c5                	mov    %eax,%ebp
		if (pid <= 0)
    43ef:	7e 3a                	jle    442b <uloop_run+0x130>
			return;

		list_for_each_entry_safe(p, tmp, &processes, list) {
    43f1:	4c 8b 35 88 3e 20 00 	mov    0x203e88(%rip),%r14        # 208280 <processes>
    43f8:	4c 8d 3d 81 3e 20 00 	lea    0x203e81(%rip),%r15        # 208280 <processes>
    43ff:	4d 8b 2e             	mov    (%r14),%r13
    4402:	4d 39 fe             	cmp    %r15,%r14
    4405:	74 d4                	je     43db <uloop_run+0xe0>
			if (p->pid < pid)
    4407:	41 3b 6e 20          	cmp    0x20(%r14),%ebp
    440b:	7f 15                	jg     4422 <uloop_run+0x127>
				continue;

			if (p->pid > pid)
    440d:	7c cc                	jl     43db <uloop_run+0xe0>
				break;

			uloop_process_delete(p);
    440f:	4c 89 f7             	mov    %r14,%rdi
    4412:	e8 59 e0 ff ff       	callq  2470 <uloop_process_delete@plt>
			p->cb(p, ret);
    4417:	8b 74 24 20          	mov    0x20(%rsp),%esi
    441b:	4c 89 f7             	mov    %r14,%rdi
    441e:	41 ff 56 18          	callq  *0x18(%r14)
	while (1) {
		pid = waitpid(-1, &ret, WNOHANG);
		if (pid <= 0)
			return;

		list_for_each_entry_safe(p, tmp, &processes, list) {
    4422:	4d 89 ee             	mov    %r13,%r14
    4425:	4d 8b 6d 00          	mov    0x0(%r13),%r13
    4429:	eb d7                	jmp    4402 <uloop_run+0x107>
		if (uloop_cancelled)
			break;

		if (do_sigchld)
			uloop_handle_processes();
		uloop_gettime(&tv);
    442b:	4c 89 e7             	mov    %r12,%rdi
    442e:	e8 1c fa ff ff       	callq  3e4f <uloop_gettime>
    4433:	48 8b 05 56 3e 20 00 	mov    0x203e56(%rip),%rax        # 208290 <timeouts>
static int uloop_get_next_timeout(struct timeval *tv)
{
	struct uloop_timeout *timeout;
	int diff;

	if (list_empty(&timeouts))
    443a:	48 8d 15 4f 3e 20 00 	lea    0x203e4f(%rip),%rdx        # 208290 <timeouts>
		return -1;
    4441:	83 c9 ff             	or     $0xffffffff,%ecx
static int uloop_get_next_timeout(struct timeval *tv)
{
	struct uloop_timeout *timeout;
	int diff;

	if (list_empty(&timeouts))
    4444:	48 39 d0             	cmp    %rdx,%rax
    4447:	74 2c                	je     4475 <uloop_run+0x17a>
    4449:	48 8b 48 20          	mov    0x20(%rax),%rcx
    444d:	48 8b 40 28          	mov    0x28(%rax),%rax
    4451:	be e8 03 00 00       	mov    $0x3e8,%esi
    4456:	48 2b 44 24 18       	sub    0x18(%rsp),%rax
    445b:	48 2b 4c 24 10       	sub    0x10(%rsp),%rcx
    4460:	48 99                	cqto   
    4462:	48 f7 fe             	idiv   %rsi
    4465:	69 c9 e8 03 00 00    	imul   $0x3e8,%ecx,%ecx
    446b:	01 c1                	add    %eax,%ecx
    446d:	b8 00 00 00 00       	mov    $0x0,%eax
    4472:	0f 48 c8             	cmovs  %eax,%ecx
static void uloop_run_events(int timeout)
{
	struct uloop_fd_event *cur;
	struct uloop_fd *fd;

	if (!cur_nfds) {
    4475:	83 3d 1c 40 20 00 00 	cmpl   $0x0,0x20401c(%rip)        # 208498 <cur_nfds>
    447c:	0f 85 c2 00 00 00    	jne    4544 <uloop_run+0x249>

static int uloop_fetch_events(int timeout)
{
	int n, nfds;

	nfds = epoll_wait(poll_fd, events, ARRAY_SIZE(events), timeout);
    4482:	8b 3d f4 3d 20 00    	mov    0x203df4(%rip),%edi        # 20827c <poll_fd>
    4488:	48 8d 35 91 3f 20 00 	lea    0x203f91(%rip),%rsi        # 208420 <events>
    448f:	ba 0a 00 00 00       	mov    $0xa,%edx
{
	struct uloop_fd_event *cur;
	struct uloop_fd *fd;

	if (!cur_nfds) {
		cur_fd = 0;
    4494:	c7 05 fe 3f 20 00 00 	movl   $0x0,0x203ffe(%rip)        # 20849c <cur_fd>
    449b:	00 00 00 
    449e:	4c 8d 3d 7b 3f 20 00 	lea    0x203f7b(%rip),%r15        # 208420 <events>
static int uloop_fetch_events(int timeout)
{
	int n, nfds;

	nfds = epoll_wait(poll_fd, events, ARRAY_SIZE(events), timeout);
	for (n = 0; n < nfds; ++n) {
    44a5:	45 31 ed             	xor    %r13d,%r13d

static int uloop_fetch_events(int timeout)
{
	int n, nfds;

	nfds = epoll_wait(poll_fd, events, ARRAY_SIZE(events), timeout);
    44a8:	e8 d3 e1 ff ff       	callq  2680 <epoll_wait@plt>
    44ad:	48 8d 15 ec 3f 20 00 	lea    0x203fec(%rip),%rdx        # 2084a0 <cur_fds>
    44b4:	89 c5                	mov    %eax,%ebp
	for (n = 0; n < nfds; ++n) {
    44b6:	44 39 ed             	cmp    %r13d,%ebp
    44b9:	7e 6e                	jle    4529 <uloop_run+0x22e>
		struct uloop_fd_event *cur = &cur_fds[n];
		struct uloop_fd *u = events[n].data.ptr;
    44bb:	4d 8b 77 04          	mov    0x4(%r15),%r14
		unsigned int ev = 0;

		cur->fd = u;
		if (!u)
    44bf:	4d 85 f6             	test   %r14,%r14
	for (n = 0; n < nfds; ++n) {
		struct uloop_fd_event *cur = &cur_fds[n];
		struct uloop_fd *u = events[n].data.ptr;
		unsigned int ev = 0;

		cur->fd = u;
    44c2:	4c 89 32             	mov    %r14,(%rdx)
		if (!u)
    44c5:	74 55                	je     451c <uloop_run+0x221>
			continue;

		if (events[n].events & (EPOLLERR|EPOLLHUP)) {
    44c7:	41 f6 07 18          	testb  $0x18,(%r15)
    44cb:	74 1e                	je     44eb <uloop_run+0x1f0>
			u->error = true;
			if (!(u->flags & ULOOP_ERROR_CB))
    44cd:	41 f6 46 0f 40       	testb  $0x40,0xf(%r14)
		cur->fd = u;
		if (!u)
			continue;

		if (events[n].events & (EPOLLERR|EPOLLHUP)) {
			u->error = true;
    44d2:	41 c6 46 0d 01       	movb   $0x1,0xd(%r14)
			if (!(u->flags & ULOOP_ERROR_CB))
    44d7:	75 12                	jne    44eb <uloop_run+0x1f0>
				uloop_fd_delete(u);
    44d9:	4c 89 f7             	mov    %r14,%rdi
    44dc:	48 89 54 24 08       	mov    %rdx,0x8(%rsp)
    44e1:	e8 5a e2 ff ff       	callq  2740 <uloop_fd_delete@plt>
    44e6:	48 8b 54 24 08       	mov    0x8(%rsp),%rdx
		}

		if(!(events[n].events & (EPOLLRDHUP|EPOLLIN|EPOLLOUT|EPOLLERR|EPOLLHUP))) {
    44eb:	41 8b 0f             	mov    (%r15),%ecx
    44ee:	f7 c1 1d 20 00 00    	test   $0x201d,%ecx
    44f4:	75 09                	jne    44ff <uloop_run+0x204>
			cur->fd = NULL;
    44f6:	48 c7 02 00 00 00 00 	movq   $0x0,(%rdx)
    44fd:	eb 1d                	jmp    451c <uloop_run+0x221>
			continue;
		}

		if(events[n].events & EPOLLRDHUP)
    44ff:	f6 c5 20             	test   $0x20,%ch
    4502:	74 05                	je     4509 <uloop_run+0x20e>
			u->eof = true;
    4504:	41 c6 46 0c 01       	movb   $0x1,0xc(%r14)

		if(events[n].events & EPOLLIN)
    4509:	89 c8                	mov    %ecx,%eax
    450b:	83 e0 01             	and    $0x1,%eax
			ev |= ULOOP_READ;

		if(events[n].events & EPOLLOUT)
			ev |= ULOOP_WRITE;
    450e:	89 c7                	mov    %eax,%edi
    4510:	83 cf 02             	or     $0x2,%edi
    4513:	80 e1 04             	and    $0x4,%cl
    4516:	0f 45 c7             	cmovne %edi,%eax

		cur->events = ev;
    4519:	89 42 08             	mov    %eax,0x8(%rdx)
static int uloop_fetch_events(int timeout)
{
	int n, nfds;

	nfds = epoll_wait(poll_fd, events, ARRAY_SIZE(events), timeout);
	for (n = 0; n < nfds; ++n) {
    451c:	41 ff c5             	inc    %r13d
    451f:	49 83 c7 0c          	add    $0xc,%r15
    4523:	48 83 c2 10          	add    $0x10,%rdx
    4527:	eb 8d                	jmp    44b6 <uloop_run+0x1bb>
	struct uloop_fd *fd;

	if (!cur_nfds) {
		cur_fd = 0;
		cur_nfds = uloop_fetch_events(timeout);
		if (cur_nfds < 0)
    4529:	85 ed                	test   %ebp,%ebp
    452b:	78 08                	js     4535 <uloop_run+0x23a>
	struct uloop_fd_event *cur;
	struct uloop_fd *fd;

	if (!cur_nfds) {
		cur_fd = 0;
		cur_nfds = uloop_fetch_events(timeout);
    452d:	89 2d 65 3f 20 00    	mov    %ebp,0x203f65(%rip)        # 208498 <cur_nfds>
    4533:	eb 0f                	jmp    4544 <uloop_run+0x249>
		if (cur_nfds < 0)
			cur_nfds = 0;
    4535:	c7 05 59 3f 20 00 00 	movl   $0x0,0x203f59(%rip)        # 208498 <cur_nfds>
    453c:	00 00 00 
    453f:	e9 fc fd ff ff       	jmpq   4340 <uloop_run+0x45>
		unsigned int events;

		cur = &cur_fds[cur_fd++];
		cur_nfds--;

		fd = cur->fd;
    4544:	48 8d 0d 55 3f 20 00 	lea    0x203f55(%rip),%rcx        # 2084a0 <cur_fds>
		cur_nfds = uloop_fetch_events(timeout);
		if (cur_nfds < 0)
			cur_nfds = 0;
	}

	while (cur_nfds > 0) {
    454b:	8b 15 47 3f 20 00    	mov    0x203f47(%rip),%edx        # 208498 <cur_nfds>
    4551:	85 d2                	test   %edx,%edx
    4553:	0f 8e e7 fd ff ff    	jle    4340 <uloop_run+0x45>
		struct uloop_fd_stack stack_cur;
		unsigned int events;

		cur = &cur_fds[cur_fd++];
    4559:	48 63 05 3c 3f 20 00 	movslq 0x203f3c(%rip),%rax        # 20849c <cur_fd>
		cur_nfds--;
    4560:	ff ca                	dec    %edx
    4562:	89 15 30 3f 20 00    	mov    %edx,0x203f30(%rip)        # 208498 <cur_nfds>

	while (cur_nfds > 0) {
		struct uloop_fd_stack stack_cur;
		unsigned int events;

		cur = &cur_fds[cur_fd++];
    4568:	8d 70 01             	lea    0x1(%rax),%esi
		cur_nfds--;

		fd = cur->fd;
    456b:	48 c1 e0 04          	shl    $0x4,%rax
    456f:	48 01 c8             	add    %rcx,%rax
    4572:	4c 8b 30             	mov    (%rax),%r14

	while (cur_nfds > 0) {
		struct uloop_fd_stack stack_cur;
		unsigned int events;

		cur = &cur_fds[cur_fd++];
    4575:	89 35 21 3f 20 00    	mov    %esi,0x203f21(%rip)        # 20849c <cur_fd>
		cur_nfds--;

		fd = cur->fd;
		events = cur->events;
		if (!fd)
    457b:	4d 85 f6             	test   %r14,%r14
    457e:	74 cb                	je     454b <uloop_run+0x250>
			continue;

		if (!fd->cb)
    4580:	49 83 3e 00          	cmpq   $0x0,(%r14)
    4584:	74 c5                	je     454b <uloop_run+0x250>

	/*
	 * Do not buffer events for level-triggered fds, they will keep firing.
	 * Caller needs to take care of recursion issues.
	 */
	if (!(fd->flags & ULOOP_EDGE_TRIGGER))
    4586:	41 f6 46 0f 04       	testb  $0x4,0xf(%r14)

		cur = &cur_fds[cur_fd++];
		cur_nfds--;

		fd = cur->fd;
		events = cur->events;
    458b:	8b 70 08             	mov    0x8(%rax),%esi
    458e:	48 8b 15 b3 3f 20 00 	mov    0x203fb3(%rip),%rdx        # 208548 <fd_stack>

	/*
	 * Do not buffer events for level-triggered fds, they will keep firing.
	 * Caller needs to take care of recursion issues.
	 */
	if (!(fd->flags & ULOOP_EDGE_TRIGGER))
    4595:	74 2c                	je     45c3 <uloop_run+0x2c8>
		return false;

	for (cur = fd_stack; cur; cur = cur->next) {
    4597:	48 89 d0             	mov    %rdx,%rax
    459a:	48 85 c0             	test   %rax,%rax
    459d:	74 24                	je     45c3 <uloop_run+0x2c8>
		if (cur->fd != fd)
    459f:	4c 3b 70 08          	cmp    0x8(%rax),%r14
    45a3:	74 05                	je     45aa <uloop_run+0x2af>
	 * Caller needs to take care of recursion issues.
	 */
	if (!(fd->flags & ULOOP_EDGE_TRIGGER))
		return false;

	for (cur = fd_stack; cur; cur = cur->next) {
    45a5:	48 8b 00             	mov    (%rax),%rax
    45a8:	eb f0                	jmp    459a <uloop_run+0x29f>
		if (cur->fd != fd)
			continue;

		if (events < 0)
    45aa:	85 f6                	test   %esi,%esi
    45ac:	79 0a                	jns    45b8 <uloop_run+0x2bd>
			cur->fd = NULL;
    45ae:	48 c7 40 08 00 00 00 	movq   $0x0,0x8(%rax)
    45b5:	00 
    45b6:	eb 93                	jmp    454b <uloop_run+0x250>
		else
			cur->events |= events | ULOOP_EVENT_BUFFERED;
    45b8:	0b 70 10             	or     0x10(%rax),%esi
    45bb:	83 ce 10             	or     $0x10,%esi
    45be:	89 70 10             	mov    %esi,0x10(%rax)
    45c1:	eb 88                	jmp    454b <uloop_run+0x250>
			continue;

		if (uloop_fd_stack_event(fd, cur->events))
			continue;

		stack_cur.next = fd_stack;
    45c3:	48 89 54 24 20       	mov    %rdx,0x20(%rsp)
		stack_cur.fd = fd;
    45c8:	4c 89 74 24 28       	mov    %r14,0x28(%rsp)
		fd_stack = &stack_cur;
    45cd:	48 89 1d 74 3f 20 00 	mov    %rbx,0x203f74(%rip)        # 208548 <fd_stack>
		do {
			stack_cur.events = 0;
    45d4:	c7 44 24 30 00 00 00 	movl   $0x0,0x30(%rsp)
    45db:	00 
			fd->cb(fd, events);
    45dc:	4c 89 f7             	mov    %r14,%rdi
    45df:	41 ff 16             	callq  *(%r14)
			events = stack_cur.events & ULOOP_EVENT_MASK;
    45e2:	8b 74 24 30          	mov    0x30(%rsp),%esi
    45e6:	83 e6 03             	and    $0x3,%esi
		} while (stack_cur.fd && events);
    45e9:	48 83 7c 24 28 00    	cmpq   $0x0,0x28(%rsp)
    45ef:	74 04                	je     45f5 <uloop_run+0x2fa>
    45f1:	85 f6                	test   %esi,%esi
    45f3:	75 df                	jne    45d4 <uloop_run+0x2d9>
		fd_stack = stack_cur.next;
    45f5:	48 8b 44 24 20       	mov    0x20(%rsp),%rax
    45fa:	48 89 05 47 3f 20 00 	mov    %rax,0x203f47(%rip)        # 208548 <fd_stack>
    4601:	e9 3a fd ff ff       	jmpq   4340 <uloop_run+0x45>
		uloop_run_events(uloop_get_next_timeout(&tv));
	}

	if (!--recursive_calls)
		uloop_setup_signals(false);
}
    4606:	48 8b 44 24 38       	mov    0x38(%rsp),%rax
    460b:	64 48 33 04 25 28 00 	xor    %fs:0x28,%rax
    4612:	00 00 
    4614:	74 05                	je     461b <uloop_run+0x320>
    4616:	e8 65 de ff ff       	callq  2480 <__stack_chk_fail@plt>
    461b:	48 83 c4 48          	add    $0x48,%rsp
    461f:	5b                   	pop    %rbx
    4620:	5d                   	pop    %rbp
    4621:	41 5c                	pop    %r12
    4623:	41 5d                	pop    %r13
    4625:	41 5e                	pop    %r14
    4627:	41 5f                	pop    %r15
    4629:	c3                   	retq   

000000000000462a <uloop_done>:

void uloop_done(void)
{
	if (poll_fd < 0)
    462a:	8b 3d 4c 3c 20 00    	mov    0x203c4c(%rip),%edi        # 20827c <poll_fd>
    4630:	85 ff                	test   %edi,%edi
    4632:	78 5b                	js     468f <uloop_done+0x65>
	if (!--recursive_calls)
		uloop_setup_signals(false);
}

void uloop_done(void)
{
    4634:	55                   	push   %rbp
    4635:	53                   	push   %rbx

static void uloop_clear_timeouts(void)
{
	struct uloop_timeout *t, *tmp;

	list_for_each_entry_safe(t, tmp, &timeouts, list)
    4636:	48 8d 2d 53 3c 20 00 	lea    0x203c53(%rip),%rbp        # 208290 <timeouts>
	if (!--recursive_calls)
		uloop_setup_signals(false);
}

void uloop_done(void)
{
    463d:	52                   	push   %rdx
	if (poll_fd < 0)
		return;

	close(poll_fd);
    463e:	e8 fd de ff ff       	callq  2540 <close@plt>

static void uloop_clear_timeouts(void)
{
	struct uloop_timeout *t, *tmp;

	list_for_each_entry_safe(t, tmp, &timeouts, list)
    4643:	48 8b 3d 46 3c 20 00 	mov    0x203c46(%rip),%rdi        # 208290 <timeouts>
{
	if (poll_fd < 0)
		return;

	close(poll_fd);
	poll_fd = -1;
    464a:	c7 05 28 3c 20 00 ff 	movl   $0xffffffff,0x203c28(%rip)        # 20827c <poll_fd>
    4651:	ff ff ff 

static void uloop_clear_timeouts(void)
{
	struct uloop_timeout *t, *tmp;

	list_for_each_entry_safe(t, tmp, &timeouts, list)
    4654:	48 8b 1f             	mov    (%rdi),%rbx
    4657:	48 39 ef             	cmp    %rbp,%rdi
    465a:	74 0d                	je     4669 <uloop_done+0x3f>
		uloop_timeout_cancel(t);
    465c:	e8 ff e0 ff ff       	callq  2760 <uloop_timeout_cancel@plt>

static void uloop_clear_timeouts(void)
{
	struct uloop_timeout *t, *tmp;

	list_for_each_entry_safe(t, tmp, &timeouts, list)
    4661:	48 89 df             	mov    %rbx,%rdi
    4664:	48 8b 1b             	mov    (%rbx),%rbx
    4667:	eb ee                	jmp    4657 <uloop_done+0x2d>

static void uloop_clear_processes(void)
{
	struct uloop_process *p, *tmp;

	list_for_each_entry_safe(p, tmp, &processes, list)
    4669:	48 8b 3d 10 3c 20 00 	mov    0x203c10(%rip),%rdi        # 208280 <processes>
    4670:	48 8d 2d 09 3c 20 00 	lea    0x203c09(%rip),%rbp        # 208280 <processes>
    4677:	48 8b 1f             	mov    (%rdi),%rbx
    467a:	48 39 ef             	cmp    %rbp,%rdi
    467d:	74 0d                	je     468c <uloop_done+0x62>
		uloop_process_delete(p);
    467f:	e8 ec dd ff ff       	callq  2470 <uloop_process_delete@plt>

static void uloop_clear_processes(void)
{
	struct uloop_process *p, *tmp;

	list_for_each_entry_safe(p, tmp, &processes, list)
    4684:	48 89 df             	mov    %rbx,%rdi
    4687:	48 8b 1b             	mov    (%rbx),%rbx
    468a:	eb ee                	jmp    467a <uloop_done+0x50>
	close(poll_fd);
	poll_fd = -1;

	uloop_clear_timeouts();
	uloop_clear_processes();
}
    468c:	58                   	pop    %rax
    468d:	5b                   	pop    %rbx
    468e:	5d                   	pop    %rbp
    468f:	c3                   	retq   

0000000000004690 <usock_connect>:
	if (type & USOCK_NONBLOCK)
		fcntl(sock, F_SETFL, fcntl(sock, F_GETFL) | O_NONBLOCK);
}

static int usock_connect(struct sockaddr *sa, int sa_len, int family, int socktype, bool server)
{
    4690:	41 55                	push   %r13
    4692:	41 54                	push   %r12
    4694:	41 89 f4             	mov    %esi,%r12d
    4697:	55                   	push   %rbp
    4698:	53                   	push   %rbx
    4699:	48 89 fd             	mov    %rdi,%rbp
	int sock;

	sock = socket(family, socktype, 0);
    469c:	89 ce                	mov    %ecx,%esi
	if (type & USOCK_NONBLOCK)
		fcntl(sock, F_SETFL, fcntl(sock, F_GETFL) | O_NONBLOCK);
}

static int usock_connect(struct sockaddr *sa, int sa_len, int family, int socktype, bool server)
{
    469e:	89 d7                	mov    %edx,%edi
	int sock;

	sock = socket(family, socktype, 0);
    46a0:	31 d2                	xor    %edx,%edx
	if (type & USOCK_NONBLOCK)
		fcntl(sock, F_SETFL, fcntl(sock, F_GETFL) | O_NONBLOCK);
}

static int usock_connect(struct sockaddr *sa, int sa_len, int family, int socktype, bool server)
{
    46a2:	48 83 ec 28          	sub    $0x28,%rsp
    46a6:	41 89 cd             	mov    %ecx,%r13d
    46a9:	64 48 8b 04 25 28 00 	mov    %fs:0x28,%rax
    46b0:	00 00 
    46b2:	48 89 44 24 18       	mov    %rax,0x18(%rsp)
    46b7:	31 c0                	xor    %eax,%eax
    46b9:	44 89 44 24 0c       	mov    %r8d,0xc(%rsp)
	int sock;

	sock = socket(family, socktype, 0);
    46be:	e8 fd e0 ff ff       	callq  27c0 <socket@plt>
	if (sock < 0)
		return -1;
    46c3:	83 ca ff             	or     $0xffffffff,%edx
static int usock_connect(struct sockaddr *sa, int sa_len, int family, int socktype, bool server)
{
	int sock;

	sock = socket(family, socktype, 0);
	if (sock < 0)
    46c6:	85 c0                	test   %eax,%eax
    46c8:	0f 88 85 00 00 00    	js     4753 <usock_connect+0xc3>
		return -1;

	if (server) {
    46ce:	44 8b 44 24 0c       	mov    0xc(%rsp),%r8d
    46d3:	89 c3                	mov    %eax,%ebx
    46d5:	45 84 c0             	test   %r8b,%r8b
    46d8:	74 50                	je     472a <usock_connect+0x9a>
		const int one = 1;
		setsockopt(sock, SOL_SOCKET, SO_REUSEADDR, &one, sizeof(one));
    46da:	48 8d 4c 24 14       	lea    0x14(%rsp),%rcx
    46df:	41 b8 04 00 00 00    	mov    $0x4,%r8d
    46e5:	ba 02 00 00 00       	mov    $0x2,%edx
    46ea:	be 01 00 00 00       	mov    $0x1,%esi
    46ef:	89 c7                	mov    %eax,%edi
	sock = socket(family, socktype, 0);
	if (sock < 0)
		return -1;

	if (server) {
		const int one = 1;
    46f1:	c7 44 24 14 01 00 00 	movl   $0x1,0x14(%rsp)
    46f8:	00 
		setsockopt(sock, SOL_SOCKET, SO_REUSEADDR, &one, sizeof(one));
    46f9:	e8 c2 dc ff ff       	callq  23c0 <setsockopt@plt>

		if (!bind(sock, sa, sa_len) &&
    46fe:	44 89 e2             	mov    %r12d,%edx
    4701:	48 89 ee             	mov    %rbp,%rsi
    4704:	89 df                	mov    %ebx,%edi
    4706:	e8 95 df ff ff       	callq  26a0 <bind@plt>
    470b:	85 c0                	test   %eax,%eax
    470d:	75 3a                	jne    4749 <usock_connect+0xb9>
    470f:	41 ff cd             	dec    %r13d
    4712:	74 04                	je     4718 <usock_connect+0x88>
		    (socktype != SOCK_STREAM || !listen(sock, SOMAXCONN)))
			return sock;
    4714:	89 da                	mov    %ebx,%edx
    4716:	eb 3b                	jmp    4753 <usock_connect+0xc3>
	if (server) {
		const int one = 1;
		setsockopt(sock, SOL_SOCKET, SO_REUSEADDR, &one, sizeof(one));

		if (!bind(sock, sa, sa_len) &&
		    (socktype != SOCK_STREAM || !listen(sock, SOMAXCONN)))
    4718:	be 80 00 00 00       	mov    $0x80,%esi
    471d:	89 df                	mov    %ebx,%edi
    471f:	e8 cc de ff ff       	callq  25f0 <listen@plt>
    4724:	85 c0                	test   %eax,%eax
    4726:	74 ec                	je     4714 <usock_connect+0x84>
    4728:	eb 1f                	jmp    4749 <usock_connect+0xb9>
			return sock;
	} else {
		if (!connect(sock, sa, sa_len) || errno == EINPROGRESS)
    472a:	44 89 e2             	mov    %r12d,%edx
    472d:	48 89 ee             	mov    %rbp,%rsi
    4730:	89 c7                	mov    %eax,%edi
    4732:	e8 f9 df ff ff       	callq  2730 <connect@plt>
    4737:	85 c0                	test   %eax,%eax
    4739:	89 da                	mov    %ebx,%edx
    473b:	74 16                	je     4753 <usock_connect+0xc3>
    473d:	e8 3e dc ff ff       	callq  2380 <__errno_location@plt>
    4742:	83 38 73             	cmpl   $0x73,(%rax)
    4745:	89 da                	mov    %ebx,%edx
    4747:	74 0a                	je     4753 <usock_connect+0xc3>
			return sock;
	}

	close(sock);
    4749:	89 df                	mov    %ebx,%edi
    474b:	e8 f0 dd ff ff       	callq  2540 <close@plt>
	return -1;
    4750:	83 ca ff             	or     $0xffffffff,%edx
}
    4753:	48 8b 4c 24 18       	mov    0x18(%rsp),%rcx
    4758:	64 48 33 0c 25 28 00 	xor    %fs:0x28,%rcx
    475f:	00 00 
    4761:	89 d0                	mov    %edx,%eax
    4763:	74 05                	je     476a <usock_connect+0xda>
    4765:	e8 16 dd ff ff       	callq  2480 <__stack_chk_fail@plt>
    476a:	48 83 c4 28          	add    $0x28,%rsp
    476e:	5b                   	pop    %rbx
    476f:	5d                   	pop    %rbp
    4770:	41 5c                	pop    %r12
    4772:	41 5d                	pop    %r13
    4774:	c3                   	retq   

0000000000004775 <usock>:

	freeaddrinfo(result);
	return sock;
}

int usock(int type, const char *host, const char *service) {
    4775:	41 56                	push   %r14
    4777:	41 55                	push   %r13
    4779:	49 89 f0             	mov    %rsi,%r8
    477c:	41 54                	push   %r12
    477e:	55                   	push   %rbp
    477f:	48 89 d6             	mov    %rdx,%rsi
    4782:	53                   	push   %rbx
	int socktype = ((type & 0xff) == USOCK_TCP) ? SOCK_STREAM : SOCK_DGRAM;
	bool server = !!(type & USOCK_SERVER);
    4783:	89 fa                	mov    %edi,%edx

	freeaddrinfo(result);
	return sock;
}

int usock(int type, const char *host, const char *service) {
    4785:	89 fd                	mov    %edi,%ebp
    4787:	48 81 ec b0 00 00 00 	sub    $0xb0,%rsp
    478e:	64 48 8b 04 25 28 00 	mov    %fs:0x28,%rax
    4795:	00 00 
    4797:	48 89 84 24 a8 00 00 	mov    %rax,0xa8(%rsp)
    479e:	00 
    479f:	31 c0                	xor    %eax,%eax
	int socktype = ((type & 0xff) == USOCK_TCP) ? SOCK_STREAM : SOCK_DGRAM;
    47a1:	40 0f b6 c7          	movzbl %dil,%eax
    47a5:	83 f8 01             	cmp    $0x1,%eax
	bool server = !!(type & USOCK_SERVER);
	int sock;

	if (type & USOCK_UNIX)
    47a8:	89 f8                	mov    %edi,%eax
	freeaddrinfo(result);
	return sock;
}

int usock(int type, const char *host, const char *service) {
	int socktype = ((type & 0xff) == USOCK_TCP) ? SOCK_STREAM : SOCK_DGRAM;
    47aa:	45 19 e4             	sbb    %r12d,%r12d
    47ad:	41 83 c4 02          	add    $0x2,%r12d
	bool server = !!(type & USOCK_SERVER);
    47b1:	81 e2 00 01 00 00    	and    $0x100,%edx
    47b7:	41 0f 95 c5          	setne  %r13b
	int sock;

	if (type & USOCK_UNIX)
    47bb:	25 00 80 00 00       	and    $0x8000,%eax
    47c0:	74 73                	je     4835 <usock+0xc0>
	return -1;
}

static int usock_unix(const char *host, int socktype, bool server)
{
	struct sockaddr_un sun = {.sun_family = AF_UNIX};
    47c2:	48 8d 7c 24 3a       	lea    0x3a(%rsp),%rdi
    47c7:	31 c0                	xor    %eax,%eax
    47c9:	b9 6e 00 00 00       	mov    $0x6e,%ecx
    47ce:	48 8d 5c 24 3a       	lea    0x3a(%rsp),%rbx
    47d3:	f3 aa                	rep stos %al,%es:(%rdi)

	if (strlen(host) >= sizeof(sun.sun_path)) {
    47d5:	48 83 c9 ff          	or     $0xffffffffffffffff,%rcx
	return -1;
}

static int usock_unix(const char *host, int socktype, bool server)
{
	struct sockaddr_un sun = {.sun_family = AF_UNIX};
    47d9:	66 c7 44 24 3a 01 00 	movw   $0x1,0x3a(%rsp)

	if (strlen(host) >= sizeof(sun.sun_path)) {
    47e0:	4c 89 c7             	mov    %r8,%rdi
    47e3:	f2 ae                	repnz scas %es:(%rdi),%al
    47e5:	48 f7 d1             	not    %rcx
    47e8:	48 ff c9             	dec    %rcx
    47eb:	48 83 f9 6b          	cmp    $0x6b,%rcx
    47ef:	76 10                	jbe    4801 <usock+0x8c>
		errno = EINVAL;
    47f1:	e8 8a db ff ff       	callq  2380 <__errno_location@plt>
    47f6:	c7 00 16 00 00 00    	movl   $0x16,(%rax)
    47fc:	e9 2e 01 00 00       	jmpq   492f <usock+0x1ba>
#endif

__fortify_function char *
__NTH (strcpy (char *__restrict __dest, const char *__restrict __src))
{
  return __builtin___strcpy_chk (__dest, __src, __bos (__dest));
    4801:	48 8d 7b 02          	lea    0x2(%rbx),%rdi
    4805:	4c 89 c6             	mov    %r8,%rsi
    4808:	ba 6c 00 00 00       	mov    $0x6c,%edx
    480d:	e8 4e de ff ff       	callq  2660 <__strcpy_chk@plt>
		return -1;
	}
	strcpy(sun.sun_path, host);

	return usock_connect((struct sockaddr*)&sun, sizeof(sun), AF_UNIX, socktype, server);
    4812:	45 89 e8             	mov    %r13d,%r8d
    4815:	48 89 df             	mov    %rbx,%rdi
    4818:	44 89 e1             	mov    %r12d,%ecx
    481b:	41 83 e0 01          	and    $0x1,%r8d
    481f:	ba 01 00 00 00       	mov    $0x1,%edx
    4824:	be 6e 00 00 00       	mov    $0x6e,%esi
    4829:	e8 62 fe ff ff       	callq  4690 <usock_connect>
    482e:	89 c3                	mov    %eax,%ebx
    4830:	e9 a2 00 00 00       	jmpq   48d7 <usock+0x162>
}

static int usock_inet(int type, const char *host, const char *service, int socktype, bool server)
{
	struct addrinfo *result, *rp;
	struct addrinfo hints = {
    4835:	48 8d 7c 24 08       	lea    0x8(%rsp),%rdi
		.ai_family = (type & USOCK_IPV6ONLY) ? AF_INET6 :
			(type & USOCK_IPV4ONLY) ? AF_INET : AF_UNSPEC,
		.ai_socktype = socktype,
		.ai_flags = AI_ADDRCONFIG
			| ((type & USOCK_SERVER) ? AI_PASSIVE : 0)
    483a:	83 fa 01             	cmp    $0x1,%edx
}

static int usock_inet(int type, const char *host, const char *service, int socktype, bool server)
{
	struct addrinfo *result, *rp;
	struct addrinfo hints = {
    483d:	b9 0c 00 00 00       	mov    $0xc,%ecx
		.ai_family = (type & USOCK_IPV6ONLY) ? AF_INET6 :
			(type & USOCK_IPV4ONLY) ? AF_INET : AF_UNSPEC,
		.ai_socktype = socktype,
		.ai_flags = AI_ADDRCONFIG
			| ((type & USOCK_SERVER) ? AI_PASSIVE : 0)
    4842:	19 d2                	sbb    %edx,%edx
}

static int usock_inet(int type, const char *host, const char *service, int socktype, bool server)
{
	struct addrinfo *result, *rp;
	struct addrinfo hints = {
    4844:	f3 ab                	rep stos %eax,%es:(%rdi)
		.ai_family = (type & USOCK_IPV6ONLY) ? AF_INET6 :
			(type & USOCK_IPV4ONLY) ? AF_INET : AF_UNSPEC,
		.ai_socktype = socktype,
		.ai_flags = AI_ADDRCONFIG
			| ((type & USOCK_SERVER) ? AI_PASSIVE : 0)
			| ((type & USOCK_NUMERIC) ? AI_NUMERICHOST : 0),
    4846:	89 e8                	mov    %ebp,%eax
	struct addrinfo hints = {
		.ai_family = (type & USOCK_IPV6ONLY) ? AF_INET6 :
			(type & USOCK_IPV4ONLY) ? AF_INET : AF_UNSPEC,
		.ai_socktype = socktype,
		.ai_flags = AI_ADDRCONFIG
			| ((type & USOCK_SERVER) ? AI_PASSIVE : 0)
    4848:	83 c2 21             	add    $0x21,%edx
			| ((type & USOCK_NUMERIC) ? AI_NUMERICHOST : 0),
    484b:	b9 04 00 00 00       	mov    $0x4,%ecx
    4850:	25 00 08 00 00       	and    $0x800,%eax
    4855:	0f 45 c1             	cmovne %ecx,%eax
}

static int usock_inet(int type, const char *host, const char *service, int socktype, bool server)
{
	struct addrinfo *result, *rp;
	struct addrinfo hints = {
    4858:	09 d0                	or     %edx,%eax
		.ai_family = (type & USOCK_IPV6ONLY) ? AF_INET6 :
    485a:	f7 c5 00 20 00 00    	test   $0x2000,%ebp
}

static int usock_inet(int type, const char *host, const char *service, int socktype, bool server)
{
	struct addrinfo *result, *rp;
	struct addrinfo hints = {
    4860:	89 44 24 08          	mov    %eax,0x8(%rsp)
		.ai_family = (type & USOCK_IPV6ONLY) ? AF_INET6 :
    4864:	b8 0a 00 00 00       	mov    $0xa,%eax
    4869:	75 0f                	jne    487a <usock+0x105>
			(type & USOCK_IPV4ONLY) ? AF_INET : AF_UNSPEC,
    486b:	89 e8                	mov    %ebp,%eax
    486d:	ba 02 00 00 00       	mov    $0x2,%edx
    4872:	25 00 40 00 00       	and    $0x4000,%eax
    4877:	0f 45 c2             	cmovne %edx,%eax
			| ((type & USOCK_SERVER) ? AI_PASSIVE : 0)
			| ((type & USOCK_NUMERIC) ? AI_NUMERICHOST : 0),
	};
	int sock = -1;

	if (getaddrinfo(host, service, &hints, &result))
    487a:	48 8d 54 24 08       	lea    0x8(%rsp),%rdx
    487f:	48 89 e1             	mov    %rsp,%rcx
    4882:	4c 89 c7             	mov    %r8,%rdi
}

static int usock_inet(int type, const char *host, const char *service, int socktype, bool server)
{
	struct addrinfo *result, *rp;
	struct addrinfo hints = {
    4885:	89 44 24 0c          	mov    %eax,0xc(%rsp)
    4889:	44 89 64 24 10       	mov    %r12d,0x10(%rsp)
			| ((type & USOCK_SERVER) ? AI_PASSIVE : 0)
			| ((type & USOCK_NUMERIC) ? AI_NUMERICHOST : 0),
	};
	int sock = -1;

	if (getaddrinfo(host, service, &hints, &result))
    488e:	e8 bd de ff ff       	callq  2750 <getaddrinfo@plt>
    4893:	85 c0                	test   %eax,%eax
    4895:	0f 85 94 00 00 00    	jne    492f <usock+0x1ba>
		return -1;

	for (rp = result; rp != NULL; rp = rp->ai_next) {
    489b:	4c 8b 34 24          	mov    (%rsp),%r14
		.ai_socktype = socktype,
		.ai_flags = AI_ADDRCONFIG
			| ((type & USOCK_SERVER) ? AI_PASSIVE : 0)
			| ((type & USOCK_NUMERIC) ? AI_NUMERICHOST : 0),
	};
	int sock = -1;
    489f:	83 cb ff             	or     $0xffffffff,%ebx

	if (getaddrinfo(host, service, &hints, &result))
		return -1;

	for (rp = result; rp != NULL; rp = rp->ai_next) {
		sock = usock_connect(rp->ai_addr, rp->ai_addrlen, rp->ai_family, socktype, server);
    48a2:	45 0f b6 ed          	movzbl %r13b,%r13d
	int sock = -1;

	if (getaddrinfo(host, service, &hints, &result))
		return -1;

	for (rp = result; rp != NULL; rp = rp->ai_next) {
    48a6:	4d 85 f6             	test   %r14,%r14
    48a9:	74 23                	je     48ce <usock+0x159>
		sock = usock_connect(rp->ai_addr, rp->ai_addrlen, rp->ai_family, socktype, server);
    48ab:	41 8b 56 04          	mov    0x4(%r14),%edx
    48af:	41 8b 76 10          	mov    0x10(%r14),%esi
    48b3:	45 89 e8             	mov    %r13d,%r8d
    48b6:	49 8b 7e 18          	mov    0x18(%r14),%rdi
    48ba:	44 89 e1             	mov    %r12d,%ecx
    48bd:	e8 ce fd ff ff       	callq  4690 <usock_connect>
		if (sock >= 0)
    48c2:	85 c0                	test   %eax,%eax

	if (getaddrinfo(host, service, &hints, &result))
		return -1;

	for (rp = result; rp != NULL; rp = rp->ai_next) {
		sock = usock_connect(rp->ai_addr, rp->ai_addrlen, rp->ai_family, socktype, server);
    48c4:	89 c3                	mov    %eax,%ebx
		if (sock >= 0)
    48c6:	79 06                	jns    48ce <usock+0x159>
	int sock = -1;

	if (getaddrinfo(host, service, &hints, &result))
		return -1;

	for (rp = result; rp != NULL; rp = rp->ai_next) {
    48c8:	4d 8b 76 28          	mov    0x28(%r14),%r14
    48cc:	eb d8                	jmp    48a6 <usock+0x131>
		sock = usock_connect(rp->ai_addr, rp->ai_addrlen, rp->ai_family, socktype, server);
		if (sock >= 0)
			break;
	}

	freeaddrinfo(result);
    48ce:	48 8b 3c 24          	mov    (%rsp),%rdi
    48d2:	e8 d9 de ff ff       	callq  27b0 <freeaddrinfo@plt>
	if (type & USOCK_UNIX)
		sock = usock_unix(host, socktype, server);
	else
		sock = usock_inet(type, host, service, socktype, server);

	if (sock < 0)
    48d7:	85 db                	test   %ebx,%ebx
    48d9:	78 54                	js     492f <usock+0x1ba>

#include "usock.h"

static void usock_set_flags(int sock, unsigned int type)
{
	if (!(type & USOCK_NOCLOEXEC))
    48db:	f7 c5 00 02 00 00    	test   $0x200,%ebp
    48e1:	75 21                	jne    4904 <usock+0x18f>
		fcntl(sock, F_SETFD, fcntl(sock, F_GETFD) | FD_CLOEXEC);
    48e3:	be 01 00 00 00       	mov    $0x1,%esi
    48e8:	89 df                	mov    %ebx,%edi
    48ea:	31 c0                	xor    %eax,%eax
    48ec:	e8 ff da ff ff       	callq  23f0 <fcntl@plt>
    48f1:	83 c8 01             	or     $0x1,%eax
    48f4:	be 02 00 00 00       	mov    $0x2,%esi
    48f9:	89 df                	mov    %ebx,%edi
    48fb:	89 c2                	mov    %eax,%edx
    48fd:	31 c0                	xor    %eax,%eax
    48ff:	e8 ec da ff ff       	callq  23f0 <fcntl@plt>

	if (type & USOCK_NONBLOCK)
    4904:	81 e5 00 04 00 00    	and    $0x400,%ebp
    490a:	74 26                	je     4932 <usock+0x1bd>
		fcntl(sock, F_SETFL, fcntl(sock, F_GETFL) | O_NONBLOCK);
    490c:	89 df                	mov    %ebx,%edi
    490e:	be 03 00 00 00       	mov    $0x3,%esi
    4913:	31 c0                	xor    %eax,%eax
    4915:	e8 d6 da ff ff       	callq  23f0 <fcntl@plt>
    491a:	80 cc 08             	or     $0x8,%ah
    491d:	be 04 00 00 00       	mov    $0x4,%esi
    4922:	89 df                	mov    %ebx,%edi
    4924:	89 c2                	mov    %eax,%edx
    4926:	31 c0                	xor    %eax,%eax
    4928:	e8 c3 da ff ff       	callq  23f0 <fcntl@plt>
    492d:	eb 03                	jmp    4932 <usock+0x1bd>
		sock = usock_unix(host, socktype, server);
	else
		sock = usock_inet(type, host, service, socktype, server);

	if (sock < 0)
		return -1;
    492f:	83 cb ff             	or     $0xffffffff,%ebx

	usock_set_flags(sock, type);
	return sock;
}
    4932:	48 8b b4 24 a8 00 00 	mov    0xa8(%rsp),%rsi
    4939:	00 
    493a:	64 48 33 34 25 28 00 	xor    %fs:0x28,%rsi
    4941:	00 00 
    4943:	89 d8                	mov    %ebx,%eax
    4945:	74 05                	je     494c <usock+0x1d7>
    4947:	e8 34 db ff ff       	callq  2480 <__stack_chk_fail@plt>
    494c:	48 81 c4 b0 00 00 00 	add    $0xb0,%rsp
    4953:	5b                   	pop    %rbx
    4954:	5d                   	pop    %rbp
    4955:	41 5c                	pop    %r12
    4957:	41 5d                	pop    %r13
    4959:	41 5e                	pop    %r14
    495b:	c3                   	retq   

000000000000495c <ustream_free_buffers>:

	return 0;
}

static void ustream_free_buffers(struct ustream_buf_list *l)
{
    495c:	55                   	push   %rbp
    495d:	53                   	push   %rbx
    495e:	48 89 fb             	mov    %rdi,%rbx
    4961:	52                   	push   %rdx
	struct ustream_buf *buf = l->head;
    4962:	48 8b 3f             	mov    (%rdi),%rdi

	while (buf) {
    4965:	48 85 ff             	test   %rdi,%rdi
    4968:	74 0d                	je     4977 <ustream_free_buffers+0x1b>
		struct ustream_buf *next = buf->next;
    496a:	48 8b 2f             	mov    (%rdi),%rbp

		free(buf);
    496d:	e8 ee d9 ff ff       	callq  2360 <free@plt>
		buf = next;
    4972:	48 89 ef             	mov    %rbp,%rdi
    4975:	eb ee                	jmp    4965 <ustream_free_buffers+0x9>
	}
	l->head = NULL;
    4977:	48 c7 03 00 00 00 00 	movq   $0x0,(%rbx)
	l->tail = NULL;
    497e:	48 c7 43 10 00 00 00 	movq   $0x0,0x10(%rbx)
    4985:	00 
	l->data_tail = NULL;
    4986:	48 c7 43 08 00 00 00 	movq   $0x0,0x8(%rbx)
    498d:	00 
}
    498e:	58                   	pop    %rax
    498f:	5b                   	pop    %rbx
    4990:	5d                   	pop    %rbp
    4991:	c3                   	retq   

0000000000004992 <ustream_state_change_cb>:
	ustream_free_buffers(&s->r);
	ustream_free_buffers(&s->w);
}

static void ustream_state_change_cb(struct uloop_timeout *t)
{
    4992:	55                   	push   %rbp
    4993:	53                   	push   %rbx
	struct ustream *s = container_of(t, struct ustream, state_change);
    4994:	48 8d 6f 90          	lea    -0x70(%rdi),%rbp
	ustream_free_buffers(&s->r);
	ustream_free_buffers(&s->w);
}

static void ustream_state_change_cb(struct uloop_timeout *t)
{
    4998:	51                   	push   %rcx
	struct ustream *s = container_of(t, struct ustream, state_change);

	if (s->write_error)
    4999:	80 7f 71 00          	cmpb   $0x0,0x71(%rdi)
	ustream_free_buffers(&s->r);
	ustream_free_buffers(&s->w);
}

static void ustream_state_change_cb(struct uloop_timeout *t)
{
    499d:	48 89 fb             	mov    %rdi,%rbx
	struct ustream *s = container_of(t, struct ustream, state_change);

	if (s->write_error)
    49a0:	74 09                	je     49ab <ustream_state_change_cb+0x19>
		ustream_free_buffers(&s->w);
    49a2:	48 8d 7d 38          	lea    0x38(%rbp),%rdi
    49a6:	e8 b1 ff ff ff       	callq  495c <ustream_free_buffers>
	if (s->notify_state)
    49ab:	48 8b 43 48          	mov    0x48(%rbx),%rax
    49af:	48 85 c0             	test   %rax,%rax
    49b2:	74 08                	je     49bc <ustream_state_change_cb+0x2a>
		s->notify_state(s);
}
    49b4:	5a                   	pop    %rdx
	struct ustream *s = container_of(t, struct ustream, state_change);

	if (s->write_error)
		ustream_free_buffers(&s->w);
	if (s->notify_state)
		s->notify_state(s);
    49b5:	48 89 ef             	mov    %rbp,%rdi
}
    49b8:	5b                   	pop    %rbx
    49b9:	5d                   	pop    %rbp
	struct ustream *s = container_of(t, struct ustream, state_change);

	if (s->write_error)
		ustream_free_buffers(&s->w);
	if (s->notify_state)
		s->notify_state(s);
    49ba:	ff e0                	jmpq   *%rax
}
    49bc:	58                   	pop    %rax
    49bd:	5b                   	pop    %rbx
    49be:	5d                   	pop    %rbp
    49bf:	c3                   	retq   

00000000000049c0 <__ustream_set_read_blocked>:
	ustream_add_buf(l, buf);
}

static void __ustream_set_read_blocked(struct ustream *s, unsigned char val)
{
	bool changed = !!s->read_blocked != !!val;
    49c0:	83 bf e4 00 00 00 00 	cmpl   $0x0,0xe4(%rdi)

	s->read_blocked = val;
    49c7:	40 0f b6 c6          	movzbl %sil,%eax
    49cb:	89 87 e4 00 00 00    	mov    %eax,0xe4(%rdi)
	ustream_add_buf(l, buf);
}

static void __ustream_set_read_blocked(struct ustream *s, unsigned char val)
{
	bool changed = !!s->read_blocked != !!val;
    49d1:	0f 95 c2             	setne  %dl

	s->read_blocked = val;
	if (changed)
    49d4:	40 84 f6             	test   %sil,%sil
    49d7:	0f 95 c0             	setne  %al
    49da:	38 c2                	cmp    %al,%dl
    49dc:	74 06                	je     49e4 <__ustream_set_read_blocked+0x24>
		s->set_read_blocked(s);
    49de:	ff a7 d0 00 00 00    	jmpq   *0xd0(%rdi)
    49e4:	c3                   	retq   

00000000000049e5 <ustream_write_error>:

	return data;
}

static void ustream_write_error(struct ustream *s)
{
    49e5:	53                   	push   %rbx
	if (!s->write_error)
    49e6:	80 bf e1 00 00 00 00 	cmpb   $0x0,0xe1(%rdi)

	return data;
}

static void ustream_write_error(struct ustream *s)
{
    49ed:	48 89 fb             	mov    %rdi,%rbx
	if (!s->write_error)
    49f0:	75 0b                	jne    49fd <ustream_write_error+0x18>
 */
bool ustream_write_pending(struct ustream *s);

static inline void ustream_state_change(struct ustream *s)
{
	uloop_timeout_set(&s->state_change, 0);
    49f2:	48 8d 7f 70          	lea    0x70(%rdi),%rdi
    49f6:	31 f6                	xor    %esi,%esi
    49f8:	e8 33 db ff ff       	callq  2530 <uloop_timeout_set@plt>
		ustream_state_change(s);
	s->write_error = true;
    49fd:	c6 83 e1 00 00 00 01 	movb   $0x1,0xe1(%rbx)
}
    4a04:	5b                   	pop    %rbx
    4a05:	c3                   	retq   

0000000000004a06 <ustream_alloc_default>:
		l->data_tail = l->head;
}

static bool ustream_can_alloc(struct ustream_buf_list *l)
{
	if (l->max_buffers <= 0)
    4a06:	8b 46 28             	mov    0x28(%rsi),%eax

	return (l->buffers < l->max_buffers);
}

static int ustream_alloc_default(struct ustream *s, struct ustream_buf_list *l)
{
    4a09:	41 54                	push   %r12
    4a0b:	55                   	push   %rbp
    4a0c:	53                   	push   %rbx
		l->data_tail = l->head;
}

static bool ustream_can_alloc(struct ustream_buf_list *l)
{
	if (l->max_buffers <= 0)
    4a0d:	85 c0                	test   %eax,%eax
    4a0f:	7e 05                	jle    4a16 <ustream_alloc_default+0x10>

static int ustream_alloc_default(struct ustream *s, struct ustream_buf_list *l)
{
	struct ustream_buf *buf;

	if (!ustream_can_alloc(l))
    4a11:	3b 46 30             	cmp    0x30(%rsi),%eax
    4a14:	7e 78                	jle    4a8e <ustream_alloc_default+0x88>
		return -1;

	buf = malloc(sizeof(*buf) + l->buffer_len + s->string_data);
    4a16:	48 63 6e 2c          	movslq 0x2c(%rsi),%rbp
    4a1a:	0f b6 87 e0 00 00 00 	movzbl 0xe0(%rdi),%eax
    4a21:	48 89 f3             	mov    %rsi,%rbx
    4a24:	48 8d 7c 05 20       	lea    0x20(%rbp,%rax,1),%rdi
    4a29:	e8 b2 db ff ff       	callq  25e0 <malloc@plt>

#include "ustream.h"

static void ustream_init_buf(struct ustream_buf *buf, int len)
{
	if (!len)
    4a2e:	85 ed                	test   %ebp,%ebp
	struct ustream_buf *buf;

	if (!ustream_can_alloc(l))
		return -1;

	buf = malloc(sizeof(*buf) + l->buffer_len + s->string_data);
    4a30:	48 89 c2             	mov    %rax,%rdx

#include "ustream.h"

static void ustream_init_buf(struct ustream_buf *buf, int len)
{
	if (!len)
    4a33:	75 05                	jne    4a3a <ustream_alloc_default+0x34>
		abort();
    4a35:	e8 36 d9 ff ff       	callq  2370 <abort@plt>
    {
      __warn_memset_zero_len ();
      return __dest;
    }
#endif
  return __builtin___memset_chk (__dest, __ch, __len, __bos0 (__dest));
    4a3a:	31 c0                	xor    %eax,%eax
    4a3c:	b9 08 00 00 00       	mov    $0x8,%ecx
    4a41:	48 89 d7             	mov    %rdx,%rdi
    4a44:	f3 ab                	rep stos %eax,%es:(%rdi)

	memset(buf, 0, sizeof(*buf));
	buf->data = buf->tail = buf->head;
    4a46:	48 8d 42 20          	lea    0x20(%rdx),%rax
	*buf->head = 0;
}

static void ustream_add_buf(struct ustream_buf_list *l, struct ustream_buf *buf)
{
	l->buffers++;
    4a4a:	ff 43 30             	incl   0x30(%rbx)
		abort();

	memset(buf, 0, sizeof(*buf));
	buf->data = buf->tail = buf->head;
	buf->end = buf->head + len;
	*buf->head = 0;
    4a4d:	c6 42 20 00          	movb   $0x0,0x20(%rdx)
	if (!len)
		abort();

	memset(buf, 0, sizeof(*buf));
	buf->data = buf->tail = buf->head;
	buf->end = buf->head + len;
    4a51:	48 01 c5             	add    %rax,%rbp
{
	if (!len)
		abort();

	memset(buf, 0, sizeof(*buf));
	buf->data = buf->tail = buf->head;
    4a54:	48 89 42 10          	mov    %rax,0x10(%rdx)
    4a58:	48 89 42 08          	mov    %rax,0x8(%rdx)
}

static void ustream_add_buf(struct ustream_buf_list *l, struct ustream_buf *buf)
{
	l->buffers++;
	if (!l->tail)
    4a5c:	48 8b 43 10          	mov    0x10(%rbx),%rax
	if (!len)
		abort();

	memset(buf, 0, sizeof(*buf));
	buf->data = buf->tail = buf->head;
	buf->end = buf->head + len;
    4a60:	48 89 6a 18          	mov    %rbp,0x18(%rdx)
}

static void ustream_add_buf(struct ustream_buf_list *l, struct ustream_buf *buf)
{
	l->buffers++;
	if (!l->tail)
    4a64:	48 85 c0             	test   %rax,%rax
    4a67:	75 05                	jne    4a6e <ustream_alloc_default+0x68>
		l->head = buf;
    4a69:	48 89 13             	mov    %rdx,(%rbx)
    4a6c:	eb 03                	jmp    4a71 <ustream_alloc_default+0x6b>
	else
		l->tail->next = buf;
    4a6e:	48 89 10             	mov    %rdx,(%rax)

	buf = malloc(sizeof(*buf) + l->buffer_len + s->string_data);
	ustream_init_buf(buf, l->buffer_len);
	ustream_add_buf(l, buf);

	return 0;
    4a71:	31 c0                	xor    %eax,%eax
	else
		l->tail->next = buf;

	buf->next = NULL;
	l->tail = buf;
	if (!l->data_tail)
    4a73:	48 83 7b 08 00       	cmpq   $0x0,0x8(%rbx)
	if (!l->tail)
		l->head = buf;
	else
		l->tail->next = buf;

	buf->next = NULL;
    4a78:	48 c7 02 00 00 00 00 	movq   $0x0,(%rdx)
	l->tail = buf;
    4a7f:	48 89 53 10          	mov    %rdx,0x10(%rbx)
	if (!l->data_tail)
    4a83:	75 0c                	jne    4a91 <ustream_alloc_default+0x8b>
		l->data_tail = l->head;
    4a85:	48 8b 13             	mov    (%rbx),%rdx
    4a88:	48 89 53 08          	mov    %rdx,0x8(%rbx)
    4a8c:	eb 03                	jmp    4a91 <ustream_alloc_default+0x8b>
static int ustream_alloc_default(struct ustream *s, struct ustream_buf_list *l)
{
	struct ustream_buf *buf;

	if (!ustream_can_alloc(l))
		return -1;
    4a8e:	83 c8 ff             	or     $0xffffffff,%eax
	buf = malloc(sizeof(*buf) + l->buffer_len + s->string_data);
	ustream_init_buf(buf, l->buffer_len);
	ustream_add_buf(l, buf);

	return 0;
}
    4a91:	5b                   	pop    %rbx
    4a92:	5d                   	pop    %rbp
    4a93:	41 5c                	pop    %r12
    4a95:	c3                   	retq   

0000000000004a96 <ustream_free_buf>:
	return (buf->end - buf->tail < len);
}

static void ustream_free_buf(struct ustream_buf_list *l, struct ustream_buf *buf)
{
	if (buf == l->head)
    4a96:	48 39 37             	cmp    %rsi,(%rdi)

	return (buf->end - buf->tail < len);
}

static void ustream_free_buf(struct ustream_buf_list *l, struct ustream_buf *buf)
{
    4a99:	48 89 fa             	mov    %rdi,%rdx
	if (buf == l->head)
    4a9c:	75 06                	jne    4aa4 <ustream_free_buf+0xe>
		l->head = buf->next;
    4a9e:	48 8b 06             	mov    (%rsi),%rax
    4aa1:	48 89 07             	mov    %rax,(%rdi)

	if (buf == l->data_tail)
    4aa4:	48 3b 72 08          	cmp    0x8(%rdx),%rsi
    4aa8:	75 07                	jne    4ab1 <ustream_free_buf+0x1b>
		l->data_tail = buf->next;
    4aaa:	48 8b 06             	mov    (%rsi),%rax
    4aad:	48 89 42 08          	mov    %rax,0x8(%rdx)

	if (buf == l->tail)
    4ab1:	48 3b 72 10          	cmp    0x10(%rdx),%rsi
    4ab5:	75 08                	jne    4abf <ustream_free_buf+0x29>
		l->tail = NULL;
    4ab7:	48 c7 42 10 00 00 00 	movq   $0x0,0x10(%rdx)
    4abe:	00 

	if (--l->buffers >= l->min_buffers) {
    4abf:	8b 42 30             	mov    0x30(%rdx),%eax
    4ac2:	ff c8                	dec    %eax
    4ac4:	3b 42 24             	cmp    0x24(%rdx),%eax
    4ac7:	89 42 30             	mov    %eax,0x30(%rdx)
    4aca:	7c 08                	jl     4ad4 <ustream_free_buf+0x3e>
		free(buf);
    4acc:	48 89 f7             	mov    %rsi,%rdi
    4acf:	e9 8c d8 ff ff       	jmpq   2360 <free@plt>
		return;
	}

	/* recycle */
	ustream_init_buf(buf, buf->end - buf->head);
    4ad4:	4c 8b 46 18          	mov    0x18(%rsi),%r8
    4ad8:	4c 8d 4e 20          	lea    0x20(%rsi),%r9
    4adc:	4d 29 c8             	sub    %r9,%r8

#include "ustream.h"

static void ustream_init_buf(struct ustream_buf *buf, int len)
{
	if (!len)
    4adf:	45 85 c0             	test   %r8d,%r8d
    4ae2:	75 06                	jne    4aea <ustream_free_buf+0x54>

	return (buf->end - buf->tail < len);
}

static void ustream_free_buf(struct ustream_buf_list *l, struct ustream_buf *buf)
{
    4ae4:	50                   	push   %rax
#include "ustream.h"

static void ustream_init_buf(struct ustream_buf *buf, int len)
{
	if (!len)
		abort();
    4ae5:	e8 86 d8 ff ff       	callq  2370 <abort@plt>
    4aea:	31 c0                	xor    %eax,%eax
    4aec:	b9 08 00 00 00       	mov    $0x8,%ecx
    4af1:	48 89 f7             	mov    %rsi,%rdi
    4af4:	f3 ab                	rep stos %eax,%es:(%rdi)

	memset(buf, 0, sizeof(*buf));
	buf->data = buf->tail = buf->head;
	buf->end = buf->head + len;
	*buf->head = 0;
    4af6:	c6 46 20 00          	movb   $0x0,0x20(%rsi)
	if (!len)
		abort();

	memset(buf, 0, sizeof(*buf));
	buf->data = buf->tail = buf->head;
	buf->end = buf->head + len;
    4afa:	4d 63 c0             	movslq %r8d,%r8
{
	if (!len)
		abort();

	memset(buf, 0, sizeof(*buf));
	buf->data = buf->tail = buf->head;
    4afd:	4c 89 4e 10          	mov    %r9,0x10(%rsi)
	buf->end = buf->head + len;
    4b01:	4d 01 c8             	add    %r9,%r8
{
	if (!len)
		abort();

	memset(buf, 0, sizeof(*buf));
	buf->data = buf->tail = buf->head;
    4b04:	4c 89 4e 08          	mov    %r9,0x8(%rsi)
}

static void ustream_add_buf(struct ustream_buf_list *l, struct ustream_buf *buf)
{
	l->buffers++;
	if (!l->tail)
    4b08:	48 8b 42 10          	mov    0x10(%rdx),%rax
	if (!len)
		abort();

	memset(buf, 0, sizeof(*buf));
	buf->data = buf->tail = buf->head;
	buf->end = buf->head + len;
    4b0c:	4c 89 46 18          	mov    %r8,0x18(%rsi)
	*buf->head = 0;
}

static void ustream_add_buf(struct ustream_buf_list *l, struct ustream_buf *buf)
{
	l->buffers++;
    4b10:	ff 42 30             	incl   0x30(%rdx)
	if (!l->tail)
    4b13:	48 85 c0             	test   %rax,%rax
    4b16:	75 05                	jne    4b1d <ustream_free_buf+0x87>
		l->head = buf;
    4b18:	48 89 32             	mov    %rsi,(%rdx)
    4b1b:	eb 03                	jmp    4b20 <ustream_free_buf+0x8a>
	else
		l->tail->next = buf;
    4b1d:	48 89 30             	mov    %rsi,(%rax)

	buf->next = NULL;
	l->tail = buf;
	if (!l->data_tail)
    4b20:	48 83 7a 08 00       	cmpq   $0x0,0x8(%rdx)
	if (!l->tail)
		l->head = buf;
	else
		l->tail->next = buf;

	buf->next = NULL;
    4b25:	48 c7 06 00 00 00 00 	movq   $0x0,(%rsi)
	l->tail = buf;
    4b2c:	48 89 72 10          	mov    %rsi,0x10(%rdx)
	if (!l->data_tail)
    4b30:	75 07                	jne    4b39 <ustream_free_buf+0xa3>
		l->data_tail = l->head;
    4b32:	48 8b 02             	mov    (%rdx),%rax
    4b35:	48 89 42 08          	mov    %rax,0x8(%rdx)
    4b39:	c3                   	retq   

0000000000004b3a <ustream_prepare_buf>:

	*buf->tail = 0;
}

static bool ustream_prepare_buf(struct ustream *s, struct ustream_buf_list *l, int len)
{
    4b3a:	41 55                	push   %r13
    4b3c:	41 54                	push   %r12
    4b3e:	49 89 fd             	mov    %rdi,%r13
    4b41:	55                   	push   %rbp
    4b42:	53                   	push   %rbx
    4b43:	48 89 f3             	mov    %rsi,%rbx
    4b46:	51                   	push   %rcx
	struct ustream_buf *buf;

	buf = l->data_tail;
    4b47:	48 8b 6e 08          	mov    0x8(%rsi),%rbp
	if (buf) {
    4b4b:	48 85 ed             	test   %rbp,%rbp
    4b4e:	0f 84 ab 00 00 00    	je     4bff <ustream_prepare_buf+0xc5>
static bool ustream_should_move(struct ustream_buf_list *l, struct ustream_buf *buf, int len)
{
	int maxlen;
	int offset;

	if (buf->data == buf->head)
    4b54:	48 8b 75 08          	mov    0x8(%rbp),%rsi
    4b58:	4c 8d 45 20          	lea    0x20(%rbp),%r8
    4b5c:	4c 39 c6             	cmp    %r8,%rsi
    4b5f:	0f 84 8c 00 00 00    	je     4bf1 <ustream_prepare_buf+0xb7>
		return false;

	maxlen = buf->end - buf->head;
    4b65:	4c 8b 4d 18          	mov    0x18(%rbp),%r9
	offset = buf->data - buf->head;

	if (offset > maxlen / 2)
    4b69:	b9 02 00 00 00       	mov    $0x2,%ecx
    4b6e:	4c 63 d2             	movslq %edx,%r10

	if (buf->data == buf->head)
		return false;

	maxlen = buf->end - buf->head;
	offset = buf->data - buf->head;
    4b71:	49 89 f3             	mov    %rsi,%r11
    4b74:	4d 29 c3             	sub    %r8,%r11
	int offset;

	if (buf->data == buf->head)
		return false;

	maxlen = buf->end - buf->head;
    4b77:	44 89 cf             	mov    %r9d,%edi
    4b7a:	44 29 c7             	sub    %r8d,%edi
	offset = buf->data - buf->head;

	if (offset > maxlen / 2)
    4b7d:	89 f8                	mov    %edi,%eax
    4b7f:	99                   	cltd   
    4b80:	f7 f9                	idiv   %ecx
    4b82:	48 8b 4d 10          	mov    0x10(%rbp),%rcx
    4b86:	41 39 c3             	cmp    %eax,%r11d
    4b89:	7f 37                	jg     4bc2 <ustream_prepare_buf+0x88>
		return true;

	if (buf->tail - buf->data < 32 && offset > maxlen / 4)
    4b8b:	48 89 c8             	mov    %rcx,%rax
    4b8e:	48 29 f0             	sub    %rsi,%rax
    4b91:	48 83 f8 1f          	cmp    $0x1f,%rax
    4b95:	7f 11                	jg     4ba8 <ustream_prepare_buf+0x6e>
    4b97:	89 f8                	mov    %edi,%eax
    4b99:	41 bc 04 00 00 00    	mov    $0x4,%r12d
    4b9f:	99                   	cltd   
    4ba0:	41 f7 fc             	idiv   %r12d
    4ba3:	41 39 c3             	cmp    %eax,%r11d
    4ba6:	7f 1a                	jg     4bc2 <ustream_prepare_buf+0x88>
		return true;

	if (buf != l->tail || ustream_can_alloc(l))
    4ba8:	48 3b 6b 10          	cmp    0x10(%rbx),%rbp
    4bac:	75 43                	jne    4bf1 <ustream_prepare_buf+0xb7>
		l->data_tail = l->head;
}

static bool ustream_can_alloc(struct ustream_buf_list *l)
{
	if (l->max_buffers <= 0)
    4bae:	8b 43 28             	mov    0x28(%rbx),%eax
    4bb1:	85 c0                	test   %eax,%eax
    4bb3:	7e 3c                	jle    4bf1 <ustream_prepare_buf+0xb7>
		return true;

	if (buf->tail - buf->data < 32 && offset > maxlen / 4)
		return true;

	if (buf != l->tail || ustream_can_alloc(l))
    4bb5:	3b 43 30             	cmp    0x30(%rbx),%eax
    4bb8:	7f 37                	jg     4bf1 <ustream_prepare_buf+0xb7>
{
	struct ustream_buf *buf;

	buf = l->data_tail;
	if (buf) {
		if (ustream_should_move(l, buf, len)) {
    4bba:	49 29 c9             	sub    %rcx,%r9
    4bbd:	4d 39 d1             	cmp    %r10,%r9
    4bc0:	7d 2f                	jge    4bf1 <ustream_prepare_buf+0xb7>
			int len = buf->tail - buf->data;

			memmove(buf->head, buf->data, len);
    4bc2:	48 29 f1             	sub    %rsi,%rcx
}

__fortify_function void *
__NTH (memmove (void *__dest, const void *__src, size_t __len))
{
  return __builtin___memmove_chk (__dest, __src, __len, __bos0 (__dest));
    4bc5:	4c 89 c7             	mov    %r8,%rdi
    4bc8:	4c 63 e1             	movslq %ecx,%r12
    4bcb:	4c 89 e2             	mov    %r12,%rdx
    4bce:	e8 ed da ff ff       	callq  26c0 <memmove@plt>
			buf->data = buf->head;
			buf->tail = buf->data + len;
    4bd3:	49 01 c4             	add    %rax,%r12

			if (l == &s->r)
    4bd6:	4c 39 eb             	cmp    %r13,%rbx
	if (buf) {
		if (ustream_should_move(l, buf, len)) {
			int len = buf->tail - buf->data;

			memmove(buf->head, buf->data, len);
			buf->data = buf->head;
    4bd9:	48 89 45 08          	mov    %rax,0x8(%rbp)
			buf->tail = buf->data + len;
    4bdd:	4c 89 65 10          	mov    %r12,0x10(%rbp)

			if (l == &s->r)
    4be1:	75 0e                	jne    4bf1 <ustream_prepare_buf+0xb7>
	__ustream_set_read_blocked(s, s->read_blocked & ~READ_BLOCKED_FULL);
}

static void ustream_fixup_string(struct ustream *s, struct ustream_buf *buf)
{
	if (!s->string_data)
    4be3:	80 bb e0 00 00 00 00 	cmpb   $0x0,0xe0(%rbx)
    4bea:	74 05                	je     4bf1 <ustream_prepare_buf+0xb7>
		return;

	*buf->tail = 0;
    4bec:	41 c6 04 24 00       	movb   $0x0,(%r12)
			buf->tail = buf->data + len;

			if (l == &s->r)
				ustream_fixup_string(s, buf);
		}
		if (buf->tail != buf->end)
    4bf1:	48 8b 55 18          	mov    0x18(%rbp),%rdx
    4bf5:	48 39 55 10          	cmp    %rdx,0x10(%rbp)
			return true;
    4bf9:	b0 01                	mov    $0x1,%al
			buf->tail = buf->data + len;

			if (l == &s->r)
				ustream_fixup_string(s, buf);
		}
		if (buf->tail != buf->end)
    4bfb:	75 38                	jne    4c35 <ustream_prepare_buf+0xfb>
    4bfd:	eb 29                	jmp    4c28 <ustream_prepare_buf+0xee>
		l->data_tail = l->head;
}

static bool ustream_can_alloc(struct ustream_buf_list *l)
{
	if (l->max_buffers <= 0)
    4bff:	8b 43 28             	mov    0x28(%rbx),%eax
    4c02:	85 c0                	test   %eax,%eax
    4c04:	7e 09                	jle    4c0f <ustream_prepare_buf+0xd5>
	if (buf && buf->next) {
		l->data_tail = buf->next;
		return true;
	}

	if (!ustream_can_alloc(l))
    4c06:	3b 43 30             	cmp    0x30(%rbx),%eax
    4c09:	7f 04                	jg     4c0f <ustream_prepare_buf+0xd5>
		return false;
    4c0b:	31 c0                	xor    %eax,%eax
    4c0d:	eb 26                	jmp    4c35 <ustream_prepare_buf+0xfb>

	if (l->alloc(s, l) < 0)
    4c0f:	48 89 de             	mov    %rbx,%rsi
    4c12:	4c 89 ef             	mov    %r13,%rdi
    4c15:	ff 53 18             	callq  *0x18(%rbx)
    4c18:	85 c0                	test   %eax,%eax
    4c1a:	78 ef                	js     4c0b <ustream_prepare_buf+0xd1>
		return false;

	l->data_tail = l->tail;
    4c1c:	48 8b 43 10          	mov    0x10(%rbx),%rax
    4c20:	48 89 43 08          	mov    %rax,0x8(%rbx)
	return true;
    4c24:	b0 01                	mov    $0x1,%al
    4c26:	eb 0d                	jmp    4c35 <ustream_prepare_buf+0xfb>
		}
		if (buf->tail != buf->end)
			return true;
	}

	if (buf && buf->next) {
    4c28:	48 8b 55 00          	mov    0x0(%rbp),%rdx
    4c2c:	48 85 d2             	test   %rdx,%rdx
    4c2f:	74 ce                	je     4bff <ustream_prepare_buf+0xc5>
		l->data_tail = buf->next;
    4c31:	48 89 53 08          	mov    %rdx,0x8(%rbx)
	if (l->alloc(s, l) < 0)
		return false;

	l->data_tail = l->tail;
	return true;
}
    4c35:	5a                   	pop    %rdx
    4c36:	5b                   	pop    %rbx
    4c37:	5d                   	pop    %rbp
    4c38:	41 5c                	pop    %r12
    4c3a:	41 5d                	pop    %r13
    4c3c:	c3                   	retq   

0000000000004c3d <ustream_write_buffered>:

	return !s->w.data_bytes;
}

static int ustream_write_buffered(struct ustream *s, const char *data, int len, int wr)
{
    4c3d:	41 56                	push   %r14
    4c3f:	41 55                	push   %r13
	struct ustream_buf_list *l = &s->w;
	struct ustream_buf *buf;
	int maxlen;

	while (len) {
		if (!ustream_prepare_buf(s, &s->w, len))
    4c41:	4c 8d 6f 38          	lea    0x38(%rdi),%r13

	return !s->w.data_bytes;
}

static int ustream_write_buffered(struct ustream *s, const char *data, int len, int wr)
{
    4c45:	41 54                	push   %r12
    4c47:	41 89 ce             	mov    %ecx,%r14d
    4c4a:	55                   	push   %rbp
    4c4b:	49 89 f4             	mov    %rsi,%r12
    4c4e:	53                   	push   %rbx
    4c4f:	48 89 fd             	mov    %rdi,%rbp
    4c52:	89 d3                	mov    %edx,%ebx
	struct ustream_buf_list *l = &s->w;
	struct ustream_buf *buf;
	int maxlen;

	while (len) {
    4c54:	85 db                	test   %ebx,%ebx
    4c56:	74 42                	je     4c9a <ustream_write_buffered+0x5d>
		if (!ustream_prepare_buf(s, &s->w, len))
    4c58:	89 da                	mov    %ebx,%edx
    4c5a:	4c 89 ee             	mov    %r13,%rsi
    4c5d:	48 89 ef             	mov    %rbp,%rdi
    4c60:	e8 d5 fe ff ff       	callq  4b3a <ustream_prepare_buf>
    4c65:	84 c0                	test   %al,%al
    4c67:	74 31                	je     4c9a <ustream_write_buffered+0x5d>
			break;

		buf = l->data_tail;
    4c69:	48 8b 55 40          	mov    0x40(%rbp),%rdx

__fortify_function void *
__NTH (memcpy (void *__restrict __dest, const void *__restrict __src,
	       size_t __len))
{
  return __builtin___memcpy_chk (__dest, __src, __len, __bos0 (__dest));
    4c6d:	4c 89 e6             	mov    %r12,%rsi

		maxlen = buf->end - buf->tail;
    4c70:	48 8b 42 18          	mov    0x18(%rdx),%rax
    4c74:	48 2b 42 10          	sub    0x10(%rdx),%rax
    4c78:	48 8b 7a 10          	mov    0x10(%rdx),%rdi
    4c7c:	39 c3                	cmp    %eax,%ebx
    4c7e:	0f 4e c3             	cmovle %ebx,%eax
		if (maxlen > len)
			maxlen = len;

		memcpy(buf->tail, data, maxlen);
    4c81:	4c 63 c0             	movslq %eax,%r8
		buf->tail += maxlen;
		data += maxlen;
		len -= maxlen;
    4c84:	29 c3                	sub    %eax,%ebx
		wr += maxlen;
    4c86:	41 01 c6             	add    %eax,%r14d
    4c89:	4c 89 c1             	mov    %r8,%rcx
    4c8c:	f3 a4                	rep movsb %ds:(%rsi),%es:(%rdi)
		maxlen = buf->end - buf->tail;
		if (maxlen > len)
			maxlen = len;

		memcpy(buf->tail, data, maxlen);
		buf->tail += maxlen;
    4c8e:	4c 01 42 10          	add    %r8,0x10(%rdx)
		data += maxlen;
		len -= maxlen;
		wr += maxlen;
		l->data_bytes += maxlen;
    4c92:	01 45 58             	add    %eax,0x58(%rbp)
		if (maxlen > len)
			maxlen = len;

		memcpy(buf->tail, data, maxlen);
		buf->tail += maxlen;
		data += maxlen;
    4c95:	49 89 f4             	mov    %rsi,%r12
    4c98:	eb ba                	jmp    4c54 <ustream_write_buffered+0x17>
		wr += maxlen;
		l->data_bytes += maxlen;
	}

	return wr;
}
    4c9a:	5b                   	pop    %rbx
    4c9b:	44 89 f0             	mov    %r14d,%eax
    4c9e:	5d                   	pop    %rbp
    4c9f:	41 5c                	pop    %r12
    4ca1:	41 5d                	pop    %r13
    4ca3:	41 5e                	pop    %r14
    4ca5:	c3                   	retq   

0000000000004ca6 <ustream_free>:
	l->tail = NULL;
	l->data_tail = NULL;
}

void ustream_free(struct ustream *s)
{
    4ca6:	53                   	push   %rbx
	if (s->free)
    4ca7:	48 8b 87 c8 00 00 00 	mov    0xc8(%rdi),%rax
	l->tail = NULL;
	l->data_tail = NULL;
}

void ustream_free(struct ustream *s)
{
    4cae:	48 89 fb             	mov    %rdi,%rbx
	if (s->free)
    4cb1:	48 85 c0             	test   %rax,%rax
    4cb4:	74 02                	je     4cb8 <ustream_free+0x12>
		s->free(s);
    4cb6:	ff d0                	callq  *%rax

	uloop_timeout_cancel(&s->state_change);
    4cb8:	48 8d 7b 70          	lea    0x70(%rbx),%rdi
    4cbc:	e8 9f da ff ff       	callq  2760 <uloop_timeout_cancel@plt>
	ustream_free_buffers(&s->r);
    4cc1:	48 89 df             	mov    %rbx,%rdi
    4cc4:	e8 93 fc ff ff       	callq  495c <ustream_free_buffers>
	ustream_free_buffers(&s->w);
    4cc9:	48 8d 7b 38          	lea    0x38(%rbx),%rdi
}
    4ccd:	5b                   	pop    %rbx
	if (s->free)
		s->free(s);

	uloop_timeout_cancel(&s->state_change);
	ustream_free_buffers(&s->r);
	ustream_free_buffers(&s->w);
    4cce:	e9 89 fc ff ff       	jmpq   495c <ustream_free_buffers>

0000000000004cd3 <ustream_init_defaults>:
	do {				\
		if (!_f)		\
			_f = _default;	\
	} while(0)

	DEFAULT_SET(s->r.alloc, ustream_alloc_default);
    4cd3:	48 83 7f 18 00       	cmpq   $0x0,0x18(%rdi)
    4cd8:	75 0b                	jne    4ce5 <ustream_init_defaults+0x12>
    4cda:	48 8d 05 25 fd ff ff 	lea    -0x2db(%rip),%rax        # 4a06 <ustream_alloc_default>
    4ce1:	48 89 47 18          	mov    %rax,0x18(%rdi)
	DEFAULT_SET(s->w.alloc, ustream_alloc_default);
    4ce5:	48 83 7f 50 00       	cmpq   $0x0,0x50(%rdi)
    4cea:	75 0b                	jne    4cf7 <ustream_init_defaults+0x24>
    4cec:	48 8d 05 13 fd ff ff 	lea    -0x2ed(%rip),%rax        # 4a06 <ustream_alloc_default>
    4cf3:	48 89 47 50          	mov    %rax,0x50(%rdi)

	DEFAULT_SET(s->r.min_buffers, 1);
    4cf7:	83 7f 24 00          	cmpl   $0x0,0x24(%rdi)
    4cfb:	75 07                	jne    4d04 <ustream_init_defaults+0x31>
    4cfd:	c7 47 24 01 00 00 00 	movl   $0x1,0x24(%rdi)
	DEFAULT_SET(s->r.max_buffers, 1);
    4d04:	83 7f 28 00          	cmpl   $0x0,0x28(%rdi)
    4d08:	75 07                	jne    4d11 <ustream_init_defaults+0x3e>
    4d0a:	c7 47 28 01 00 00 00 	movl   $0x1,0x28(%rdi)
	DEFAULT_SET(s->r.buffer_len, 4096);
    4d11:	83 7f 2c 00          	cmpl   $0x0,0x2c(%rdi)
    4d15:	75 07                	jne    4d1e <ustream_init_defaults+0x4b>
    4d17:	c7 47 2c 00 10 00 00 	movl   $0x1000,0x2c(%rdi)

	DEFAULT_SET(s->w.min_buffers, 2);
    4d1e:	83 7f 5c 00          	cmpl   $0x0,0x5c(%rdi)
    4d22:	75 07                	jne    4d2b <ustream_init_defaults+0x58>
    4d24:	c7 47 5c 02 00 00 00 	movl   $0x2,0x5c(%rdi)
	DEFAULT_SET(s->w.max_buffers, -1);
    4d2b:	83 7f 60 00          	cmpl   $0x0,0x60(%rdi)
    4d2f:	75 07                	jne    4d38 <ustream_init_defaults+0x65>
    4d31:	c7 47 60 ff ff ff ff 	movl   $0xffffffff,0x60(%rdi)
	DEFAULT_SET(s->w.buffer_len, 256);
    4d38:	83 7f 64 00          	cmpl   $0x0,0x64(%rdi)
    4d3c:	75 07                	jne    4d45 <ustream_init_defaults+0x72>
    4d3e:	c7 47 64 00 01 00 00 	movl   $0x100,0x64(%rdi)

#undef DEFAULT_SET

	s->state_change.cb = ustream_state_change_cb;
    4d45:	48 8d 05 46 fc ff ff 	lea    -0x3ba(%rip),%rax        # 4992 <ustream_state_change_cb>
	s->write_error = false;
    4d4c:	c6 87 e1 00 00 00 00 	movb   $0x0,0xe1(%rdi)
	s->eof = false;
    4d53:	c6 87 e2 00 00 00 00 	movb   $0x0,0xe2(%rdi)
	s->eof_write_done = false;
    4d5a:	c6 87 e3 00 00 00 00 	movb   $0x0,0xe3(%rdi)
	s->read_blocked = 0;
    4d61:	c7 87 e4 00 00 00 00 	movl   $0x0,0xe4(%rdi)
    4d68:	00 00 00 
	DEFAULT_SET(s->w.max_buffers, -1);
	DEFAULT_SET(s->w.buffer_len, 256);

#undef DEFAULT_SET

	s->state_change.cb = ustream_state_change_cb;
    4d6b:	48 89 87 88 00 00 00 	mov    %rax,0x88(%rdi)
	s->write_error = false;
	s->eof = false;
	s->eof_write_done = false;
	s->read_blocked = 0;

	s->r.buffers = 0;
    4d72:	c7 47 30 00 00 00 00 	movl   $0x0,0x30(%rdi)
	s->r.data_bytes = 0;
    4d79:	c7 47 20 00 00 00 00 	movl   $0x0,0x20(%rdi)

	s->w.buffers = 0;
    4d80:	c7 47 68 00 00 00 00 	movl   $0x0,0x68(%rdi)
	s->w.data_bytes = 0;
    4d87:	c7 47 58 00 00 00 00 	movl   $0x0,0x58(%rdi)
    4d8e:	c3                   	retq   

0000000000004d8f <ustream_set_read_blocked>:
		s->set_read_blocked(s);
}

void ustream_set_read_blocked(struct ustream *s, bool set)
{
	unsigned char val = s->read_blocked & ~READ_BLOCKED_USER;
    4d8f:	8a 87 e4 00 00 00    	mov    0xe4(%rdi),%al
    4d95:	83 e0 fe             	and    $0xfffffffe,%eax

	if (set)
		val |= READ_BLOCKED_USER;
    4d98:	88 c2                	mov    %al,%dl
    4d9a:	83 ca 01             	or     $0x1,%edx
    4d9d:	40 84 f6             	test   %sil,%sil
    4da0:	0f 45 c2             	cmovne %edx,%eax

	__ustream_set_read_blocked(s, val);
    4da3:	0f b6 f0             	movzbl %al,%esi
    4da6:	e9 15 fc ff ff       	jmpq   49c0 <__ustream_set_read_blocked>

0000000000004dab <ustream_consume>:

void ustream_consume(struct ustream *s, int len)
{
	struct ustream_buf *buf = s->r.head;

	if (!len)
    4dab:	85 f6                	test   %esi,%esi
    4dad:	74 5b                	je     4e0a <ustream_consume+0x5f>

	__ustream_set_read_blocked(s, val);
}

void ustream_consume(struct ustream *s, int len)
{
    4daf:	41 54                	push   %r12
    4db1:	55                   	push   %rbp
    4db2:	48 89 fd             	mov    %rdi,%rbp
    4db5:	53                   	push   %rbx
    4db6:	89 f3                	mov    %esi,%ebx

	if (!len)
		return;

	s->r.data_bytes -= len;
	if (s->r.data_bytes < 0)
    4db8:	29 5f 20             	sub    %ebx,0x20(%rdi)
	__ustream_set_read_blocked(s, val);
}

void ustream_consume(struct ustream *s, int len)
{
	struct ustream_buf *buf = s->r.head;
    4dbb:	48 8b 37             	mov    (%rdi),%rsi

	if (!len)
		return;

	s->r.data_bytes -= len;
	if (s->r.data_bytes < 0)
    4dbe:	79 16                	jns    4dd6 <ustream_consume+0x2b>
		abort();
    4dc0:	e8 ab d5 ff ff       	callq  2370 <abort@plt>
		if (len < buf_len) {
			buf->data += len;
			break;
		}

		len -= buf_len;
    4dc5:	29 c3                	sub    %eax,%ebx
		ustream_free_buf(&s->r, buf);
    4dc7:	48 89 ef             	mov    %rbp,%rdi
    4dca:	e8 c7 fc ff ff       	callq  4a96 <ustream_free_buf>
		buf = next;
	} while(len);
    4dcf:	85 db                	test   %ebx,%ebx
			break;
		}

		len -= buf_len;
		ustream_free_buf(&s->r, buf);
		buf = next;
    4dd1:	4c 89 e6             	mov    %r12,%rsi
	} while(len);
    4dd4:	74 1c                	je     4df2 <ustream_consume+0x47>
	if (s->r.data_bytes < 0)
		abort();

	do {
		struct ustream_buf *next = buf->next;
		int buf_len = buf->tail - buf->data;
    4dd6:	48 8b 56 08          	mov    0x8(%rsi),%rdx
    4dda:	48 8b 46 10          	mov    0x10(%rsi),%rax
	s->r.data_bytes -= len;
	if (s->r.data_bytes < 0)
		abort();

	do {
		struct ustream_buf *next = buf->next;
    4dde:	4c 8b 26             	mov    (%rsi),%r12
		int buf_len = buf->tail - buf->data;
    4de1:	48 29 d0             	sub    %rdx,%rax

		if (len < buf_len) {
    4de4:	39 c3                	cmp    %eax,%ebx
    4de6:	7d dd                	jge    4dc5 <ustream_consume+0x1a>
			buf->data += len;
    4de8:	48 63 db             	movslq %ebx,%rbx
    4deb:	48 01 d3             	add    %rdx,%rbx
    4dee:	48 89 5e 08          	mov    %rbx,0x8(%rsi)
		len -= buf_len;
		ustream_free_buf(&s->r, buf);
		buf = next;
	} while(len);

	__ustream_set_read_blocked(s, s->read_blocked & ~READ_BLOCKED_FULL);
    4df2:	8b b5 e4 00 00 00    	mov    0xe4(%rbp),%esi
    4df8:	48 89 ef             	mov    %rbp,%rdi
}
    4dfb:	5b                   	pop    %rbx
    4dfc:	5d                   	pop    %rbp
    4dfd:	41 5c                	pop    %r12
		len -= buf_len;
		ustream_free_buf(&s->r, buf);
		buf = next;
	} while(len);

	__ustream_set_read_blocked(s, s->read_blocked & ~READ_BLOCKED_FULL);
    4dff:	81 e6 fd 00 00 00    	and    $0xfd,%esi
    4e05:	e9 b6 fb ff ff       	jmpq   49c0 <__ustream_set_read_blocked>
    4e0a:	c3                   	retq   

0000000000004e0b <ustream_reserve>:
	l->data_tail = l->tail;
	return true;
}

char *ustream_reserve(struct ustream *s, int len, int *maxlen)
{
    4e0b:	55                   	push   %rbp
    4e0c:	53                   	push   %rbx
    4e0d:	48 89 d5             	mov    %rdx,%rbp
    4e10:	51                   	push   %rcx
	struct ustream_buf *buf = s->r.head;

	if (!ustream_prepare_buf(s, &s->r, len)) {
    4e11:	89 f2                	mov    %esi,%edx
    4e13:	48 89 fe             	mov    %rdi,%rsi
	l->data_tail = l->tail;
	return true;
}

char *ustream_reserve(struct ustream *s, int len, int *maxlen)
{
    4e16:	48 89 fb             	mov    %rdi,%rbx
	struct ustream_buf *buf = s->r.head;

	if (!ustream_prepare_buf(s, &s->r, len)) {
    4e19:	e8 1c fd ff ff       	callq  4b3a <ustream_prepare_buf>
    4e1e:	84 c0                	test   %al,%al
    4e20:	75 21                	jne    4e43 <ustream_reserve+0x38>
		__ustream_set_read_blocked(s, s->read_blocked | READ_BLOCKED_FULL);
    4e22:	40 8a b3 e4 00 00 00 	mov    0xe4(%rbx),%sil
    4e29:	48 89 df             	mov    %rbx,%rdi
    4e2c:	83 ce 02             	or     $0x2,%esi
    4e2f:	40 0f b6 f6          	movzbl %sil,%esi
    4e33:	e8 88 fb ff ff       	callq  49c0 <__ustream_set_read_blocked>
		*maxlen = 0;
    4e38:	c7 45 00 00 00 00 00 	movl   $0x0,0x0(%rbp)
		return NULL;
    4e3f:	31 c0                	xor    %eax,%eax
    4e41:	eb 12                	jmp    4e55 <ustream_reserve+0x4a>
	}

	buf = s->r.data_tail;
    4e43:	48 8b 53 08          	mov    0x8(%rbx),%rdx
	*maxlen = buf->end - buf->tail;
    4e47:	48 8b 42 10          	mov    0x10(%rdx),%rax
    4e4b:	48 8b 52 18          	mov    0x18(%rdx),%rdx
    4e4f:	48 29 c2             	sub    %rax,%rdx
    4e52:	89 55 00             	mov    %edx,0x0(%rbp)
	return buf->tail;
}
    4e55:	5a                   	pop    %rdx
    4e56:	5b                   	pop    %rbx
    4e57:	5d                   	pop    %rbp
    4e58:	c3                   	retq   

0000000000004e59 <ustream_fill_read>:
{
	struct ustream_buf *buf = s->r.data_tail;
	int n = len;
	int maxlen;

	s->r.data_bytes += len;
    4e59:	01 77 20             	add    %esi,0x20(%rdi)
	return buf->tail;
}

void ustream_fill_read(struct ustream *s, int len)
{
	struct ustream_buf *buf = s->r.data_tail;
    4e5c:	48 8b 4f 08          	mov    0x8(%rdi),%rcx
	int n = len;
	int maxlen;

	s->r.data_bytes += len;
    4e60:	41 89 f0             	mov    %esi,%r8d
	do {
		if (!buf)
    4e63:	48 85 c9             	test   %rcx,%rcx
    4e66:	75 06                	jne    4e6e <ustream_fill_read+0x15>
	*maxlen = buf->end - buf->tail;
	return buf->tail;
}

void ustream_fill_read(struct ustream *s, int len)
{
    4e68:	50                   	push   %rax
	int maxlen;

	s->r.data_bytes += len;
	do {
		if (!buf)
			abort();
    4e69:	e8 02 d5 ff ff       	callq  2370 <abort@plt>

		maxlen = buf->end - buf->tail;
    4e6e:	48 8b 41 10          	mov    0x10(%rcx),%rax
    4e72:	48 8b 51 18          	mov    0x18(%rcx),%rdx
    4e76:	48 29 c2             	sub    %rax,%rdx
    4e79:	41 39 d0             	cmp    %edx,%r8d
    4e7c:	41 0f 4e d0          	cmovle %r8d,%edx
		if (len < maxlen)
			maxlen = len;

		len -= maxlen;
    4e80:	41 29 d0             	sub    %edx,%r8d
		buf->tail += maxlen;
    4e83:	48 63 d2             	movslq %edx,%rdx
    4e86:	48 01 d0             	add    %rdx,%rax
	__ustream_set_read_blocked(s, s->read_blocked & ~READ_BLOCKED_FULL);
}

static void ustream_fixup_string(struct ustream *s, struct ustream_buf *buf)
{
	if (!s->string_data)
    4e89:	80 bf e0 00 00 00 00 	cmpb   $0x0,0xe0(%rdi)
		maxlen = buf->end - buf->tail;
		if (len < maxlen)
			maxlen = len;

		len -= maxlen;
		buf->tail += maxlen;
    4e90:	48 89 41 10          	mov    %rax,0x10(%rcx)
	__ustream_set_read_blocked(s, s->read_blocked & ~READ_BLOCKED_FULL);
}

static void ustream_fixup_string(struct ustream *s, struct ustream_buf *buf)
{
	if (!s->string_data)
    4e94:	74 03                	je     4e99 <ustream_fill_read+0x40>
		return;

	*buf->tail = 0;
    4e96:	c6 00 00             	movb   $0x0,(%rax)
		buf->tail += maxlen;
		ustream_fixup_string(s, buf);

		s->r.data_tail = buf;
		buf = buf->next;
	} while (len);
    4e99:	45 85 c0             	test   %r8d,%r8d

		len -= maxlen;
		buf->tail += maxlen;
		ustream_fixup_string(s, buf);

		s->r.data_tail = buf;
    4e9c:	48 89 4f 08          	mov    %rcx,0x8(%rdi)
		buf = buf->next;
    4ea0:	48 8b 09             	mov    (%rcx),%rcx
	} while (len);
    4ea3:	75 be                	jne    4e63 <ustream_fill_read+0xa>

	if (s->notify_read)
    4ea5:	48 8b 87 a8 00 00 00 	mov    0xa8(%rdi),%rax
    4eac:	48 85 c0             	test   %rax,%rax
    4eaf:	74 02                	je     4eb3 <ustream_fill_read+0x5a>
		s->notify_read(s, n);
    4eb1:	ff e0                	jmpq   *%rax
    4eb3:	c3                   	retq   

0000000000004eb4 <ustream_get_read_buf>:
char *ustream_get_read_buf(struct ustream *s, int *buflen)
{
	char *data = NULL;
	int len = 0;

	if (s->r.head) {
    4eb4:	48 8b 17             	mov    (%rdi),%rdx
    4eb7:	48 85 d2             	test   %rdx,%rdx
    4eba:	74 1a                	je     4ed6 <ustream_get_read_buf+0x22>
		len = s->r.head->tail - s->r.head->data;
    4ebc:	48 8b 42 08          	mov    0x8(%rdx),%rax
    4ec0:	48 8b 52 10          	mov    0x10(%rdx),%rdx
    4ec4:	48 29 c2             	sub    %rax,%rdx
		s->notify_read(s, n);
}

char *ustream_get_read_buf(struct ustream *s, int *buflen)
{
	char *data = NULL;
    4ec7:	85 d2                	test   %edx,%edx
	int len = 0;

	if (s->r.head) {
		len = s->r.head->tail - s->r.head->data;
    4ec9:	89 d1                	mov    %edx,%ecx
		s->notify_read(s, n);
}

char *ustream_get_read_buf(struct ustream *s, int *buflen)
{
	char *data = NULL;
    4ecb:	ba 00 00 00 00       	mov    $0x0,%edx
    4ed0:	48 0f 4e c2          	cmovle %rdx,%rax
    4ed4:	eb 04                	jmp    4eda <ustream_get_read_buf+0x26>
	int len = 0;
    4ed6:	31 c9                	xor    %ecx,%ecx
		s->notify_read(s, n);
}

char *ustream_get_read_buf(struct ustream *s, int *buflen)
{
	char *data = NULL;
    4ed8:	31 c0                	xor    %eax,%eax
		len = s->r.head->tail - s->r.head->data;
		if (len > 0)
			data = s->r.head->data;
	}

	if (buflen)
    4eda:	48 85 f6             	test   %rsi,%rsi
    4edd:	74 02                	je     4ee1 <ustream_get_read_buf+0x2d>
		*buflen = len;
    4edf:	89 0e                	mov    %ecx,(%rsi)

	return data;
}
    4ee1:	c3                   	retq   

0000000000004ee2 <ustream_write_pending>:
bool ustream_write_pending(struct ustream *s)
{
	struct ustream_buf *buf = s->w.head;
	int wr = 0, len;

	if (s->write_error)
    4ee2:	80 bf e1 00 00 00 00 	cmpb   $0x0,0xe1(%rdi)
    4ee9:	0f 85 c0 00 00 00    	jne    4faf <ustream_write_pending+0xcd>
		ustream_state_change(s);
	s->write_error = true;
}

bool ustream_write_pending(struct ustream *s)
{
    4eef:	41 57                	push   %r15
    4ef1:	41 56                	push   %r14
		if (len < maxlen) {
			buf->data += len;
			break;
		}

		ustream_free_buf(&s->w, buf);
    4ef3:	4c 8d 7f 38          	lea    0x38(%rdi),%r15
		ustream_state_change(s);
	s->write_error = true;
}

bool ustream_write_pending(struct ustream *s)
{
    4ef7:	41 55                	push   %r13
    4ef9:	41 54                	push   %r12
	struct ustream_buf *buf = s->w.head;
    4efb:	45 31 e4             	xor    %r12d,%r12d
		ustream_state_change(s);
	s->write_error = true;
}

bool ustream_write_pending(struct ustream *s)
{
    4efe:	55                   	push   %rbp
    4eff:	53                   	push   %rbx
    4f00:	48 89 fb             	mov    %rdi,%rbx
    4f03:	51                   	push   %rcx
	struct ustream_buf *buf = s->w.head;
    4f04:	48 8b 6f 38          	mov    0x38(%rdi),%rbp
	int wr = 0, len;

	if (s->write_error)
		return false;

	while (buf && s->w.data_bytes) {
    4f08:	48 85 ed             	test   %rbp,%rbp
    4f0b:	74 5c                	je     4f69 <ustream_write_pending+0x87>
    4f0d:	83 7b 58 00          	cmpl   $0x0,0x58(%rbx)
    4f11:	74 56                	je     4f69 <ustream_write_pending+0x87>
		struct ustream_buf *next = buf->next;
    4f13:	4c 8b 75 00          	mov    0x0(%rbp),%r14
		int maxlen = buf->tail - buf->data;
    4f17:	48 8b 75 08          	mov    0x8(%rbp),%rsi

		len = s->write(s, buf->data, maxlen, !!buf->next);
    4f1b:	31 c9                	xor    %ecx,%ecx
	if (s->write_error)
		return false;

	while (buf && s->w.data_bytes) {
		struct ustream_buf *next = buf->next;
		int maxlen = buf->tail - buf->data;
    4f1d:	4c 8b 6d 10          	mov    0x10(%rbp),%r13

		len = s->write(s, buf->data, maxlen, !!buf->next);
    4f21:	48 89 df             	mov    %rbx,%rdi
	if (s->write_error)
		return false;

	while (buf && s->w.data_bytes) {
		struct ustream_buf *next = buf->next;
		int maxlen = buf->tail - buf->data;
    4f24:	49 29 f5             	sub    %rsi,%r13

		len = s->write(s, buf->data, maxlen, !!buf->next);
    4f27:	4d 85 f6             	test   %r14,%r14
    4f2a:	0f 95 c1             	setne  %cl
    4f2d:	44 89 ea             	mov    %r13d,%edx
    4f30:	ff 93 c0 00 00 00    	callq  *0xc0(%rbx)
		if (len < 0) {
    4f36:	85 c0                	test   %eax,%eax
    4f38:	79 0a                	jns    4f44 <ustream_write_pending+0x62>
			ustream_write_error(s);
    4f3a:	48 89 df             	mov    %rbx,%rdi
    4f3d:	e8 a3 fa ff ff       	callq  49e5 <ustream_write_error>
			break;
    4f42:	eb 25                	jmp    4f69 <ustream_write_pending+0x87>
		}

		if (len == 0)
    4f44:	74 23                	je     4f69 <ustream_write_pending+0x87>
			break;

		wr += len;
    4f46:	41 01 c4             	add    %eax,%r12d
		s->w.data_bytes -= len;
    4f49:	29 43 58             	sub    %eax,0x58(%rbx)
		if (len < maxlen) {
    4f4c:	41 39 c5             	cmp    %eax,%r13d
    4f4f:	7e 08                	jle    4f59 <ustream_write_pending+0x77>
			buf->data += len;
    4f51:	48 98                	cltq   
    4f53:	48 01 45 08          	add    %rax,0x8(%rbp)
			break;
    4f57:	eb 10                	jmp    4f69 <ustream_write_pending+0x87>
		}

		ustream_free_buf(&s->w, buf);
    4f59:	48 89 ee             	mov    %rbp,%rsi
    4f5c:	4c 89 ff             	mov    %r15,%rdi
		buf = next;
    4f5f:	4c 89 f5             	mov    %r14,%rbp
		if (len < maxlen) {
			buf->data += len;
			break;
		}

		ustream_free_buf(&s->w, buf);
    4f62:	e8 2f fb ff ff       	callq  4a96 <ustream_free_buf>
    4f67:	eb 9f                	jmp    4f08 <ustream_write_pending+0x26>
		buf = next;
	}

	if (s->notify_write)
    4f69:	48 8b 83 b0 00 00 00 	mov    0xb0(%rbx),%rax
    4f70:	48 85 c0             	test   %rax,%rax
    4f73:	74 08                	je     4f7d <ustream_write_pending+0x9b>
		s->notify_write(s, wr);
    4f75:	44 89 e6             	mov    %r12d,%esi
    4f78:	48 89 df             	mov    %rbx,%rdi
    4f7b:	ff d0                	callq  *%rax

	if (s->eof && wr && !s->w.data_bytes)
    4f7d:	80 bb e2 00 00 00 00 	cmpb   $0x0,0xe2(%rbx)
    4f84:	74 16                	je     4f9c <ustream_write_pending+0xba>
    4f86:	45 85 e4             	test   %r12d,%r12d
    4f89:	74 11                	je     4f9c <ustream_write_pending+0xba>
    4f8b:	83 7b 58 00          	cmpl   $0x0,0x58(%rbx)
    4f8f:	75 0b                	jne    4f9c <ustream_write_pending+0xba>
    4f91:	48 8d 7b 70          	lea    0x70(%rbx),%rdi
    4f95:	31 f6                	xor    %esi,%esi
    4f97:	e8 94 d5 ff ff       	callq  2530 <uloop_timeout_set@plt>
		ustream_state_change(s);

	return !s->w.data_bytes;
    4f9c:	83 7b 58 00          	cmpl   $0x0,0x58(%rbx)
}
    4fa0:	5a                   	pop    %rdx
    4fa1:	5b                   	pop    %rbx
    4fa2:	5d                   	pop    %rbp
		s->notify_write(s, wr);

	if (s->eof && wr && !s->w.data_bytes)
		ustream_state_change(s);

	return !s->w.data_bytes;
    4fa3:	0f 94 c0             	sete   %al
}
    4fa6:	41 5c                	pop    %r12
    4fa8:	41 5d                	pop    %r13
    4faa:	41 5e                	pop    %r14
    4fac:	41 5f                	pop    %r15
    4fae:	c3                   	retq   
    4faf:	31 c0                	xor    %eax,%eax
    4fb1:	c3                   	retq   

0000000000004fb2 <ustream_write>:
int ustream_write(struct ustream *s, const char *data, int len, bool more)
{
	struct ustream_buf_list *l = &s->w;
	int wr = 0;

	if (s->write_error)
    4fb2:	80 bf e1 00 00 00 00 	cmpb   $0x0,0xe1(%rdi)
    4fb9:	75 5c                	jne    5017 <ustream_write+0x65>

	return wr;
}

int ustream_write(struct ustream *s, const char *data, int len, bool more)
{
    4fbb:	41 55                	push   %r13
    4fbd:	41 54                	push   %r12
    4fbf:	49 89 f4             	mov    %rsi,%r12
    4fc2:	55                   	push   %rbp
    4fc3:	53                   	push   %rbx
    4fc4:	48 89 fd             	mov    %rdi,%rbp
    4fc7:	41 51                	push   %r9
	int wr = 0;

	if (s->write_error)
		return 0;

	if (!l->data_bytes) {
    4fc9:	83 7f 58 00          	cmpl   $0x0,0x58(%rdi)
    4fcd:	89 d3                	mov    %edx,%ebx
    4fcf:	75 2b                	jne    4ffc <ustream_write+0x4a>
		wr = s->write(s, data, len, more);
    4fd1:	0f b6 c9             	movzbl %cl,%ecx
    4fd4:	ff 97 c0 00 00 00    	callq  *0xc0(%rdi)
		if (wr == len)
    4fda:	39 c3                	cmp    %eax,%ebx

	if (s->write_error)
		return 0;

	if (!l->data_bytes) {
		wr = s->write(s, data, len, more);
    4fdc:	41 89 c5             	mov    %eax,%r13d
		if (wr == len)
    4fdf:	74 39                	je     501a <ustream_write+0x68>
			return wr;

		if (wr < 0) {
    4fe1:	85 c0                	test   %eax,%eax
    4fe3:	79 0d                	jns    4ff2 <ustream_write+0x40>
			ustream_write_error(s);
    4fe5:	48 89 ef             	mov    %rbp,%rdi
    4fe8:	e8 f8 f9 ff ff       	callq  49e5 <ustream_write_error>
    4fed:	44 89 e8             	mov    %r13d,%eax
    4ff0:	eb 2a                	jmp    501c <ustream_write+0x6a>
			return wr;
		}

		data += wr;
    4ff2:	48 63 d0             	movslq %eax,%rdx
		len -= wr;
    4ff5:	29 c3                	sub    %eax,%ebx
		if (wr < 0) {
			ustream_write_error(s);
			return wr;
		}

		data += wr;
    4ff7:	49 01 d4             	add    %rdx,%r12
    4ffa:	eb 03                	jmp    4fff <ustream_write+0x4d>
}

int ustream_write(struct ustream *s, const char *data, int len, bool more)
{
	struct ustream_buf_list *l = &s->w;
	int wr = 0;
    4ffc:	45 31 ed             	xor    %r13d,%r13d
		data += wr;
		len -= wr;
	}

	return ustream_write_buffered(s, data, len, wr);
}
    4fff:	41 58                	pop    %r8

		data += wr;
		len -= wr;
	}

	return ustream_write_buffered(s, data, len, wr);
    5001:	44 89 e9             	mov    %r13d,%ecx
    5004:	89 da                	mov    %ebx,%edx
    5006:	4c 89 e6             	mov    %r12,%rsi
}
    5009:	5b                   	pop    %rbx

		data += wr;
		len -= wr;
	}

	return ustream_write_buffered(s, data, len, wr);
    500a:	48 89 ef             	mov    %rbp,%rdi
}
    500d:	5d                   	pop    %rbp
    500e:	41 5c                	pop    %r12
    5010:	41 5d                	pop    %r13

		data += wr;
		len -= wr;
	}

	return ustream_write_buffered(s, data, len, wr);
    5012:	e9 26 fc ff ff       	jmpq   4c3d <ustream_write_buffered>
{
	struct ustream_buf_list *l = &s->w;
	int wr = 0;

	if (s->write_error)
		return 0;
    5017:	31 c0                	xor    %eax,%eax
		data += wr;
		len -= wr;
	}

	return ustream_write_buffered(s, data, len, wr);
}
    5019:	c3                   	retq   
	if (s->write_error)
		return 0;

	if (!l->data_bytes) {
		wr = s->write(s, data, len, more);
		if (wr == len)
    501a:	89 d8                	mov    %ebx,%eax
		data += wr;
		len -= wr;
	}

	return ustream_write_buffered(s, data, len, wr);
}
    501c:	5a                   	pop    %rdx
    501d:	5b                   	pop    %rbx
    501e:	5d                   	pop    %rbp
    501f:	41 5c                	pop    %r12
    5021:	41 5d                	pop    %r13
    5023:	c3                   	retq   

0000000000005024 <ustream_vprintf>:

#define MAX_STACK_BUFLEN	256

int ustream_vprintf(struct ustream *s, const char *format, va_list arg)
{
    5024:	55                   	push   %rbp
    5025:	48 89 e5             	mov    %rsp,%rbp
    5028:	41 57                	push   %r15
    502a:	41 56                	push   %r14
    502c:	41 55                	push   %r13
    502e:	41 54                	push   %r12
    5030:	53                   	push   %rbx
    5031:	48 83 ec 38          	sub    $0x38,%rsp
    5035:	64 48 8b 04 25 28 00 	mov    %fs:0x28,%rax
    503c:	00 00 
    503e:	48 89 45 c8          	mov    %rax,-0x38(%rbp)
    5042:	31 c0                	xor    %eax,%eax
	struct ustream_buf_list *l = &s->w;
	char *buf;
	va_list arg2;
	int wr, maxlen, buflen;

	if (s->write_error)
    5044:	80 bf e1 00 00 00 00 	cmpb   $0x0,0xe1(%rdi)
    504b:	74 07                	je     5054 <ustream_vprintf+0x30>
		return 0;
    504d:	31 db                	xor    %ebx,%ebx
    504f:	e9 a2 01 00 00       	jmpq   51f6 <ustream_vprintf+0x1d2>

	if (!l->data_bytes) {
    5054:	83 7f 58 00          	cmpl   $0x0,0x58(%rdi)
    5058:	49 89 fc             	mov    %rdi,%r12
    505b:	49 89 f6             	mov    %rsi,%r14
    505e:	49 89 d5             	mov    %rdx,%r13
    5061:	0f 85 ce 00 00 00    	jne    5135 <ustream_vprintf+0x111>
		buf = alloca(MAX_STACK_BUFLEN);
		va_copy(arg2, arg);
    5067:	4c 8d 4d b0          	lea    -0x50(%rbp),%r9
    506b:	48 89 d6             	mov    %rdx,%rsi
    506e:	b9 06 00 00 00       	mov    $0x6,%ecx

	if (s->write_error)
		return 0;

	if (!l->data_bytes) {
		buf = alloca(MAX_STACK_BUFLEN);
    5073:	48 81 ec 10 01 00 00 	sub    $0x110,%rsp

__fortify_function int
__NTH (vsnprintf (char *__restrict __s, size_t __n,
		  const char *__restrict __fmt, _G_va_list __ap))
{
  return __builtin___vsnprintf_chk (__s, __n, __USE_FORTIFY_LEVEL - 1,
    507a:	4d 89 f0             	mov    %r14,%r8
    507d:	ba 01 00 00 00       	mov    $0x1,%edx
		va_copy(arg2, arg);
    5082:	4c 89 cf             	mov    %r9,%rdi

	if (s->write_error)
		return 0;

	if (!l->data_bytes) {
		buf = alloca(MAX_STACK_BUFLEN);
    5085:	4c 8d 7c 24 0f       	lea    0xf(%rsp),%r15
		va_copy(arg2, arg);
    508a:	f3 a5                	rep movsl %ds:(%rsi),%es:(%rdi)

	if (s->write_error)
		return 0;

	if (!l->data_bytes) {
		buf = alloca(MAX_STACK_BUFLEN);
    508c:	49 83 e7 f0          	and    $0xfffffffffffffff0,%r15
    5090:	b9 00 01 00 00       	mov    $0x100,%ecx
    5095:	be 00 01 00 00       	mov    $0x100,%esi
    509a:	4c 89 ff             	mov    %r15,%rdi
    509d:	e8 6e d5 ff ff       	callq  2610 <__vsnprintf_chk@plt>
		va_copy(arg2, arg);
		maxlen = vsnprintf(buf, MAX_STACK_BUFLEN, format, arg2);
		va_end(arg2);
		if (maxlen < MAX_STACK_BUFLEN) {
    50a2:	3d ff 00 00 00       	cmp    $0xff,%eax
    50a7:	89 c3                	mov    %eax,%ebx
    50a9:	7f 4c                	jg     50f7 <ustream_vprintf+0xd3>
			wr = s->write(s, buf, maxlen, false);
    50ab:	31 c9                	xor    %ecx,%ecx
    50ad:	89 c2                	mov    %eax,%edx
    50af:	4c 89 fe             	mov    %r15,%rsi
    50b2:	4c 89 e7             	mov    %r12,%rdi
    50b5:	41 ff 94 24 c0 00 00 	callq  *0xc0(%r12)
    50bc:	00 
			if (wr < 0) {
    50bd:	85 c0                	test   %eax,%eax
		buf = alloca(MAX_STACK_BUFLEN);
		va_copy(arg2, arg);
		maxlen = vsnprintf(buf, MAX_STACK_BUFLEN, format, arg2);
		va_end(arg2);
		if (maxlen < MAX_STACK_BUFLEN) {
			wr = s->write(s, buf, maxlen, false);
    50bf:	41 89 c5             	mov    %eax,%r13d
			if (wr < 0) {
    50c2:	79 10                	jns    50d4 <ustream_vprintf+0xb0>
				ustream_write_error(s);
    50c4:	4c 89 e7             	mov    %r12,%rdi
				return wr;
    50c7:	44 89 eb             	mov    %r13d,%ebx
		maxlen = vsnprintf(buf, MAX_STACK_BUFLEN, format, arg2);
		va_end(arg2);
		if (maxlen < MAX_STACK_BUFLEN) {
			wr = s->write(s, buf, maxlen, false);
			if (wr < 0) {
				ustream_write_error(s);
    50ca:	e8 16 f9 ff ff       	callq  49e5 <ustream_write_error>
				return wr;
    50cf:	e9 22 01 00 00       	jmpq   51f6 <ustream_vprintf+0x1d2>
			}
			if (wr == maxlen)
    50d4:	39 d8                	cmp    %ebx,%eax
    50d6:	0f 84 1a 01 00 00    	je     51f6 <ustream_vprintf+0x1d2>
				return wr;

			buf += wr;
			maxlen -= wr;
			return ustream_write_buffered(s, buf, maxlen, wr);
    50dc:	89 da                	mov    %ebx,%edx
    50de:	48 63 f0             	movslq %eax,%rsi
    50e1:	89 c1                	mov    %eax,%ecx
    50e3:	29 c2                	sub    %eax,%edx
    50e5:	4c 01 fe             	add    %r15,%rsi
    50e8:	4c 89 e7             	mov    %r12,%rdi
    50eb:	e8 4d fb ff ff       	callq  4c3d <ustream_write_buffered>
    50f0:	89 c3                	mov    %eax,%ebx
    50f2:	e9 ff 00 00 00       	jmpq   51f6 <ustream_vprintf+0x1d2>
		} else {
			buf = malloc(maxlen + 1);
    50f7:	ff c3                	inc    %ebx
    50f9:	48 63 db             	movslq %ebx,%rbx
    50fc:	48 89 df             	mov    %rbx,%rdi
    50ff:	e8 dc d4 ff ff       	callq  25e0 <malloc@plt>
    5104:	48 83 c9 ff          	or     $0xffffffffffffffff,%rcx
    5108:	49 89 c7             	mov    %rax,%r15
    510b:	48 89 de             	mov    %rbx,%rsi
    510e:	4d 89 e9             	mov    %r13,%r9
    5111:	4d 89 f0             	mov    %r14,%r8
    5114:	ba 01 00 00 00       	mov    $0x1,%edx
    5119:	48 89 c7             	mov    %rax,%rdi
    511c:	e8 ef d4 ff ff       	callq  2610 <__vsnprintf_chk@plt>
			wr = vsnprintf(buf, maxlen + 1, format, arg);
			wr = ustream_write(s, buf, wr, false);
    5121:	31 c9                	xor    %ecx,%ecx
    5123:	89 c2                	mov    %eax,%edx
    5125:	4c 89 fe             	mov    %r15,%rsi
    5128:	4c 89 e7             	mov    %r12,%rdi
    512b:	e8 c0 d5 ff ff       	callq  26f0 <ustream_write@plt>
    5130:	e9 b7 00 00 00       	jmpq   51ec <ustream_vprintf+0x1c8>

#define MAX_STACK_BUFLEN	256

int ustream_vprintf(struct ustream *s, const char *format, va_list arg)
{
	struct ustream_buf_list *l = &s->w;
    5135:	48 8d 77 38          	lea    0x38(%rdi),%rsi
			free(buf);
			return wr;
		}
	}

	if (!ustream_prepare_buf(s, l, 1))
    5139:	ba 01 00 00 00       	mov    $0x1,%edx
    513e:	e8 f7 f9 ff ff       	callq  4b3a <ustream_prepare_buf>
    5143:	84 c0                	test   %al,%al
    5145:	0f 84 02 ff ff ff    	je     504d <ustream_vprintf+0x29>
		return 0;

	buf = l->data_tail->tail;
    514b:	49 8b 54 24 40       	mov    0x40(%r12),%rdx
	buflen = l->data_tail->end - buf;

	va_copy(arg2, arg);
    5150:	4c 8d 4d b0          	lea    -0x50(%rbp),%r9
    5154:	b9 06 00 00 00       	mov    $0x6,%ecx
    5159:	4c 89 ee             	mov    %r13,%rsi
    515c:	4d 89 f0             	mov    %r14,%r8
    515f:	4c 89 cf             	mov    %r9,%rdi
	}

	if (!ustream_prepare_buf(s, l, 1))
		return 0;

	buf = l->data_tail->tail;
    5162:	48 8b 42 10          	mov    0x10(%rdx),%rax
	buflen = l->data_tail->end - buf;
    5166:	4c 8b 7a 18          	mov    0x18(%rdx),%r15
    516a:	ba 01 00 00 00       	mov    $0x1,%edx

	va_copy(arg2, arg);
    516f:	f3 a5                	rep movsl %ds:(%rsi),%es:(%rdi)
    5171:	48 83 c9 ff          	or     $0xffffffffffffffff,%rcx

	if (!ustream_prepare_buf(s, l, 1))
		return 0;

	buf = l->data_tail->tail;
	buflen = l->data_tail->end - buf;
    5175:	49 29 c7             	sub    %rax,%r15
    5178:	48 89 c7             	mov    %rax,%rdi
    517b:	49 63 f7             	movslq %r15d,%rsi
	maxlen = vsnprintf(buf, buflen, format, arg2);
	va_end(arg2);

	wr = maxlen;
	if (wr >= buflen)
		wr = buflen - 1;
    517e:	41 8d 5f ff          	lea    -0x1(%r15),%ebx
    5182:	e8 89 d4 ff ff       	callq  2610 <__vsnprintf_chk@plt>

	l->data_tail->tail += wr;
    5187:	49 8b 54 24 40       	mov    0x40(%r12),%rdx
	maxlen = vsnprintf(buf, buflen, format, arg2);
	va_end(arg2);

	wr = maxlen;
	if (wr >= buflen)
		wr = buflen - 1;
    518c:	44 39 f8             	cmp    %r15d,%eax
    518f:	0f 4c d8             	cmovl  %eax,%ebx

	l->data_tail->tail += wr;
    5192:	4c 63 d3             	movslq %ebx,%r10
    5195:	4c 01 52 10          	add    %r10,0x10(%rdx)
	l->data_bytes += wr;
    5199:	41 01 5c 24 58       	add    %ebx,0x58(%r12)
	if (maxlen < buflen)
    519e:	41 39 c7             	cmp    %eax,%r15d
    51a1:	7f 53                	jg     51f6 <ustream_vprintf+0x1d2>
		return wr;

	buf = malloc(maxlen + 1);
    51a3:	ff c0                	inc    %eax
    51a5:	4c 89 55 a0          	mov    %r10,-0x60(%rbp)
    51a9:	48 63 f0             	movslq %eax,%rsi
    51ac:	48 89 f7             	mov    %rsi,%rdi
    51af:	48 89 75 a8          	mov    %rsi,-0x58(%rbp)
    51b3:	e8 28 d4 ff ff       	callq  25e0 <malloc@plt>
    51b8:	48 8b 75 a8          	mov    -0x58(%rbp),%rsi
    51bc:	48 83 c9 ff          	or     $0xffffffffffffffff,%rcx
    51c0:	ba 01 00 00 00       	mov    $0x1,%edx
    51c5:	48 89 c7             	mov    %rax,%rdi
    51c8:	4d 89 e9             	mov    %r13,%r9
    51cb:	4d 89 f0             	mov    %r14,%r8
    51ce:	49 89 c7             	mov    %rax,%r15
    51d1:	e8 3a d4 ff ff       	callq  2610 <__vsnprintf_chk@plt>
	maxlen = vsnprintf(buf, maxlen + 1, format, arg);
	wr = ustream_write_buffered(s, buf + wr, maxlen - wr, wr);
    51d6:	4c 8b 55 a0          	mov    -0x60(%rbp),%r10
    51da:	29 d8                	sub    %ebx,%eax
    51dc:	89 d9                	mov    %ebx,%ecx
    51de:	89 c2                	mov    %eax,%edx
    51e0:	4c 89 e7             	mov    %r12,%rdi
    51e3:	4b 8d 34 17          	lea    (%r15,%r10,1),%rsi
    51e7:	e8 51 fa ff ff       	callq  4c3d <ustream_write_buffered>
	free(buf);
    51ec:	4c 89 ff             	mov    %r15,%rdi
	if (maxlen < buflen)
		return wr;

	buf = malloc(maxlen + 1);
	maxlen = vsnprintf(buf, maxlen + 1, format, arg);
	wr = ustream_write_buffered(s, buf + wr, maxlen - wr, wr);
    51ef:	89 c3                	mov    %eax,%ebx
	free(buf);
    51f1:	e8 6a d1 ff ff       	callq  2360 <free@plt>

	return wr;
}
    51f6:	48 8b 4d c8          	mov    -0x38(%rbp),%rcx
    51fa:	64 48 33 0c 25 28 00 	xor    %fs:0x28,%rcx
    5201:	00 00 
    5203:	89 d8                	mov    %ebx,%eax
    5205:	74 05                	je     520c <ustream_vprintf+0x1e8>
    5207:	e8 74 d2 ff ff       	callq  2480 <__stack_chk_fail@plt>
    520c:	48 8d 65 d8          	lea    -0x28(%rbp),%rsp
    5210:	5b                   	pop    %rbx
    5211:	41 5c                	pop    %r12
    5213:	41 5d                	pop    %r13
    5215:	41 5e                	pop    %r14
    5217:	41 5f                	pop    %r15
    5219:	5d                   	pop    %rbp
    521a:	c3                   	retq   

000000000000521b <ustream_printf>:

int ustream_printf(struct ustream *s, const char *format, ...)
{
    521b:	48 81 ec d8 00 00 00 	sub    $0xd8,%rsp
    5222:	84 c0                	test   %al,%al
    5224:	48 89 54 24 30       	mov    %rdx,0x30(%rsp)
    5229:	48 89 4c 24 38       	mov    %rcx,0x38(%rsp)
    522e:	4c 89 44 24 40       	mov    %r8,0x40(%rsp)
    5233:	4c 89 4c 24 48       	mov    %r9,0x48(%rsp)
    5238:	74 37                	je     5271 <ustream_printf+0x56>
    523a:	0f 29 44 24 50       	movaps %xmm0,0x50(%rsp)
    523f:	0f 29 4c 24 60       	movaps %xmm1,0x60(%rsp)
    5244:	0f 29 54 24 70       	movaps %xmm2,0x70(%rsp)
    5249:	0f 29 9c 24 80 00 00 	movaps %xmm3,0x80(%rsp)
    5250:	00 
    5251:	0f 29 a4 24 90 00 00 	movaps %xmm4,0x90(%rsp)
    5258:	00 
    5259:	0f 29 ac 24 a0 00 00 	movaps %xmm5,0xa0(%rsp)
    5260:	00 
    5261:	0f 29 b4 24 b0 00 00 	movaps %xmm6,0xb0(%rsp)
    5268:	00 
    5269:	0f 29 bc 24 c0 00 00 	movaps %xmm7,0xc0(%rsp)
    5270:	00 
    5271:	64 48 8b 04 25 28 00 	mov    %fs:0x28,%rax
    5278:	00 00 
    527a:	48 89 44 24 18       	mov    %rax,0x18(%rsp)
    527f:	31 c0                	xor    %eax,%eax
	va_list arg;
	int ret;

	if (s->write_error)
    5281:	80 bf e1 00 00 00 00 	cmpb   $0x0,0xe1(%rdi)
    5288:	75 2e                	jne    52b8 <ustream_printf+0x9d>
		return 0;

	va_start(arg, format);
    528a:	48 8d 84 24 e0 00 00 	lea    0xe0(%rsp),%rax
    5291:	00 
	ret = ustream_vprintf(s, format, arg);
    5292:	48 89 e2             	mov    %rsp,%rdx
	int ret;

	if (s->write_error)
		return 0;

	va_start(arg, format);
    5295:	c7 04 24 10 00 00 00 	movl   $0x10,(%rsp)
    529c:	c7 44 24 04 30 00 00 	movl   $0x30,0x4(%rsp)
    52a3:	00 
    52a4:	48 89 44 24 08       	mov    %rax,0x8(%rsp)
    52a9:	48 8d 44 24 20       	lea    0x20(%rsp),%rax
    52ae:	48 89 44 24 10       	mov    %rax,0x10(%rsp)
	ret = ustream_vprintf(s, format, arg);
    52b3:	e8 98 d0 ff ff       	callq  2350 <ustream_vprintf@plt>
	va_end(arg);

	return ret;
}
    52b8:	48 8b 4c 24 18       	mov    0x18(%rsp),%rcx
    52bd:	64 48 33 0c 25 28 00 	xor    %fs:0x28,%rcx
    52c4:	00 00 
    52c6:	74 05                	je     52cd <ustream_printf+0xb2>
    52c8:	e8 b3 d1 ff ff       	callq  2480 <__stack_chk_fail@plt>
    52cd:	48 81 c4 d8 00 00 00 	add    $0xd8,%rsp
    52d4:	c3                   	retq   

00000000000052d5 <ustream_fd_free>:

static void ustream_fd_free(struct ustream *s)
{
	struct ustream_fd *sf = container_of(s, struct ustream_fd, stream);

	uloop_fd_delete(&sf->fd);
    52d5:	48 81 c7 e8 00 00 00 	add    $0xe8,%rdi
    52dc:	e9 5f d4 ff ff       	jmpq   2740 <uloop_fd_delete@plt>

00000000000052e1 <ustream_fd_set_uloop>:
{
	struct ustream_fd *sf = container_of(s, struct ustream_fd, stream);
	struct ustream_buf *buf;
	unsigned int flags = ULOOP_EDGE_TRIGGER;

	if (!s->read_blocked && !s->eof)
    52e1:	83 bf e4 00 00 00 00 	cmpl   $0x0,0xe4(%rdi)

static void ustream_fd_set_uloop(struct ustream *s, bool write)
{
	struct ustream_fd *sf = container_of(s, struct ustream_fd, stream);
	struct ustream_buf *buf;
	unsigned int flags = ULOOP_EDGE_TRIGGER;
    52e8:	b8 04 00 00 00       	mov    $0x4,%eax

	if (!s->read_blocked && !s->eof)
    52ed:	75 0e                	jne    52fd <ustream_fd_set_uloop+0x1c>
		flags |= ULOOP_READ;
    52ef:	80 bf e2 00 00 00 01 	cmpb   $0x1,0xe2(%rdi)
    52f6:	19 c0                	sbb    %eax,%eax
    52f8:	f7 d0                	not    %eax
    52fa:	83 c0 05             	add    $0x5,%eax

	buf = s->w.head;
	if (write || (buf && s->w.data_bytes && !s->write_error))
    52fd:	40 84 f6             	test   %sil,%sil
    5300:	75 16                	jne    5318 <ustream_fd_set_uloop+0x37>
    5302:	48 83 7f 38 00       	cmpq   $0x0,0x38(%rdi)
    5307:	74 12                	je     531b <ustream_fd_set_uloop+0x3a>
    5309:	83 7f 58 00          	cmpl   $0x0,0x58(%rdi)
    530d:	74 0c                	je     531b <ustream_fd_set_uloop+0x3a>
    530f:	80 bf e1 00 00 00 00 	cmpb   $0x0,0xe1(%rdi)
    5316:	75 03                	jne    531b <ustream_fd_set_uloop+0x3a>
		flags |= ULOOP_WRITE;
    5318:	83 c8 02             	or     $0x2,%eax

	uloop_fd_add(&sf->fd, flags);
    531b:	48 81 c7 e8 00 00 00 	add    $0xe8,%rdi
    5322:	89 c6                	mov    %eax,%esi
    5324:	e9 47 d3 ff ff       	jmpq   2670 <uloop_fd_add@plt>

0000000000005329 <__ustream_fd_poll>:

	return ret;
}

static bool __ustream_fd_poll(struct ustream_fd *sf, unsigned int events)
{
    5329:	41 55                	push   %r13
    532b:	41 54                	push   %r12
    532d:	41 89 f4             	mov    %esi,%r12d
    5330:	55                   	push   %rbp
    5331:	53                   	push   %rbx
	struct ustream *s = &sf->stream;
	bool more = false;
    5332:	31 ed                	xor    %ebp,%ebp

	return ret;
}

static bool __ustream_fd_poll(struct ustream_fd *sf, unsigned int events)
{
    5334:	48 89 fb             	mov    %rdi,%rbx
    5337:	48 83 ec 18          	sub    $0x18,%rsp
    533b:	64 48 8b 04 25 28 00 	mov    %fs:0x28,%rax
    5342:	00 00 
    5344:	48 89 44 24 08       	mov    %rax,0x8(%rsp)
    5349:	31 c0                	xor    %eax,%eax
	struct ustream *s = &sf->stream;
	bool more = false;

	if (events & ULOOP_READ)
    534b:	40 80 e6 01          	and    $0x1,%sil
    534f:	0f 84 83 00 00 00    	je     53d8 <__ustream_fd_poll+0xaf>
	int buflen = 0;
	ssize_t len;
	char *buf;

	do {
		buf = ustream_reserve(s, 1, &buflen);
    5355:	4c 8d 6c 24 04       	lea    0x4(%rsp),%r13
}

static void ustream_fd_read_pending(struct ustream_fd *sf, bool *more)
{
	struct ustream *s = &sf->stream;
	int buflen = 0;
    535a:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%rsp)
    5361:	00 
	ssize_t len;
	char *buf;

	do {
		buf = ustream_reserve(s, 1, &buflen);
    5362:	4c 89 ea             	mov    %r13,%rdx
    5365:	be 01 00 00 00       	mov    $0x1,%esi
    536a:	48 89 df             	mov    %rbx,%rdi
    536d:	e8 ae d1 ff ff       	callq  2520 <ustream_reserve@plt>
		if (!buf)
    5372:	48 85 c0             	test   %rax,%rax
    5375:	74 61                	je     53d8 <__ustream_fd_poll+0xaf>
	return __read_chk (__fd, __buf, __nbytes, __bos0 (__buf));

      if (__nbytes > __bos0 (__buf))
	return __read_chk_warn (__fd, __buf, __nbytes, __bos0 (__buf));
    }
  return __read_alias (__fd, __buf, __nbytes);
    5377:	48 63 54 24 04       	movslq 0x4(%rsp),%rdx
    537c:	8b bb f0 00 00 00    	mov    0xf0(%rbx),%edi
    5382:	48 89 c6             	mov    %rax,%rsi
    5385:	e8 d6 d1 ff ff       	callq  2560 <read@plt>
			break;

		len = read(sf->fd.fd, buf, buflen);
		if (len < 0) {
    538a:	48 85 c0             	test   %rax,%rax
    538d:	79 27                	jns    53b6 <__ustream_fd_poll+0x8d>
			if (errno == EINTR)
    538f:	e8 ec cf ff ff       	callq  2380 <__errno_location@plt>
    5394:	8b 00                	mov    (%rax),%eax
    5396:	83 f8 04             	cmp    $0x4,%eax
    5399:	74 c7                	je     5362 <__ustream_fd_poll+0x39>
				continue;

			if (errno == EAGAIN)
    539b:	83 f8 0b             	cmp    $0xb,%eax
    539e:	74 38                	je     53d8 <__ustream_fd_poll+0xaf>

			len = 0;
		}

		if (!len) {
			if (!s->eof)
    53a0:	80 bb e2 00 00 00 00 	cmpb   $0x0,0xe2(%rbx)
    53a7:	75 1e                	jne    53c7 <__ustream_fd_poll+0x9e>
    53a9:	48 8d 7b 70          	lea    0x70(%rbx),%rdi
    53ad:	31 f6                	xor    %esi,%esi
    53af:	e8 7c d1 ff ff       	callq  2530 <uloop_timeout_set@plt>
    53b4:	eb 11                	jmp    53c7 <__ustream_fd_poll+0x9e>
				return;

			len = 0;
		}

		if (!len) {
    53b6:	74 e8                	je     53a0 <__ustream_fd_poll+0x77>
			s->eof = true;
			ustream_fd_set_uloop(s, false);
			return;
		}

		ustream_fill_read(s, len);
    53b8:	89 c6                	mov    %eax,%esi
    53ba:	48 89 df             	mov    %rbx,%rdi
		*more = true;
    53bd:	40 b5 01             	mov    $0x1,%bpl
			s->eof = true;
			ustream_fd_set_uloop(s, false);
			return;
		}

		ustream_fill_read(s, len);
    53c0:	e8 2b d1 ff ff       	callq  24f0 <ustream_fill_read@plt>
    53c5:	eb 9b                	jmp    5362 <__ustream_fd_poll+0x39>
		}

		if (!len) {
			if (!s->eof)
				ustream_state_change(s);
			s->eof = true;
    53c7:	c6 83 e2 00 00 00 01 	movb   $0x1,0xe2(%rbx)
			ustream_fd_set_uloop(s, false);
    53ce:	31 f6                	xor    %esi,%esi
    53d0:	48 89 df             	mov    %rbx,%rdi
    53d3:	e8 09 ff ff ff       	callq  52e1 <ustream_fd_set_uloop>
	bool more = false;

	if (events & ULOOP_READ)
		ustream_fd_read_pending(sf, &more);

	if (events & ULOOP_WRITE) {
    53d8:	41 80 e4 02          	and    $0x2,%r12b
    53dc:	74 16                	je     53f4 <__ustream_fd_poll+0xcb>
		if (!ustream_write_pending(s))
    53de:	48 89 df             	mov    %rbx,%rdi
    53e1:	e8 9a d1 ff ff       	callq  2580 <ustream_write_pending@plt>
    53e6:	84 c0                	test   %al,%al
    53e8:	75 0a                	jne    53f4 <__ustream_fd_poll+0xcb>
			ustream_fd_set_uloop(s, false);
    53ea:	31 f6                	xor    %esi,%esi
    53ec:	48 89 df             	mov    %rbx,%rdi
    53ef:	e8 ed fe ff ff       	callq  52e1 <ustream_fd_set_uloop>
	}

	return more;
}
    53f4:	48 8b 4c 24 08       	mov    0x8(%rsp),%rcx
    53f9:	64 48 33 0c 25 28 00 	xor    %fs:0x28,%rcx
    5400:	00 00 
    5402:	40 88 e8             	mov    %bpl,%al
    5405:	74 05                	je     540c <__ustream_fd_poll+0xe3>
    5407:	e8 74 d0 ff ff       	callq  2480 <__stack_chk_fail@plt>
    540c:	48 83 c4 18          	add    $0x18,%rsp
    5410:	5b                   	pop    %rbx
    5411:	5d                   	pop    %rbp
    5412:	41 5c                	pop    %r12
    5414:	41 5d                	pop    %r13
    5416:	c3                   	retq   

0000000000005417 <ustream_fd_poll>:

static bool ustream_fd_poll(struct ustream *s)
{
	struct ustream_fd *sf = container_of(s, struct ustream_fd, stream);

	return __ustream_fd_poll(sf, ULOOP_READ | ULOOP_WRITE);
    5417:	be 03 00 00 00       	mov    $0x3,%esi
    541c:	e9 08 ff ff ff       	jmpq   5329 <__ustream_fd_poll>

0000000000005421 <ustream_uloop_cb>:

static void ustream_uloop_cb(struct uloop_fd *fd, unsigned int events)
{
	struct ustream_fd *sf = container_of(fd, struct ustream_fd, fd);

	__ustream_fd_poll(sf, events);
    5421:	48 81 ef e8 00 00 00 	sub    $0xe8,%rdi
    5428:	e9 fc fe ff ff       	jmpq   5329 <__ustream_fd_poll>

000000000000542d <ustream_fd_set_read_blocked>:
	uloop_fd_add(&sf->fd, flags);
}

static void ustream_fd_set_read_blocked(struct ustream *s)
{
	ustream_fd_set_uloop(s, false);
    542d:	31 f6                	xor    %esi,%esi
    542f:	e9 ad fe ff ff       	jmpq   52e1 <ustream_fd_set_uloop>

0000000000005434 <ustream_fd_write>:
{
	struct ustream_fd *sf = container_of(s, struct ustream_fd, stream);
	ssize_t ret = 0, len;

	if (!buflen)
		return 0;
    5434:	31 c0                	xor    %eax,%eax
static int ustream_fd_write(struct ustream *s, const char *buf, int buflen, bool more)
{
	struct ustream_fd *sf = container_of(s, struct ustream_fd, stream);
	ssize_t ret = 0, len;

	if (!buflen)
    5436:	85 d2                	test   %edx,%edx
    5438:	74 62                	je     549c <ustream_fd_write+0x68>
		*more = true;
	} while (1);
}

static int ustream_fd_write(struct ustream *s, const char *buf, int buflen, bool more)
{
    543a:	41 55                	push   %r13
    543c:	41 54                	push   %r12
    543e:	49 89 fd             	mov    %rdi,%r13
    5441:	55                   	push   %rbp
    5442:	53                   	push   %rbx
    5443:	49 89 f4             	mov    %rsi,%r12
    5446:	51                   	push   %rcx
    5447:	89 d5                	mov    %edx,%ebp
    5449:	31 db                	xor    %ebx,%ebx

	if (!buflen)
		return 0;

	while (buflen) {
		len = write(sf->fd.fd, buf, buflen);
    544b:	41 8b bd f0 00 00 00 	mov    0xf0(%r13),%edi
    5452:	48 63 d5             	movslq %ebp,%rdx
    5455:	4c 89 e6             	mov    %r12,%rsi
    5458:	e8 c3 cf ff ff       	callq  2420 <write@plt>

		if (len < 0) {
    545d:	48 85 c0             	test   %rax,%rax
    5460:	79 16                	jns    5478 <ustream_fd_write+0x44>
			if (errno == EINTR)
    5462:	e8 19 cf ff ff       	callq  2380 <__errno_location@plt>
    5467:	8b 00                	mov    (%rax),%eax
    5469:	83 f8 04             	cmp    $0x4,%eax
    546c:	74 dd                	je     544b <ustream_fd_write+0x17>
				continue;

			if (errno == EAGAIN || errno == EWOULDBLOCK)
    546e:	83 f8 0b             	cmp    $0xb,%eax
    5471:	74 13                	je     5486 <ustream_fd_write+0x52>
				break;

			return -1;
    5473:	83 c8 ff             	or     $0xffffffff,%eax
    5476:	eb 1d                	jmp    5495 <ustream_fd_write+0x61>
		}

		ret += len;
    5478:	48 01 c3             	add    %rax,%rbx
		buf += len;
    547b:	49 01 c4             	add    %rax,%r12
	ssize_t ret = 0, len;

	if (!buflen)
		return 0;

	while (buflen) {
    547e:	29 c5                	sub    %eax,%ebp
    5480:	75 c9                	jne    544b <ustream_fd_write+0x17>
	}

	if (buflen)
		ustream_fd_set_uloop(s, true);

	return ret;
    5482:	89 d8                	mov    %ebx,%eax
    5484:	eb 0f                	jmp    5495 <ustream_fd_write+0x61>
		buf += len;
		buflen -= len;
	}

	if (buflen)
		ustream_fd_set_uloop(s, true);
    5486:	be 01 00 00 00       	mov    $0x1,%esi
    548b:	4c 89 ef             	mov    %r13,%rdi
    548e:	e8 4e fe ff ff       	callq  52e1 <ustream_fd_set_uloop>
    5493:	eb ed                	jmp    5482 <ustream_fd_write+0x4e>

	return ret;
}
    5495:	5a                   	pop    %rdx
    5496:	5b                   	pop    %rbx
    5497:	5d                   	pop    %rbp
    5498:	41 5c                	pop    %r12
    549a:	41 5d                	pop    %r13
    549c:	c3                   	retq   

000000000000549d <ustream_fd_init>:

	uloop_fd_delete(&sf->fd);
}

void ustream_fd_init(struct ustream_fd *sf, int fd)
{
    549d:	55                   	push   %rbp
    549e:	53                   	push   %rbx
    549f:	89 f5                	mov    %esi,%ebp
    54a1:	50                   	push   %rax
    54a2:	48 89 fb             	mov    %rdi,%rbx
	struct ustream *s = &sf->stream;

	ustream_init_defaults(s);
    54a5:	e8 e6 cf ff ff       	callq  2490 <ustream_init_defaults@plt>

	sf->fd.fd = fd;
	sf->fd.cb = ustream_uloop_cb;
    54aa:	48 8d 05 70 ff ff ff 	lea    -0x90(%rip),%rax        # 5421 <ustream_uloop_cb>
{
	struct ustream *s = &sf->stream;

	ustream_init_defaults(s);

	sf->fd.fd = fd;
    54b1:	89 ab f0 00 00 00    	mov    %ebp,0xf0(%rbx)
	sf->fd.cb = ustream_uloop_cb;
	s->set_read_blocked = ustream_fd_set_read_blocked;
	s->write = ustream_fd_write;
	s->free = ustream_fd_free;
	s->poll = ustream_fd_poll;
	ustream_fd_set_uloop(s, false);
    54b7:	48 89 df             	mov    %rbx,%rdi
    54ba:	31 f6                	xor    %esi,%esi
	struct ustream *s = &sf->stream;

	ustream_init_defaults(s);

	sf->fd.fd = fd;
	sf->fd.cb = ustream_uloop_cb;
    54bc:	48 89 83 e8 00 00 00 	mov    %rax,0xe8(%rbx)
	s->set_read_blocked = ustream_fd_set_read_blocked;
    54c3:	48 8d 05 63 ff ff ff 	lea    -0x9d(%rip),%rax        # 542d <ustream_fd_set_read_blocked>
    54ca:	48 89 83 d0 00 00 00 	mov    %rax,0xd0(%rbx)
	s->write = ustream_fd_write;
    54d1:	48 8d 05 5c ff ff ff 	lea    -0xa4(%rip),%rax        # 5434 <ustream_fd_write>
    54d8:	48 89 83 c0 00 00 00 	mov    %rax,0xc0(%rbx)
	s->free = ustream_fd_free;
    54df:	48 8d 05 ef fd ff ff 	lea    -0x211(%rip),%rax        # 52d5 <ustream_fd_free>
    54e6:	48 89 83 c8 00 00 00 	mov    %rax,0xc8(%rbx)
	s->poll = ustream_fd_poll;
    54ed:	48 8d 05 23 ff ff ff 	lea    -0xdd(%rip),%rax        # 5417 <ustream_fd_poll>
    54f4:	48 89 83 d8 00 00 00 	mov    %rax,0xd8(%rbx)
	ustream_fd_set_uloop(s, false);
}
    54fb:	5a                   	pop    %rdx
    54fc:	5b                   	pop    %rbx
    54fd:	5d                   	pop    %rbp
	sf->fd.cb = ustream_uloop_cb;
	s->set_read_blocked = ustream_fd_set_read_blocked;
	s->write = ustream_fd_write;
	s->free = ustream_fd_free;
	s->poll = ustream_fd_poll;
	ustream_fd_set_uloop(s, false);
    54fe:	e9 de fd ff ff       	jmpq   52e1 <ustream_fd_set_uloop>

0000000000005503 <vlist_init>:
#include "vlist.h"

void
vlist_init(struct vlist_tree *tree, avl_tree_comp cmp, vlist_update_cb update)
{
	tree->update = update;
    5503:	48 89 57 30          	mov    %rdx,0x30(%rdi)
	tree->version = 1;
    5507:	c7 47 3c 01 00 00 00 	movl   $0x1,0x3c(%rdi)

	avl_init(&tree->avl, cmp, 0, tree);
    550e:	48 89 f9             	mov    %rdi,%rcx
    5511:	31 d2                	xor    %edx,%edx
    5513:	e9 18 cf ff ff       	jmpq   2430 <avl_init@plt>

0000000000005518 <vlist_delete>:
}

void
vlist_delete(struct vlist_tree *tree, struct vlist_node *node)
{
    5518:	55                   	push   %rbp
    5519:	53                   	push   %rbx
    551a:	48 89 f5             	mov    %rsi,%rbp
    551d:	41 50                	push   %r8
	if (!tree->no_delete)
    551f:	80 7f 39 00          	cmpb   $0x0,0x39(%rdi)
	avl_init(&tree->avl, cmp, 0, tree);
}

void
vlist_delete(struct vlist_tree *tree, struct vlist_node *node)
{
    5523:	48 89 fb             	mov    %rdi,%rbx
	if (!tree->no_delete)
    5526:	75 05                	jne    552d <vlist_delete+0x15>
		avl_delete(&tree->avl, &node->avl);
    5528:	e8 63 d1 ff ff       	callq  2690 <avl_delete@plt>
	tree->update(tree, NULL, node);
    552d:	48 8b 43 30          	mov    0x30(%rbx),%rax
    5531:	48 89 ea             	mov    %rbp,%rdx
    5534:	48 89 df             	mov    %rbx,%rdi
}
    5537:	59                   	pop    %rcx
    5538:	5b                   	pop    %rbx
    5539:	5d                   	pop    %rbp
void
vlist_delete(struct vlist_tree *tree, struct vlist_node *node)
{
	if (!tree->no_delete)
		avl_delete(&tree->avl, &node->avl);
	tree->update(tree, NULL, node);
    553a:	31 f6                	xor    %esi,%esi
    553c:	ff e0                	jmpq   *%rax

000000000000553e <vlist_add>:
}

void
vlist_add(struct vlist_tree *tree, struct vlist_node *node, const void *key)
{
    553e:	41 54                	push   %r12
    5540:	55                   	push   %rbp
    5541:	48 89 f5             	mov    %rsi,%rbp
    5544:	53                   	push   %rbx
	struct vlist_node *old_node = NULL;
	struct avl_node *anode;

	node->avl.key = key;
	node->version = tree->version;
    5545:	8b 47 3c             	mov    0x3c(%rdi),%eax
	tree->update(tree, NULL, node);
}

void
vlist_add(struct vlist_tree *tree, struct vlist_node *node, const void *key)
{
    5548:	48 89 fb             	mov    %rdi,%rbx
	struct vlist_node *old_node = NULL;
	struct avl_node *anode;

	node->avl.key = key;
    554b:	48 89 56 28          	mov    %rdx,0x28(%rsi)
	node->version = tree->version;
    554f:	89 46 38             	mov    %eax,0x38(%rsi)

	anode = avl_find(&tree->avl, key);
    5552:	48 89 d6             	mov    %rdx,%rsi
    5555:	e8 e6 ce ff ff       	callq  2440 <avl_find@plt>
	if (anode) {
    555a:	48 85 c0             	test   %rax,%rax
	struct avl_node *anode;

	node->avl.key = key;
	node->version = tree->version;

	anode = avl_find(&tree->avl, key);
    555d:	49 89 c4             	mov    %rax,%r12
	if (anode) {
    5560:	74 21                	je     5583 <vlist_add+0x45>
		old_node = container_of(anode, struct vlist_node, avl);
		if (tree->keep_old || tree->no_delete) {
    5562:	80 7b 38 00          	cmpb   $0x0,0x38(%rbx)
    5566:	75 06                	jne    556e <vlist_add+0x30>
    5568:	80 7b 39 00          	cmpb   $0x0,0x39(%rbx)
    556c:	74 0a                	je     5578 <vlist_add+0x3a>
			old_node->version = tree->version;
    556e:	8b 43 3c             	mov    0x3c(%rbx),%eax
    5571:	41 89 44 24 38       	mov    %eax,0x38(%r12)
			goto update_only;
    5576:	eb 16                	jmp    558e <vlist_add+0x50>
		}

		avl_delete(&tree->avl, anode);
    5578:	48 89 c6             	mov    %rax,%rsi
    557b:	48 89 df             	mov    %rbx,%rdi
    557e:	e8 0d d1 ff ff       	callq  2690 <avl_delete@plt>
	}

	avl_insert(&tree->avl, &node->avl);
    5583:	48 89 ee             	mov    %rbp,%rsi
    5586:	48 89 df             	mov    %rbx,%rdi
    5589:	e8 82 ce ff ff       	callq  2410 <avl_insert@plt>

update_only:
	tree->update(tree, node, old_node);
    558e:	48 8b 43 30          	mov    0x30(%rbx),%rax
    5592:	4c 89 e2             	mov    %r12,%rdx
    5595:	48 89 ee             	mov    %rbp,%rsi
    5598:	48 89 df             	mov    %rbx,%rdi
}
    559b:	5b                   	pop    %rbx
    559c:	5d                   	pop    %rbp
    559d:	41 5c                	pop    %r12
	}

	avl_insert(&tree->avl, &node->avl);

update_only:
	tree->update(tree, node, old_node);
    559f:	ff e0                	jmpq   *%rax

00000000000055a1 <vlist_flush>:
}

void
vlist_flush(struct vlist_tree *tree)
{
    55a1:	55                   	push   %rbp
    55a2:	53                   	push   %rbx
    55a3:	48 89 fb             	mov    %rdi,%rbx
    55a6:	52                   	push   %rdx
	struct vlist_node *node, *tmp;

	avl_for_each_element_safe(&tree->avl, node, avl, tmp) {
    55a7:	48 8b 37             	mov    (%rdi),%rsi
    55aa:	48 8b 2e             	mov    (%rsi),%rbp
    55ad:	48 8b 43 08          	mov    0x8(%rbx),%rax
    55b1:	48 39 46 08          	cmp    %rax,0x8(%rsi)
    55b5:	74 24                	je     55db <vlist_flush+0x3a>
		if ((node->version == tree->version || node->version == -1) &&
    55b7:	8b 56 38             	mov    0x38(%rsi),%edx
    55ba:	8b 43 3c             	mov    0x3c(%rbx),%eax
    55bd:	83 fa ff             	cmp    $0xffffffff,%edx
    55c0:	74 04                	je     55c6 <vlist_flush+0x25>
    55c2:	39 c2                	cmp    %eax,%edx
    55c4:	75 04                	jne    55ca <vlist_flush+0x29>
    55c6:	ff c0                	inc    %eax
    55c8:	75 08                	jne    55d2 <vlist_flush+0x31>
		    tree->version != -1)
			continue;

		vlist_delete(tree, node);
    55ca:	48 89 df             	mov    %rbx,%rdi
    55cd:	e8 7e ce ff ff       	callq  2450 <vlist_delete@plt>
void
vlist_flush(struct vlist_tree *tree)
{
	struct vlist_node *node, *tmp;

	avl_for_each_element_safe(&tree->avl, node, avl, tmp) {
    55d2:	48 89 ee             	mov    %rbp,%rsi
    55d5:	48 8b 6d 00          	mov    0x0(%rbp),%rbp
    55d9:	eb d2                	jmp    55ad <vlist_flush+0xc>
		    tree->version != -1)
			continue;

		vlist_delete(tree, node);
	}
}
    55db:	58                   	pop    %rax
    55dc:	5b                   	pop    %rbx
    55dd:	5d                   	pop    %rbp
    55de:	c3                   	retq   

00000000000055df <vlist_flush_all>:

void
vlist_flush_all(struct vlist_tree *tree)
{
	tree->version = -1;
    55df:	c7 47 3c ff ff ff ff 	movl   $0xffffffff,0x3c(%rdi)
	vlist_flush(tree);
    55e6:	e9 e5 d1 ff ff       	jmpq   27d0 <vlist_flush@plt>

00000000000055eb <__calloc_a>:
	for (_addr = (_first_addr), _len = (_first_len); \
		_addr; \
		_addr = va_arg(_arg, void **), _len = _addr ? va_arg(_arg, size_t) : 0)

void *__calloc_a(size_t len, ...)
{
    55eb:	53                   	push   %rbx
    55ec:	48 89 fb             	mov    %rdi,%rbx
    55ef:	48 81 ec f0 00 00 00 	sub    $0xf0,%rsp
    55f6:	84 c0                	test   %al,%al
    55f8:	48 89 74 24 48       	mov    %rsi,0x48(%rsp)
    55fd:	48 89 54 24 50       	mov    %rdx,0x50(%rsp)
    5602:	48 89 4c 24 58       	mov    %rcx,0x58(%rsp)
    5607:	4c 89 44 24 60       	mov    %r8,0x60(%rsp)
    560c:	4c 89 4c 24 68       	mov    %r9,0x68(%rsp)
    5611:	74 3d                	je     5650 <__calloc_a+0x65>
    5613:	0f 29 44 24 70       	movaps %xmm0,0x70(%rsp)
    5618:	0f 29 8c 24 80 00 00 	movaps %xmm1,0x80(%rsp)
    561f:	00 
    5620:	0f 29 94 24 90 00 00 	movaps %xmm2,0x90(%rsp)
    5627:	00 
    5628:	0f 29 9c 24 a0 00 00 	movaps %xmm3,0xa0(%rsp)
    562f:	00 
    5630:	0f 29 a4 24 b0 00 00 	movaps %xmm4,0xb0(%rsp)
    5637:	00 
    5638:	0f 29 ac 24 c0 00 00 	movaps %xmm5,0xc0(%rsp)
    563f:	00 
    5640:	0f 29 b4 24 d0 00 00 	movaps %xmm6,0xd0(%rsp)
    5647:	00 
    5648:	0f 29 bc 24 e0 00 00 	movaps %xmm7,0xe0(%rsp)
    564f:	00 
    5650:	64 48 8b 04 25 28 00 	mov    %fs:0x28,%rax
    5657:	00 00 
    5659:	48 89 44 24 38       	mov    %rax,0x38(%rsp)
    565e:	31 c0                	xor    %eax,%eax
	void **cur_addr;
	size_t cur_len;
	int alloc_len = 0;
	char *ptr;

	va_start(ap, len);
    5660:	48 8d 84 24 00 01 00 	lea    0x100(%rsp),%rax
    5667:	00 

	va_copy(ap1, ap);
    5668:	48 8d 74 24 08       	lea    0x8(%rsp),%rsi
    566d:	b9 06 00 00 00       	mov    $0x6,%ecx
	void **cur_addr;
	size_t cur_len;
	int alloc_len = 0;
	char *ptr;

	va_start(ap, len);
    5672:	48 89 44 24 10       	mov    %rax,0x10(%rsp)
    5677:	48 8d 44 24 40       	lea    0x40(%rsp),%rax
    567c:	c7 44 24 08 08 00 00 	movl   $0x8,0x8(%rsp)
    5683:	00 
    5684:	c7 44 24 0c 30 00 00 	movl   $0x30,0xc(%rsp)
    568b:	00 
    568c:	48 89 44 24 18       	mov    %rax,0x18(%rsp)

	va_copy(ap1, ap);
    5691:	48 8d 44 24 20       	lea    0x20(%rsp),%rax
    5696:	48 89 c7             	mov    %rax,%rdi
    5699:	f3 a5                	rep movsl %ds:(%rsi),%es:(%rdi)
	foreach_arg(ap1, cur_addr, cur_len, &ret, len)
    569b:	48 89 de             	mov    %rbx,%rsi
    569e:	48 8b 7c 24 30       	mov    0x30(%rsp),%rdi
    56a3:	8b 54 24 20          	mov    0x20(%rsp),%edx
		alloc_len += cur_len;
    56a7:	01 ce                	add    %ecx,%esi
    56a9:	89 f1                	mov    %esi,%ecx
	char *ptr;

	va_start(ap, len);

	va_copy(ap1, ap);
	foreach_arg(ap1, cur_addr, cur_len, &ret, len)
    56ab:	83 fa 2f             	cmp    $0x2f,%edx
    56ae:	77 0e                	ja     56be <__calloc_a+0xd3>
    56b0:	89 d0                	mov    %edx,%eax
    56b2:	83 c2 08             	add    $0x8,%edx
    56b5:	48 01 f8             	add    %rdi,%rax
    56b8:	89 54 24 20          	mov    %edx,0x20(%rsp)
    56bc:	eb 0e                	jmp    56cc <__calloc_a+0xe1>
    56be:	48 8b 44 24 28       	mov    0x28(%rsp),%rax
    56c3:	48 8d 50 08          	lea    0x8(%rax),%rdx
    56c7:	48 89 54 24 28       	mov    %rdx,0x28(%rsp)
    56cc:	48 83 38 00          	cmpq   $0x0,(%rax)
    56d0:	74 2a                	je     56fc <__calloc_a+0x111>
    56d2:	8b 54 24 20          	mov    0x20(%rsp),%edx
    56d6:	83 fa 2f             	cmp    $0x2f,%edx
    56d9:	77 0e                	ja     56e9 <__calloc_a+0xfe>
    56db:	89 d0                	mov    %edx,%eax
    56dd:	83 c2 08             	add    $0x8,%edx
    56e0:	48 01 f8             	add    %rdi,%rax
    56e3:	89 54 24 20          	mov    %edx,0x20(%rsp)
    56e7:	eb 0e                	jmp    56f7 <__calloc_a+0x10c>
    56e9:	48 8b 44 24 28       	mov    0x28(%rsp),%rax
    56ee:	48 8d 50 08          	lea    0x8(%rax),%rdx
    56f2:	48 89 54 24 28       	mov    %rdx,0x28(%rsp)
    56f7:	48 8b 30             	mov    (%rax),%rsi
    56fa:	eb a7                	jmp    56a3 <__calloc_a+0xb8>
		alloc_len += cur_len;
	va_end(ap1);

	ptr = calloc(1, alloc_len);
    56fc:	48 63 f6             	movslq %esi,%rsi
    56ff:	bf 01 00 00 00       	mov    $0x1,%edi
    5704:	e8 87 ce ff ff       	callq  2590 <calloc@plt>
	alloc_len = 0;
    5709:	31 ff                	xor    %edi,%edi
	foreach_arg(ap, cur_addr, cur_len, &ret, len) {
    570b:	48 89 e6             	mov    %rsp,%rsi
    570e:	8b 4c 24 08          	mov    0x8(%rsp),%ecx
		*cur_addr = &ptr[alloc_len];
    5712:	48 63 d7             	movslq %edi,%rdx
		alloc_len += cur_len;
    5715:	01 df                	add    %ebx,%edi
	va_end(ap1);

	ptr = calloc(1, alloc_len);
	alloc_len = 0;
	foreach_arg(ap, cur_addr, cur_len, &ret, len) {
		*cur_addr = &ptr[alloc_len];
    5717:	48 01 c2             	add    %rax,%rdx
    571a:	48 89 16             	mov    %rdx,(%rsi)
		alloc_len += cur_len;
	va_end(ap1);

	ptr = calloc(1, alloc_len);
	alloc_len = 0;
	foreach_arg(ap, cur_addr, cur_len, &ret, len) {
    571d:	83 f9 2f             	cmp    $0x2f,%ecx
    5720:	77 10                	ja     5732 <__calloc_a+0x147>
    5722:	89 ca                	mov    %ecx,%edx
    5724:	83 c1 08             	add    $0x8,%ecx
    5727:	48 03 54 24 18       	add    0x18(%rsp),%rdx
    572c:	89 4c 24 08          	mov    %ecx,0x8(%rsp)
    5730:	eb 0e                	jmp    5740 <__calloc_a+0x155>
    5732:	48 8b 54 24 10       	mov    0x10(%rsp),%rdx
    5737:	48 8d 4a 08          	lea    0x8(%rdx),%rcx
    573b:	48 89 4c 24 10       	mov    %rcx,0x10(%rsp)
    5740:	48 8b 32             	mov    (%rdx),%rsi
    5743:	48 85 f6             	test   %rsi,%rsi
    5746:	74 2c                	je     5774 <__calloc_a+0x189>
    5748:	8b 4c 24 08          	mov    0x8(%rsp),%ecx
    574c:	83 f9 2f             	cmp    $0x2f,%ecx
    574f:	77 10                	ja     5761 <__calloc_a+0x176>
    5751:	89 ca                	mov    %ecx,%edx
    5753:	83 c1 08             	add    $0x8,%ecx
    5756:	48 03 54 24 18       	add    0x18(%rsp),%rdx
    575b:	89 4c 24 08          	mov    %ecx,0x8(%rsp)
    575f:	eb 0e                	jmp    576f <__calloc_a+0x184>
    5761:	48 8b 54 24 10       	mov    0x10(%rsp),%rdx
    5766:	48 8d 4a 08          	lea    0x8(%rdx),%rcx
    576a:	48 89 4c 24 10       	mov    %rcx,0x10(%rsp)
    576f:	48 8b 1a             	mov    (%rdx),%rbx
    5772:	eb 9a                	jmp    570e <__calloc_a+0x123>
		alloc_len += cur_len;
	}
	va_end(ap);

	return ret;
}
    5774:	48 8b 5c 24 38       	mov    0x38(%rsp),%rbx
    5779:	64 48 33 1c 25 28 00 	xor    %fs:0x28,%rbx
    5780:	00 00 
    5782:	48 8b 04 24          	mov    (%rsp),%rax
    5786:	74 05                	je     578d <__calloc_a+0x1a2>
    5788:	e8 f3 cc ff ff       	callq  2480 <__stack_chk_fail@plt>
    578d:	48 81 c4 f0 00 00 00 	add    $0xf0,%rsp
    5794:	5b                   	pop    %rbx
    5795:	c3                   	retq   

0000000000005796 <safe_list_for_each>:
}

int safe_list_for_each(struct safe_list *head,
		       int (*cb)(void *ctx, struct safe_list *list),
		       void *ctx)
{
    5796:	41 56                	push   %r14
    5798:	41 55                	push   %r13
    579a:	49 89 f5             	mov    %rsi,%r13
    579d:	41 54                	push   %r12
    579f:	55                   	push   %rbp
    57a0:	48 89 d5             	mov    %rdx,%rbp
    57a3:	53                   	push   %rbx
    57a4:	49 89 fc             	mov    %rdi,%r12
    57a7:	48 83 ec 20          	sub    $0x20,%rsp
	struct safe_list_iterator i;
	struct safe_list *cur;
	int ret = 0;

	for (cur = list_entry(head->list.next, struct safe_list, list),
    57ab:	48 8b 37             	mov    (%rdi),%rsi
}

int safe_list_for_each(struct safe_list *head,
		       int (*cb)(void *ctx, struct safe_list *list),
		       void *ctx)
{
    57ae:	64 48 8b 04 25 28 00 	mov    %fs:0x28,%rax
    57b5:	00 00 
    57b7:	48 89 44 24 18       	mov    %rax,0x18(%rsp)
    57bc:	31 c0                	xor    %eax,%eax
	struct safe_list *next;

	next = list_entry(list->list.next, struct safe_list, list);
	next_i = next->i;

	next->i = i;
    57be:	48 89 e3             	mov    %rsp,%rbx
    57c1:	48 8b 06             	mov    (%rsi),%rax
{
	struct safe_list_iterator *next_i;
	struct safe_list *next;

	next = list_entry(list->list.next, struct safe_list, list);
	next_i = next->i;
    57c4:	48 8b 50 10          	mov    0x10(%rax),%rdx

	next->i = i;
    57c8:	48 89 60 10          	mov    %rsp,0x10(%rax)
	i->next = next;
    57cc:	48 89 44 24 10       	mov    %rax,0x10(%rsp)
	i->head = &next->i;
    57d1:	48 83 c0 10          	add    $0x10,%rax
    57d5:	48 89 04 24          	mov    %rax,(%rsp)

	i->next_i = next_i;
	if (next_i)
    57d9:	48 85 d2             	test   %rdx,%rdx

	next->i = i;
	i->next = next;
	i->head = &next->i;

	i->next_i = next_i;
    57dc:	48 89 54 24 08       	mov    %rdx,0x8(%rsp)
	if (next_i)
    57e1:	74 08                	je     57eb <safe_list_for_each+0x55>
		next_i->head = &i->next_i;
    57e3:	48 8d 44 24 08       	lea    0x8(%rsp),%rax
    57e8:	48 89 02             	mov    %rax,(%rdx)
    57eb:	4c 8d 73 08          	lea    0x8(%rbx),%r14
{
	struct safe_list_iterator i;
	struct safe_list *cur;
	int ret = 0;

	for (cur = list_entry(head->list.next, struct safe_list, list),
    57ef:	4c 39 e6             	cmp    %r12,%rsi
    57f2:	74 53                	je     5847 <safe_list_for_each+0xb1>
	     __safe_list_set_iterator(cur, &i);
	     cur != head;
	     cur = i.next, __safe_list_move_iterator(cur, &i)) {
		ret = cb(ctx, cur);
    57f4:	48 89 ef             	mov    %rbp,%rdi
    57f7:	41 ff d5             	callq  *%r13
		if (ret)
    57fa:	85 c0                	test   %eax,%eax
    57fc:	75 4b                	jne    5849 <safe_list_for_each+0xb3>
}

static void
__safe_list_del_iterator(struct safe_list_iterator *i)
{
	*i->head = i->next_i;
    57fe:	48 8b 04 24          	mov    (%rsp),%rax
    5802:	48 8b 54 24 08       	mov    0x8(%rsp),%rdx
	int ret = 0;

	for (cur = list_entry(head->list.next, struct safe_list, list),
	     __safe_list_set_iterator(cur, &i);
	     cur != head;
	     cur = i.next, __safe_list_move_iterator(cur, &i)) {
    5807:	48 8b 74 24 10       	mov    0x10(%rsp),%rsi
}

static void
__safe_list_del_iterator(struct safe_list_iterator *i)
{
	*i->head = i->next_i;
    580c:	48 89 10             	mov    %rdx,(%rax)
	if (i->next_i)
    580f:	48 8b 44 24 08       	mov    0x8(%rsp),%rax
    5814:	48 85 c0             	test   %rax,%rax
    5817:	74 07                	je     5820 <safe_list_for_each+0x8a>
		i->next_i->head = i->head;
    5819:	48 8b 14 24          	mov    (%rsp),%rdx
    581d:	48 89 10             	mov    %rdx,(%rax)
    5820:	48 8b 06             	mov    (%rsi),%rax
{
	struct safe_list_iterator *next_i;
	struct safe_list *next;

	next = list_entry(list->list.next, struct safe_list, list);
	next_i = next->i;
    5823:	48 8b 50 10          	mov    0x10(%rax),%rdx

	next->i = i;
    5827:	48 89 58 10          	mov    %rbx,0x10(%rax)
	i->next = next;
    582b:	48 89 44 24 10       	mov    %rax,0x10(%rsp)
	i->head = &next->i;
    5830:	48 83 c0 10          	add    $0x10,%rax
    5834:	48 89 04 24          	mov    %rax,(%rsp)

	i->next_i = next_i;
	if (next_i)
    5838:	48 85 d2             	test   %rdx,%rdx

	next->i = i;
	i->next = next;
	i->head = &next->i;

	i->next_i = next_i;
    583b:	48 89 54 24 08       	mov    %rdx,0x8(%rsp)
	if (next_i)
    5840:	74 ad                	je     57ef <safe_list_for_each+0x59>
		next_i->head = &i->next_i;
    5842:	4c 89 32             	mov    %r14,(%rdx)
    5845:	eb a8                	jmp    57ef <safe_list_for_each+0x59>
    5847:	31 c0                	xor    %eax,%eax
}

static void
__safe_list_del_iterator(struct safe_list_iterator *i)
{
	*i->head = i->next_i;
    5849:	48 8b 14 24          	mov    (%rsp),%rdx
    584d:	48 8b 4c 24 08       	mov    0x8(%rsp),%rcx
    5852:	48 89 0a             	mov    %rcx,(%rdx)
	if (i->next_i)
    5855:	48 8b 54 24 08       	mov    0x8(%rsp),%rdx
    585a:	48 85 d2             	test   %rdx,%rdx
    585d:	74 07                	je     5866 <safe_list_for_each+0xd0>
		i->next_i->head = i->head;
    585f:	48 8b 0c 24          	mov    (%rsp),%rcx
    5863:	48 89 0a             	mov    %rcx,(%rdx)
			break;
	}

	__safe_list_del_iterator(&i);
	return ret;
}
    5866:	48 8b 7c 24 18       	mov    0x18(%rsp),%rdi
    586b:	64 48 33 3c 25 28 00 	xor    %fs:0x28,%rdi
    5872:	00 00 
    5874:	74 05                	je     587b <safe_list_for_each+0xe5>
    5876:	e8 05 cc ff ff       	callq  2480 <__stack_chk_fail@plt>
    587b:	48 83 c4 20          	add    $0x20,%rsp
    587f:	5b                   	pop    %rbx
    5880:	5d                   	pop    %rbp
    5881:	41 5c                	pop    %r12
    5883:	41 5d                	pop    %r13
    5885:	41 5e                	pop    %r14
    5887:	c3                   	retq   

0000000000005888 <safe_list_add>:
}

static inline void
list_add_tail(struct list_head *_new, struct list_head *head)
{
	_list_add(_new, head->prev, head);
    5888:	48 8b 46 08          	mov    0x8(%rsi),%rax

void safe_list_add(struct safe_list *list, struct safe_list *head)
{
	list->i = NULL;
    588c:	48 c7 47 10 00 00 00 	movq   $0x0,0x10(%rdi)
    5893:	00 
static inline void
_list_add(struct list_head *_new, struct list_head *prev,
    struct list_head *next)
{

	next->prev = _new;
    5894:	48 89 7e 08          	mov    %rdi,0x8(%rsi)
	_new->next = next;
    5898:	48 89 37             	mov    %rsi,(%rdi)
	_new->prev = prev;
    589b:	48 89 47 08          	mov    %rax,0x8(%rdi)
	prev->next = _new;
    589f:	48 89 38             	mov    %rdi,(%rax)
    58a2:	c3                   	retq   

00000000000058a3 <safe_list_add_first>:
#define	list_for_each_prev_safe(p, n, h) for (p = (h)->prev, n = p->prev; p != (h); p = n, n = p->prev)

static inline void
list_add(struct list_head *_new, struct list_head *head)
{
	_list_add(_new, head, head->next);
    58a3:	48 8b 06             	mov    (%rsi),%rax
	list_add_tail(&list->list, &head->list);
}

void safe_list_add_first(struct safe_list *list, struct safe_list *head)
{
	list->i = NULL;
    58a6:	48 c7 47 10 00 00 00 	movq   $0x0,0x10(%rdi)
    58ad:	00 
static inline void
_list_add(struct list_head *_new, struct list_head *prev,
    struct list_head *next)
{

	next->prev = _new;
    58ae:	48 89 78 08          	mov    %rdi,0x8(%rax)
	_new->next = next;
    58b2:	48 89 07             	mov    %rax,(%rdi)
	_new->prev = prev;
    58b5:	48 89 77 08          	mov    %rsi,0x8(%rdi)
	prev->next = _new;
    58b9:	48 89 3e             	mov    %rdi,(%rsi)
    58bc:	c3                   	retq   

00000000000058bd <safe_list_del>:
}

static inline void
_list_del(struct list_head *entry)
{
	entry->next->prev = entry->prev;
    58bd:	48 8b 47 08          	mov    0x8(%rdi),%rax
void safe_list_del(struct safe_list *list)
{
	struct safe_list_iterator *i, *next_i, **tail;
	struct safe_list *next;

	next = list_entry(list->list.next, struct safe_list, list);
    58c1:	48 8b 17             	mov    (%rdi),%rdx
	list_del(&list->list);

	if (!list->i)
    58c4:	48 8b 77 10          	mov    0x10(%rdi),%rsi
    58c8:	48 89 42 08          	mov    %rax,0x8(%rdx)
	entry->prev->next = entry->next;
    58cc:	48 8b 47 08          	mov    0x8(%rdi),%rax
    58d0:	48 85 f6             	test   %rsi,%rsi
    58d3:	48 89 10             	mov    %rdx,(%rax)

static inline void
list_del(struct list_head *entry)
{
	_list_del(entry);
	entry->next = entry->prev = NULL;
    58d6:	48 c7 47 08 00 00 00 	movq   $0x0,0x8(%rdi)
    58dd:	00 
    58de:	48 c7 07 00 00 00 00 	movq   $0x0,(%rdi)
    58e5:	74 40                	je     5927 <safe_list_del+0x6a>
		return;

	next_i = next->i;
    58e7:	48 8b 4a 10          	mov    0x10(%rdx),%rcx
	tail = &next->i;
    58eb:	4c 8d 4a 10          	lea    0x10(%rdx),%r9
    58ef:	48 89 f0             	mov    %rsi,%rax

	for (i = list->i; i; i = i->next_i) {
    58f2:	4c 8b 40 08          	mov    0x8(%rax),%r8
		tail = &i->next_i;
		i->next = next;
    58f6:	48 89 50 10          	mov    %rdx,0x10(%rax)
		return;

	next_i = next->i;
	tail = &next->i;

	for (i = list->i; i; i = i->next_i) {
    58fa:	4d 85 c0             	test   %r8,%r8
    58fd:	74 05                	je     5904 <safe_list_del+0x47>
    58ff:	4c 89 c0             	mov    %r8,%rax
    5902:	eb ee                	jmp    58f2 <safe_list_del+0x35>
		tail = &i->next_i;
		i->next = next;
	}

	next->i = list->i;
    5904:	48 89 72 10          	mov    %rsi,0x10(%rdx)
	list->i->head = &next->i;
    5908:	48 8b 57 10          	mov    0x10(%rdi),%rdx
	*tail = next_i;
	if (next_i)
    590c:	48 85 c9             	test   %rcx,%rcx
		tail = &i->next_i;
		i->next = next;
	}

	next->i = list->i;
	list->i->head = &next->i;
    590f:	4c 89 0a             	mov    %r9,(%rdx)
	*tail = next_i;
    5912:	48 89 48 08          	mov    %rcx,0x8(%rax)
	if (next_i)
    5916:	74 07                	je     591f <safe_list_del+0x62>

	next_i = next->i;
	tail = &next->i;

	for (i = list->i; i; i = i->next_i) {
		tail = &i->next_i;
    5918:	48 83 c0 08          	add    $0x8,%rax
    591c:	48 89 01             	mov    %rax,(%rcx)
	list->i->head = &next->i;
	*tail = next_i;
	if (next_i)
		next_i->head = tail;

	list->i = NULL;
    591f:	48 c7 47 10 00 00 00 	movq   $0x0,0x10(%rdi)
    5926:	00 
    5927:	c3                   	retq   

0000000000005928 <__runqueue_empty_cb>:
#include <stdio.h>
#include "runqueue.h"

static void
__runqueue_empty_cb(struct uloop_timeout *timeout)
{
    5928:	48 89 f8             	mov    %rdi,%rax
	struct runqueue *q = container_of(timeout, struct runqueue, timeout);

	q->empty_cb(q);
    592b:	48 8d 7f d0          	lea    -0x30(%rdi),%rdi
    592f:	ff 60 40             	jmpq   *0x40(%rax)

0000000000005932 <__runqueue_start_next>:
	INIT_SAFE_LIST(&q->tasks_active);
	INIT_SAFE_LIST(&q->tasks_inactive);
}

static void __runqueue_start_next(struct uloop_timeout *timeout)
{
    5932:	41 55                	push   %r13
    5934:	41 54                	push   %r12
	struct runqueue *q = container_of(timeout, struct runqueue, timeout);
    5936:	4c 8d 67 d0          	lea    -0x30(%rdi),%r12
	INIT_SAFE_LIST(&q->tasks_active);
	INIT_SAFE_LIST(&q->tasks_inactive);
}

static void __runqueue_start_next(struct uloop_timeout *timeout)
{
    593a:	55                   	push   %rbp
    593b:	53                   	push   %rbx
    593c:	48 89 fb             	mov    %rdi,%rbx
    593f:	51                   	push   %rcx

	do {
		if (q->stopped)
			break;

		if (list_empty(&q->tasks_inactive.list))
    5940:	4d 8d 6c 24 18       	lea    0x18(%r12),%r13
{
	struct runqueue *q = container_of(timeout, struct runqueue, timeout);
	struct runqueue_task *t;

	do {
		if (q->stopped)
    5945:	80 7b 38 00          	cmpb   $0x0,0x38(%rbx)
    5949:	75 4e                	jne    5999 <__runqueue_start_next+0x67>
}

static inline bool
list_empty(const struct list_head *head)
{
	return (head->next == head);
    594b:	48 8b 6b e8          	mov    -0x18(%rbx),%rbp
			break;

		if (list_empty(&q->tasks_inactive.list))
    594f:	4c 39 ed             	cmp    %r13,%rbp
    5952:	74 45                	je     5999 <__runqueue_start_next+0x67>
			break;

		if (q->max_running_tasks && q->running_tasks >= q->max_running_tasks)
    5954:	8b 43 34             	mov    0x34(%rbx),%eax
    5957:	85 c0                	test   %eax,%eax
    5959:	74 05                	je     5960 <__runqueue_start_next+0x2e>
    595b:	3b 43 30             	cmp    0x30(%rbx),%eax
    595e:	7e 39                	jle    5999 <__runqueue_start_next+0x67>
			break;

		t = list_first_entry(&q->tasks_inactive.list, struct runqueue_task, list.list);
		safe_list_del(&t->list);
    5960:	48 89 ef             	mov    %rbp,%rdi
    5963:	e8 58 cb ff ff       	callq  24c0 <safe_list_del@plt>
		safe_list_add(&t->list, &q->tasks_active);
    5968:	4c 89 e6             	mov    %r12,%rsi
    596b:	48 89 ef             	mov    %rbp,%rdi
    596e:	e8 5d cc ff ff       	callq  25d0 <safe_list_add@plt>
		t->running = true;
		q->running_tasks++;
		if (t->run_timeout)
    5973:	8b 75 60             	mov    0x60(%rbp),%esi
			break;

		t = list_first_entry(&q->tasks_inactive.list, struct runqueue_task, list.list);
		safe_list_del(&t->list);
		safe_list_add(&t->list, &q->tasks_active);
		t->running = true;
    5976:	c6 45 6d 01          	movb   $0x1,0x6d(%rbp)
		q->running_tasks++;
    597a:	ff 43 30             	incl   0x30(%rbx)
		if (t->run_timeout)
    597d:	85 f6                	test   %esi,%esi
    597f:	74 09                	je     598a <__runqueue_start_next+0x58>
			uloop_timeout_set(&t->timeout, t->run_timeout);
    5981:	48 8d 7d 30          	lea    0x30(%rbp),%rdi
    5985:	e8 a6 cb ff ff       	callq  2530 <uloop_timeout_set@plt>
		t->type->run(q, t);
    598a:	48 8b 45 18          	mov    0x18(%rbp),%rax
    598e:	48 89 ee             	mov    %rbp,%rsi
    5991:	4c 89 e7             	mov    %r12,%rdi
    5994:	ff 50 08             	callq  *0x8(%rax)
	} while (1);
    5997:	eb ac                	jmp    5945 <__runqueue_start_next+0x13>

	if (!q->empty &&
    5999:	80 7b 39 00          	cmpb   $0x0,0x39(%rbx)
    599d:	75 3a                	jne    59d9 <__runqueue_start_next+0xa7>
    599f:	4c 39 63 d0          	cmp    %r12,-0x30(%rbx)
    59a3:	75 34                	jne    59d9 <__runqueue_start_next+0xa7>
	    list_empty(&q->tasks_active.list) &&
	    list_empty(&q->tasks_inactive.list)) {
    59a5:	49 83 c4 18          	add    $0x18,%r12
			uloop_timeout_set(&t->timeout, t->run_timeout);
		t->type->run(q, t);
	} while (1);

	if (!q->empty &&
	    list_empty(&q->tasks_active.list) &&
    59a9:	4c 39 63 e8          	cmp    %r12,-0x18(%rbx)
    59ad:	75 2a                	jne    59d9 <__runqueue_start_next+0xa7>
	    list_empty(&q->tasks_inactive.list)) {
		q->empty = true;
		if (q->empty_cb) {
    59af:	48 83 7b 40 00       	cmpq   $0x0,0x40(%rbx)
	} while (1);

	if (!q->empty &&
	    list_empty(&q->tasks_active.list) &&
	    list_empty(&q->tasks_inactive.list)) {
		q->empty = true;
    59b4:	c6 43 39 01          	movb   $0x1,0x39(%rbx)
		if (q->empty_cb) {
    59b8:	74 1f                	je     59d9 <__runqueue_start_next+0xa7>
			q->timeout.cb = __runqueue_empty_cb;
    59ba:	48 8d 05 67 ff ff ff 	lea    -0x99(%rip),%rax        # 5928 <__runqueue_empty_cb>
			uloop_timeout_set(&q->timeout, 1);
    59c1:	48 89 df             	mov    %rbx,%rdi
    59c4:	be 01 00 00 00       	mov    $0x1,%esi
	if (!q->empty &&
	    list_empty(&q->tasks_active.list) &&
	    list_empty(&q->tasks_inactive.list)) {
		q->empty = true;
		if (q->empty_cb) {
			q->timeout.cb = __runqueue_empty_cb;
    59c9:	48 89 43 18          	mov    %rax,0x18(%rbx)
			uloop_timeout_set(&q->timeout, 1);
		}
	}
}
    59cd:	5a                   	pop    %rdx
    59ce:	5b                   	pop    %rbx
    59cf:	5d                   	pop    %rbp
    59d0:	41 5c                	pop    %r12
    59d2:	41 5d                	pop    %r13
	    list_empty(&q->tasks_active.list) &&
	    list_empty(&q->tasks_inactive.list)) {
		q->empty = true;
		if (q->empty_cb) {
			q->timeout.cb = __runqueue_empty_cb;
			uloop_timeout_set(&q->timeout, 1);
    59d4:	e9 57 cb ff ff       	jmpq   2530 <uloop_timeout_set@plt>
		}
	}
}
    59d9:	58                   	pop    %rax
    59da:	5b                   	pop    %rbx
    59db:	5d                   	pop    %rbp
    59dc:	41 5c                	pop    %r12
    59de:	41 5d                	pop    %r13
    59e0:	c3                   	retq   

00000000000059e1 <runqueue_process_cancel_cb>:
void runqueue_process_cancel_cb(struct runqueue *q, struct runqueue_task *t, int type)
{
	struct runqueue_process *p = container_of(t, struct runqueue_process, task);

	if (!type)
		type = SIGTERM;
    59e1:	85 d2                	test   %edx,%edx
    59e3:	b8 0f 00 00 00       	mov    $0xf,%eax

	kill(p->proc.pid, type);
    59e8:	8b be 90 00 00 00    	mov    0x90(%rsi),%edi
void runqueue_process_cancel_cb(struct runqueue *q, struct runqueue_task *t, int type)
{
	struct runqueue_process *p = container_of(t, struct runqueue_process, task);

	if (!type)
		type = SIGTERM;
    59ee:	0f 44 d0             	cmove  %eax,%edx

	kill(p->proc.pid, type);
    59f1:	89 d6                	mov    %edx,%esi
    59f3:	e9 c8 cb ff ff       	jmpq   25c0 <kill@plt>

00000000000059f8 <runqueue_process_kill_cb>:
}

void runqueue_process_kill_cb(struct runqueue *q, struct runqueue_task *t)
{
    59f8:	53                   	push   %rbx
	struct runqueue_process *p = container_of(t, struct runqueue_process, task);

	uloop_process_delete(&p->proc);
    59f9:	48 8d 7e 70          	lea    0x70(%rsi),%rdi

	kill(p->proc.pid, type);
}

void runqueue_process_kill_cb(struct runqueue *q, struct runqueue_task *t)
{
    59fd:	48 89 f3             	mov    %rsi,%rbx
	struct runqueue_process *p = container_of(t, struct runqueue_process, task);

	uloop_process_delete(&p->proc);
    5a00:	e8 6b ca ff ff       	callq  2470 <uloop_process_delete@plt>
	kill(p->proc.pid, SIGKILL);
    5a05:	8b bb 90 00 00 00    	mov    0x90(%rbx),%edi
    5a0b:	be 09 00 00 00       	mov    $0x9,%esi
}
    5a10:	5b                   	pop    %rbx
void runqueue_process_kill_cb(struct runqueue *q, struct runqueue_task *t)
{
	struct runqueue_process *p = container_of(t, struct runqueue_process, task);

	uloop_process_delete(&p->proc);
	kill(p->proc.pid, SIGKILL);
    5a11:	e9 aa cb ff ff       	jmpq   25c0 <kill@plt>

0000000000005a16 <_runqueue_task_add>:

static void _runqueue_task_add(struct runqueue *q, struct runqueue_task *t, bool running, bool first)
{
	struct safe_list *head;

	if (t->queued)
    5a16:	80 7e 6c 00          	cmpb   $0x0,0x6c(%rsi)
    5a1a:	0f 85 93 00 00 00    	jne    5ab3 <_runqueue_task_add+0x9d>
	else
		runqueue_task_cancel(t, t->cancel_type);
}

static void _runqueue_task_add(struct runqueue *q, struct runqueue_task *t, bool running, bool first)
{
    5a20:	41 54                	push   %r12
    5a22:	55                   	push   %rbp
    5a23:	48 89 f5             	mov    %rsi,%rbp
    5a26:	53                   	push   %rbx
	struct safe_list *head;

	if (t->queued)
		return;

	if (!t->type->run && !running) {
    5a27:	48 8b 46 18          	mov    0x18(%rsi),%rax
    5a2b:	48 83 78 08 00       	cmpq   $0x0,0x8(%rax)
    5a30:	75 1e                	jne    5a50 <_runqueue_task_add+0x3a>
    5a32:	84 d2                	test   %dl,%dl
    5a34:	75 22                	jne    5a58 <_runqueue_task_add+0x42>
		fprintf(stderr, "BUG: inactive task added without run() callback\n");
    5a36:	48 8b 05 ab 25 20 00 	mov    0x2025ab(%rip),%rax        # 207fe8 <_DYNAMIC+0x208>

# ifdef __va_arg_pack
__fortify_function int
fprintf (FILE *__restrict __stream, const char *__restrict __fmt, ...)
{
  return __fprintf_chk (__stream, __USE_FORTIFY_LEVEL - 1, __fmt,
    5a3d:	48 8d 3d bc 06 00 00 	lea    0x6bc(%rip),%rdi        # 6100 <blob_type+0x20>
	t->queued = true;
	t->running = running;
	q->empty = false;

	runqueue_start_next(q);
}
    5a44:	5b                   	pop    %rbx
    5a45:	5d                   	pop    %rbp
    5a46:	41 5c                	pop    %r12
    5a48:	48 8b 30             	mov    (%rax),%rsi
    5a4b:	e9 80 ca ff ff       	jmpq   24d0 <fputs@plt>
	if (!t->type->run && !running) {
		fprintf(stderr, "BUG: inactive task added without run() callback\n");
		return;
	}

	if (running) {
    5a50:	84 d2                	test   %dl,%dl
		q->running_tasks++;
		head = &q->tasks_active;
	} else {
		head = &q->tasks_inactive;
    5a52:	48 8d 77 18          	lea    0x18(%rdi),%rsi
	if (!t->type->run && !running) {
		fprintf(stderr, "BUG: inactive task added without run() callback\n");
		return;
	}

	if (running) {
    5a56:	74 06                	je     5a5e <_runqueue_task_add+0x48>
		q->running_tasks++;
    5a58:	ff 47 60             	incl   0x60(%rdi)
		head = &q->tasks_active;
    5a5b:	48 89 fe             	mov    %rdi,%rsi
	} else {
		head = &q->tasks_inactive;
	}

	t->timeout.cb = __runqueue_task_timeout;
    5a5e:	48 8d 05 00 02 00 00 	lea    0x200(%rip),%rax        # 5c65 <__runqueue_task_timeout>
	t->q = q;
	if (first)
    5a65:	84 c9                	test   %cl,%cl
    5a67:	48 89 fb             	mov    %rdi,%rbx
	} else {
		head = &q->tasks_inactive;
	}

	t->timeout.cb = __runqueue_task_timeout;
	t->q = q;
    5a6a:	48 89 7d 20          	mov    %rdi,0x20(%rbp)
    5a6e:	41 89 d4             	mov    %edx,%r12d
	if (first)
		safe_list_add_first(&t->list, head);
    5a71:	48 89 ef             	mov    %rbp,%rdi
		head = &q->tasks_active;
	} else {
		head = &q->tasks_inactive;
	}

	t->timeout.cb = __runqueue_task_timeout;
    5a74:	48 89 45 48          	mov    %rax,0x48(%rbp)
	t->q = q;
	if (first)
    5a78:	74 07                	je     5a81 <_runqueue_task_add+0x6b>
		safe_list_add_first(&t->list, head);
    5a7a:	e8 31 c9 ff ff       	callq  23b0 <safe_list_add_first@plt>
    5a7f:	eb 05                	jmp    5a86 <_runqueue_task_add+0x70>
	else
		safe_list_add(&t->list, head);
    5a81:	e8 4a cb ff ff       	callq  25d0 <safe_list_add@plt>
static void runqueue_start_next(struct runqueue *q)
{
	if (q->empty)
		return;

	q->timeout.cb = __runqueue_start_next;
    5a86:	48 8d 05 a5 fe ff ff 	lea    -0x15b(%rip),%rax        # 5932 <__runqueue_start_next>
	t->q = q;
	if (first)
		safe_list_add_first(&t->list, head);
	else
		safe_list_add(&t->list, head);
	t->cancelled = false;
    5a8d:	c6 45 6e 00          	movb   $0x0,0x6e(%rbp)
	t->queued = true;
    5a91:	c6 45 6c 01          	movb   $0x1,0x6c(%rbp)
	t->running = running;
    5a95:	44 88 65 6d          	mov    %r12b,0x6d(%rbp)
{
	if (q->empty)
		return;

	q->timeout.cb = __runqueue_start_next;
	uloop_timeout_set(&q->timeout, 1);
    5a99:	48 8d 7b 30          	lea    0x30(%rbx),%rdi
	else
		safe_list_add(&t->list, head);
	t->cancelled = false;
	t->queued = true;
	t->running = running;
	q->empty = false;
    5a9d:	c6 43 69 00          	movb   $0x0,0x69(%rbx)
static void runqueue_start_next(struct runqueue *q)
{
	if (q->empty)
		return;

	q->timeout.cb = __runqueue_start_next;
    5aa1:	48 89 43 48          	mov    %rax,0x48(%rbx)
	uloop_timeout_set(&q->timeout, 1);
    5aa5:	be 01 00 00 00       	mov    $0x1,%esi
	t->queued = true;
	t->running = running;
	q->empty = false;

	runqueue_start_next(q);
}
    5aaa:	5b                   	pop    %rbx
    5aab:	5d                   	pop    %rbp
    5aac:	41 5c                	pop    %r12
{
	if (q->empty)
		return;

	q->timeout.cb = __runqueue_start_next;
	uloop_timeout_set(&q->timeout, 1);
    5aae:	e9 7d ca ff ff       	jmpq   2530 <uloop_timeout_set@plt>
    5ab3:	c3                   	retq   

0000000000005ab4 <runqueue_start_next>:
	}
}

static void runqueue_start_next(struct runqueue *q)
{
	if (q->empty)
    5ab4:	80 7f 69 00          	cmpb   $0x0,0x69(%rdi)
    5ab8:	75 19                	jne    5ad3 <runqueue_start_next+0x1f>
		return;

	q->timeout.cb = __runqueue_start_next;
    5aba:	48 8d 05 71 fe ff ff 	lea    -0x18f(%rip),%rax        # 5932 <__runqueue_start_next>
	uloop_timeout_set(&q->timeout, 1);
    5ac1:	48 83 c7 30          	add    $0x30,%rdi
    5ac5:	be 01 00 00 00       	mov    $0x1,%esi
static void runqueue_start_next(struct runqueue *q)
{
	if (q->empty)
		return;

	q->timeout.cb = __runqueue_start_next;
    5aca:	48 89 47 18          	mov    %rax,0x18(%rdi)
	uloop_timeout_set(&q->timeout, 1);
    5ace:	e9 5d ca ff ff       	jmpq   2530 <uloop_timeout_set@plt>
    5ad3:	c3                   	retq   

0000000000005ad4 <runqueue_init>:
}

void runqueue_init(struct runqueue *q)
{
	INIT_SAFE_LIST(&q->tasks_active);
	INIT_SAFE_LIST(&q->tasks_inactive);
    5ad4:	48 8d 47 18          	lea    0x18(%rdi),%rax
#define LIST_HEAD(name)	struct list_head name = LIST_HEAD_INIT(name)

static inline void
INIT_LIST_HEAD(struct list_head *list)
{
	list->next = list->prev = list;
    5ad8:	48 89 7f 08          	mov    %rdi,0x8(%rdi)
    5adc:	48 89 3f             	mov    %rdi,(%rdi)
	q->empty_cb(q);
}

void runqueue_init(struct runqueue *q)
{
	INIT_SAFE_LIST(&q->tasks_active);
    5adf:	48 c7 47 10 00 00 00 	movq   $0x0,0x10(%rdi)
    5ae6:	00 
	INIT_SAFE_LIST(&q->tasks_inactive);
    5ae7:	48 c7 47 28 00 00 00 	movq   $0x0,0x28(%rdi)
    5aee:	00 
    5aef:	48 89 47 20          	mov    %rax,0x20(%rdi)
    5af3:	48 89 47 18          	mov    %rax,0x18(%rdi)
    5af7:	c3                   	retq   

0000000000005af8 <runqueue_cancel_active>:
	return 0;
}

void runqueue_cancel_active(struct runqueue *q)
{
	safe_list_for_each(&q->tasks_active, __runqueue_cancel, NULL);
    5af8:	48 8d 35 f1 00 00 00 	lea    0xf1(%rip),%rsi        # 5bf0 <__runqueue_cancel>
    5aff:	31 d2                	xor    %edx,%edx
    5b01:	e9 3a c8 ff ff       	jmpq   2340 <safe_list_for_each@plt>

0000000000005b06 <runqueue_cancel_pending>:
}

void runqueue_cancel_pending(struct runqueue *q)
{
	safe_list_for_each(&q->tasks_inactive, __runqueue_cancel, NULL);
    5b06:	48 8d 35 e3 00 00 00 	lea    0xe3(%rip),%rsi        # 5bf0 <__runqueue_cancel>
    5b0d:	48 83 c7 18          	add    $0x18,%rdi
    5b11:	31 d2                	xor    %edx,%edx
    5b13:	e9 28 c8 ff ff       	jmpq   2340 <safe_list_for_each@plt>

0000000000005b18 <runqueue_cancel>:
}

void runqueue_cancel(struct runqueue *q)
{
    5b18:	53                   	push   %rbx
    5b19:	48 89 fb             	mov    %rdi,%rbx
	runqueue_cancel_pending(q);
    5b1c:	e8 ef cb ff ff       	callq  2710 <runqueue_cancel_pending@plt>
	runqueue_cancel_active(q);
    5b21:	48 89 df             	mov    %rbx,%rdi
}
    5b24:	5b                   	pop    %rbx
}

void runqueue_cancel(struct runqueue *q)
{
	runqueue_cancel_pending(q);
	runqueue_cancel_active(q);
    5b25:	e9 36 c9 ff ff       	jmpq   2460 <runqueue_cancel_active@plt>

0000000000005b2a <runqueue_task_add>:
	runqueue_start_next(q);
}

void runqueue_task_add(struct runqueue *q, struct runqueue_task *t, bool running)
{
	_runqueue_task_add(q, t, running, 0);
    5b2a:	0f b6 d2             	movzbl %dl,%edx
    5b2d:	31 c9                	xor    %ecx,%ecx
    5b2f:	e9 e2 fe ff ff       	jmpq   5a16 <_runqueue_task_add>

0000000000005b34 <runqueue_task_add_first>:
}

void runqueue_task_add_first(struct runqueue *q, struct runqueue_task *t, bool running)
{
	_runqueue_task_add(q, t, running, 1);
    5b34:	0f b6 d2             	movzbl %dl,%edx
    5b37:	b9 01 00 00 00       	mov    $0x1,%ecx
    5b3c:	e9 d5 fe ff ff       	jmpq   5a16 <_runqueue_task_add>

0000000000005b41 <runqueue_stop>:
	runqueue_start_next(q);
}

void runqueue_stop(struct runqueue *q)
{
	q->stopped = true;
    5b41:	c6 47 68 01          	movb   $0x1,0x68(%rdi)
    5b45:	c3                   	retq   

0000000000005b46 <runqueue_resume>:
}

void runqueue_resume(struct runqueue *q)
{
	q->stopped = false;
    5b46:	c6 47 68 00          	movb   $0x0,0x68(%rdi)
	runqueue_start_next(q);
    5b4a:	e9 65 ff ff ff       	jmpq   5ab4 <runqueue_start_next>

0000000000005b4f <runqueue_task_complete>:

void runqueue_task_complete(struct runqueue_task *t)
{
	struct runqueue *q = t->q;

	if (!t->queued)
    5b4f:	80 7f 6c 00          	cmpb   $0x0,0x6c(%rdi)
    5b53:	74 4d                	je     5ba2 <runqueue_task_complete+0x53>
	q->stopped = false;
	runqueue_start_next(q);
}

void runqueue_task_complete(struct runqueue_task *t)
{
    5b55:	55                   	push   %rbp
    5b56:	53                   	push   %rbx
    5b57:	52                   	push   %rdx
	struct runqueue *q = t->q;

	if (!t->queued)
		return;

	if (t->running)
    5b58:	80 7f 6d 00          	cmpb   $0x0,0x6d(%rdi)
	runqueue_start_next(q);
}

void runqueue_task_complete(struct runqueue_task *t)
{
	struct runqueue *q = t->q;
    5b5c:	48 8b 6f 20          	mov    0x20(%rdi),%rbp

	if (!t->queued)
		return;

	if (t->running)
    5b60:	74 03                	je     5b65 <runqueue_task_complete+0x16>
		t->q->running_tasks--;
    5b62:	ff 4d 60             	decl   0x60(%rbp)
    5b65:	48 89 fb             	mov    %rdi,%rbx

	uloop_timeout_cancel(&t->timeout);
    5b68:	48 8d 7f 30          	lea    0x30(%rdi),%rdi
    5b6c:	e8 ef cb ff ff       	callq  2760 <uloop_timeout_cancel@plt>

	safe_list_del(&t->list);
    5b71:	48 89 df             	mov    %rbx,%rdi
    5b74:	e8 47 c9 ff ff       	callq  24c0 <safe_list_del@plt>
	t->queued = false;
	t->running = false;
	t->cancelled = false;
	if (t->complete)
    5b79:	48 8b 43 28          	mov    0x28(%rbx),%rax
		t->q->running_tasks--;

	uloop_timeout_cancel(&t->timeout);

	safe_list_del(&t->list);
	t->queued = false;
    5b7d:	c6 43 6c 00          	movb   $0x0,0x6c(%rbx)
	t->running = false;
    5b81:	c6 43 6d 00          	movb   $0x0,0x6d(%rbx)
	t->cancelled = false;
    5b85:	c6 43 6e 00          	movb   $0x0,0x6e(%rbx)
	if (t->complete)
    5b89:	48 85 c0             	test   %rax,%rax
    5b8c:	74 08                	je     5b96 <runqueue_task_complete+0x47>
		t->complete(q, t);
    5b8e:	48 89 de             	mov    %rbx,%rsi
    5b91:	48 89 ef             	mov    %rbp,%rdi
    5b94:	ff d0                	callq  *%rax
	runqueue_start_next(t->q);
    5b96:	48 8b 7b 20          	mov    0x20(%rbx),%rdi
}
    5b9a:	58                   	pop    %rax
    5b9b:	5b                   	pop    %rbx
    5b9c:	5d                   	pop    %rbp
	t->queued = false;
	t->running = false;
	t->cancelled = false;
	if (t->complete)
		t->complete(q, t);
	runqueue_start_next(t->q);
    5b9d:	e9 12 ff ff ff       	jmpq   5ab4 <runqueue_start_next>
    5ba2:	c3                   	retq   

0000000000005ba3 <runqueue_task_cancel>:
	uloop_timeout_cancel(&q->timeout);
}

void runqueue_task_cancel(struct runqueue_task *t, int type)
{
	if (!t->queued)
    5ba3:	80 7f 6c 00          	cmpb   $0x0,0x6c(%rdi)
    5ba7:	74 46                	je     5bef <runqueue_task_cancel+0x4c>
		return;

	if (!t->running) {
    5ba9:	80 7f 6d 00          	cmpb   $0x0,0x6d(%rdi)
    5bad:	75 05                	jne    5bb4 <runqueue_task_cancel+0x11>
		runqueue_task_complete(t);
    5baf:	e9 4c ca ff ff       	jmpq   2600 <runqueue_task_complete@plt>
	runqueue_cancel_pending(q);
	uloop_timeout_cancel(&q->timeout);
}

void runqueue_task_cancel(struct runqueue_task *t, int type)
{
    5bb4:	55                   	push   %rbp
    5bb5:	53                   	push   %rbx
    5bb6:	89 f5                	mov    %esi,%ebp
    5bb8:	41 50                	push   %r8
		runqueue_task_complete(t);
		return;
	}

	t->cancelled = true;
	if (t->cancel_timeout)
    5bba:	8b 77 64             	mov    0x64(%rdi),%esi
    5bbd:	48 89 fb             	mov    %rdi,%rbx
	if (!t->running) {
		runqueue_task_complete(t);
		return;
	}

	t->cancelled = true;
    5bc0:	c6 47 6e 01          	movb   $0x1,0x6e(%rdi)
	if (t->cancel_timeout)
    5bc4:	85 f6                	test   %esi,%esi
    5bc6:	74 09                	je     5bd1 <runqueue_task_cancel+0x2e>
		uloop_timeout_set(&t->timeout, t->cancel_timeout);
    5bc8:	48 8d 7f 30          	lea    0x30(%rdi),%rdi
    5bcc:	e8 5f c9 ff ff       	callq  2530 <uloop_timeout_set@plt>
	if (t->type->cancel)
    5bd1:	48 8b 43 18          	mov    0x18(%rbx),%rax
    5bd5:	48 8b 40 10          	mov    0x10(%rax),%rax
    5bd9:	48 85 c0             	test   %rax,%rax
    5bdc:	74 0e                	je     5bec <runqueue_task_cancel+0x49>
		t->type->cancel(t->q, t, type);
    5bde:	48 8b 7b 20          	mov    0x20(%rbx),%rdi
    5be2:	89 ea                	mov    %ebp,%edx
    5be4:	48 89 de             	mov    %rbx,%rsi
}
    5be7:	59                   	pop    %rcx
    5be8:	5b                   	pop    %rbx
    5be9:	5d                   	pop    %rbp

	t->cancelled = true;
	if (t->cancel_timeout)
		uloop_timeout_set(&t->timeout, t->cancel_timeout);
	if (t->type->cancel)
		t->type->cancel(t->q, t, type);
    5bea:	ff e0                	jmpq   *%rax
}
    5bec:	58                   	pop    %rax
    5bed:	5b                   	pop    %rbx
    5bee:	5d                   	pop    %rbp
    5bef:	c3                   	retq   

0000000000005bf0 <__runqueue_cancel>:
	q->timeout.cb = __runqueue_start_next;
	uloop_timeout_set(&q->timeout, 1);
}

static int __runqueue_cancel(void *ctx, struct safe_list *list)
{
    5bf0:	50                   	push   %rax
    5bf1:	48 89 f7             	mov    %rsi,%rdi
	struct runqueue_task *t;

	t = container_of(list, struct runqueue_task, list);
	runqueue_task_cancel(t, 0);
    5bf4:	31 f6                	xor    %esi,%esi
    5bf6:	e8 a5 c8 ff ff       	callq  24a0 <runqueue_task_cancel@plt>

	return 0;
}
    5bfb:	31 c0                	xor    %eax,%eax
    5bfd:	5a                   	pop    %rdx
    5bfe:	c3                   	retq   

0000000000005bff <runqueue_task_kill>:
void runqueue_task_kill(struct runqueue_task *t)
{
	struct runqueue *q = t->q;
	bool running = t->running;

	if (!t->queued)
    5bff:	80 7f 6c 00          	cmpb   $0x0,0x6c(%rdi)
    5c03:	74 3a                	je     5c3f <runqueue_task_kill+0x40>
{
	_runqueue_task_add(q, t, running, 1);
}

void runqueue_task_kill(struct runqueue_task *t)
{
    5c05:	41 54                	push   %r12
    5c07:	55                   	push   %rbp
    5c08:	53                   	push   %rbx
	struct runqueue *q = t->q;
	bool running = t->running;
    5c09:	44 8a 67 6d          	mov    0x6d(%rdi),%r12b
    5c0d:	48 89 fb             	mov    %rdi,%rbx
	_runqueue_task_add(q, t, running, 1);
}

void runqueue_task_kill(struct runqueue_task *t)
{
	struct runqueue *q = t->q;
    5c10:	48 8b 6f 20          	mov    0x20(%rdi),%rbp
	bool running = t->running;

	if (!t->queued)
		return;

	runqueue_task_complete(t);
    5c14:	e8 e7 c9 ff ff       	callq  2600 <runqueue_task_complete@plt>
	if (running && t->type->kill)
    5c19:	45 84 e4             	test   %r12b,%r12b
    5c1c:	74 15                	je     5c33 <runqueue_task_kill+0x34>
    5c1e:	48 8b 43 18          	mov    0x18(%rbx),%rax
    5c22:	48 8b 40 18          	mov    0x18(%rax),%rax
    5c26:	48 85 c0             	test   %rax,%rax
    5c29:	74 08                	je     5c33 <runqueue_task_kill+0x34>
		t->type->kill(q, t);
    5c2b:	48 89 de             	mov    %rbx,%rsi
    5c2e:	48 89 ef             	mov    %rbp,%rdi
    5c31:	ff d0                	callq  *%rax

	runqueue_start_next(q);
}
    5c33:	5b                   	pop    %rbx

	runqueue_task_complete(t);
	if (running && t->type->kill)
		t->type->kill(q, t);

	runqueue_start_next(q);
    5c34:	48 89 ef             	mov    %rbp,%rdi
}
    5c37:	5d                   	pop    %rbp
    5c38:	41 5c                	pop    %r12

	runqueue_task_complete(t);
	if (running && t->type->kill)
		t->type->kill(q, t);

	runqueue_start_next(q);
    5c3a:	e9 75 fe ff ff       	jmpq   5ab4 <runqueue_start_next>
    5c3f:	c3                   	retq   

0000000000005c40 <runqueue_kill>:
	runqueue_cancel_pending(q);
	runqueue_cancel_active(q);
}

void runqueue_kill(struct runqueue *q)
{
    5c40:	53                   	push   %rbx
    5c41:	48 89 fb             	mov    %rdi,%rbx
}

static inline bool
list_empty(const struct list_head *head)
{
	return (head->next == head);
    5c44:	48 8b 3b             	mov    (%rbx),%rdi
	struct runqueue_task *t;

	while (!list_empty(&q->tasks_active.list)) {
    5c47:	48 39 fb             	cmp    %rdi,%rbx
    5c4a:	74 07                	je     5c53 <runqueue_kill+0x13>
		t = list_first_entry(&q->tasks_active.list, struct runqueue_task, list.list);
		runqueue_task_kill(t);
    5c4c:	e8 af ca ff ff       	callq  2700 <runqueue_task_kill@plt>
    5c51:	eb f1                	jmp    5c44 <runqueue_kill+0x4>
	}
	runqueue_cancel_pending(q);
    5c53:	48 89 df             	mov    %rbx,%rdi
    5c56:	e8 b5 ca ff ff       	callq  2710 <runqueue_cancel_pending@plt>
	uloop_timeout_cancel(&q->timeout);
    5c5b:	48 8d 7b 30          	lea    0x30(%rbx),%rdi
}
    5c5f:	5b                   	pop    %rbx
	while (!list_empty(&q->tasks_active.list)) {
		t = list_first_entry(&q->tasks_active.list, struct runqueue_task, list.list);
		runqueue_task_kill(t);
	}
	runqueue_cancel_pending(q);
	uloop_timeout_cancel(&q->timeout);
    5c60:	e9 fb ca ff ff       	jmpq   2760 <uloop_timeout_cancel@plt>

0000000000005c65 <__runqueue_task_timeout>:
		t->type->cancel(t->q, t, type);
}

static void
__runqueue_task_timeout(struct uloop_timeout *timeout)
{
    5c65:	48 89 f8             	mov    %rdi,%rax
	struct runqueue_task *t = container_of(timeout, struct runqueue_task, timeout);
    5c68:	48 8d 7f d0          	lea    -0x30(%rdi),%rdi

	if (t->cancelled)
    5c6c:	80 78 3e 00          	cmpb   $0x0,0x3e(%rax)
    5c70:	74 05                	je     5c77 <__runqueue_task_timeout+0x12>
		runqueue_task_kill(t);
    5c72:	e9 89 ca ff ff       	jmpq   2700 <runqueue_task_kill@plt>
	else
		runqueue_task_cancel(t, t->cancel_type);
    5c77:	8b 70 38             	mov    0x38(%rax),%esi
    5c7a:	e9 21 c8 ff ff       	jmpq   24a0 <runqueue_task_cancel@plt>

0000000000005c7f <__runqueue_proc_cb>:
static void
__runqueue_proc_cb(struct uloop_process *p, int ret)
{
	struct runqueue_process *t = container_of(p, struct runqueue_process, proc);

	runqueue_task_complete(&t->task);
    5c7f:	48 83 ef 70          	sub    $0x70,%rdi
    5c83:	e9 78 c9 ff ff       	jmpq   2600 <runqueue_task_complete@plt>

0000000000005c88 <runqueue_process_add>:
	.kill = runqueue_process_kill_cb,
};

void runqueue_process_add(struct runqueue *q, struct runqueue_process *p, pid_t pid)
{
	if (p->proc.pending)
    5c88:	80 be 80 00 00 00 00 	cmpb   $0x0,0x80(%rsi)
    5c8f:	75 55                	jne    5ce6 <runqueue_process_add+0x5e>
	.cancel = runqueue_process_cancel_cb,
	.kill = runqueue_process_kill_cb,
};

void runqueue_process_add(struct runqueue *q, struct runqueue_process *p, pid_t pid)
{
    5c91:	55                   	push   %rbp
    5c92:	53                   	push   %rbx
	if (p->proc.pending)
		return;

	p->proc.pid = pid;
	p->proc.cb = __runqueue_proc_cb;
    5c93:	48 8d 05 e5 ff ff ff 	lea    -0x1b(%rip),%rax        # 5c7f <__runqueue_proc_cb>
	.cancel = runqueue_process_cancel_cb,
	.kill = runqueue_process_kill_cb,
};

void runqueue_process_add(struct runqueue *q, struct runqueue_process *p, pid_t pid)
{
    5c9a:	41 50                	push   %r8
	if (p->proc.pending)
		return;

	p->proc.pid = pid;
	p->proc.cb = __runqueue_proc_cb;
	if (!p->task.type)
    5c9c:	48 83 7e 18 00       	cmpq   $0x0,0x18(%rsi)
void runqueue_process_add(struct runqueue *q, struct runqueue_process *p, pid_t pid)
{
	if (p->proc.pending)
		return;

	p->proc.pid = pid;
    5ca1:	89 96 90 00 00 00    	mov    %edx,0x90(%rsi)
	p->proc.cb = __runqueue_proc_cb;
    5ca7:	48 89 86 88 00 00 00 	mov    %rax,0x88(%rsi)
	if (!p->task.type)
    5cae:	75 0b                	jne    5cbb <runqueue_process_add+0x33>
		p->task.type = &runqueue_proc_type;
    5cb0:	48 8d 05 09 21 20 00 	lea    0x202109(%rip),%rax        # 207dc0 <runqueue_proc_type>
    5cb7:	48 89 46 18          	mov    %rax,0x18(%rsi)
    5cbb:	48 89 fb             	mov    %rdi,%rbx
	uloop_process_add(&p->proc);
    5cbe:	48 8d 7e 70          	lea    0x70(%rsi),%rdi
    5cc2:	48 89 f5             	mov    %rsi,%rbp
    5cc5:	e8 86 c9 ff ff       	callq  2650 <uloop_process_add@plt>
	if (!p->task.running)
    5cca:	80 7d 6d 00          	cmpb   $0x0,0x6d(%rbp)
    5cce:	75 13                	jne    5ce3 <runqueue_process_add+0x5b>
		runqueue_task_add(q, &p->task, true);
}
    5cd0:	59                   	pop    %rcx
	p->proc.cb = __runqueue_proc_cb;
	if (!p->task.type)
		p->task.type = &runqueue_proc_type;
	uloop_process_add(&p->proc);
	if (!p->task.running)
		runqueue_task_add(q, &p->task, true);
    5cd1:	48 89 ee             	mov    %rbp,%rsi
    5cd4:	48 89 df             	mov    %rbx,%rdi
    5cd7:	ba 01 00 00 00       	mov    $0x1,%edx
}
    5cdc:	5b                   	pop    %rbx
    5cdd:	5d                   	pop    %rbp
	p->proc.cb = __runqueue_proc_cb;
	if (!p->task.type)
		p->task.type = &runqueue_proc_type;
	uloop_process_add(&p->proc);
	if (!p->task.running)
		runqueue_task_add(q, &p->task, true);
    5cde:	e9 9d ca ff ff       	jmpq   2780 <runqueue_task_add@plt>
}
    5ce3:	58                   	pop    %rax
    5ce4:	5b                   	pop    %rbx
    5ce5:	5d                   	pop    %rbp
    5ce6:	c3                   	retq   

0000000000005ce7 <md5_hash_block>:
# define FH(b, c, d) (b ^ c ^ d)
# define FI(b, c, d) (c ^ (b | ~d))

/* Hash a single block, 64 bytes long and 4-byte aligned. */
static void md5_hash_block(const void *buffer, md5_ctx_t *ctx)
{
    5ce7:	41 54                	push   %r12
    5ce9:	55                   	push   %rbp
    5cea:	53                   	push   %rbx
    5ceb:	48 83 ec 50          	sub    $0x50,%rsp
		5, 9, 14, 20,
		4, 11, 16, 23,
		6, 10, 15, 21
	};

	uint32_t A = ctx->A;
    5cef:	8b 2e                	mov    (%rsi),%ebp
	uint32_t B = ctx->B;
    5cf1:	8b 5e 04             	mov    0x4(%rsi),%ebx
	uint32_t C = ctx->C;
    5cf4:	44 8b 5e 08          	mov    0x8(%rsi),%r11d
	uint32_t D = ctx->D;
    5cf8:	44 8b 56 0c          	mov    0xc(%rsi),%r10d
# define FH(b, c, d) (b ^ c ^ d)
# define FI(b, c, d) (c ^ (b | ~d))

/* Hash a single block, 64 bytes long and 4-byte aligned. */
static void md5_hash_block(const void *buffer, md5_ctx_t *ctx)
{
    5cfc:	64 48 8b 04 25 28 00 	mov    %fs:0x28,%rax
    5d03:	00 00 
    5d05:	48 89 44 24 48       	mov    %rax,0x48(%rsp)
    5d0a:	31 c0                	xor    %eax,%eax
	const char *ps;
	int i;
	uint32_t temp;

	for (i = 0; i < 16; i++) {
		cwp[i] = SWAP_LE32(words[i]);
    5d0c:	8b 14 07             	mov    (%rdi,%rax,1),%edx
    5d0f:	89 54 04 08          	mov    %edx,0x8(%rsp,%rax,1)
    5d13:	48 83 c0 04          	add    $0x4,%rax
	const char *pp;
	const char *ps;
	int i;
	uint32_t temp;

	for (i = 0; i < 16; i++) {
    5d17:	48 83 f8 40          	cmp    $0x40,%rax
    5d1b:	75 ef                	jne    5d0c <md5_hash_block+0x25>
    5d1d:	45 89 d1             	mov    %r10d,%r9d
    5d20:	45 89 d8             	mov    %r11d,%r8d
    5d23:	41 89 dc             	mov    %ebx,%r12d
    5d26:	89 e9                	mov    %ebp,%ecx
    5d28:	31 d2                	xor    %edx,%edx
	pc = C_array;
	pp = P_array;
	ps = S_array;

	for (i = 0; i < 16; i++) {
		temp = A + FF(B, C, D) + cwp[(int) (*pp++)] + *pc++;
    5d2a:	44 89 c0             	mov    %r8d,%eax
    5d2d:	48 8d 3d 6c 04 00 00 	lea    0x46c(%rip),%rdi        # 61a0 <C_array.4587>
    5d34:	44 31 c8             	xor    %r9d,%eax
    5d37:	44 21 e0             	and    %r12d,%eax
    5d3a:	44 31 c8             	xor    %r9d,%eax
    5d3d:	03 04 97             	add    (%rdi,%rdx,4),%eax
    5d40:	48 8d 3d 19 04 00 00 	lea    0x419(%rip),%rdi        # 6160 <P_array.4588>
    5d47:	48 0f be 3c 17       	movsbq (%rdi,%rdx,1),%rdi
    5d4c:	03 44 bc 08          	add    0x8(%rsp,%rdi,4),%eax
		CYCLIC(temp, ps[i & 3]);
    5d50:	48 8d 3d e9 03 00 00 	lea    0x3e9(%rip),%rdi        # 6140 <S_array.4589>
	pc = C_array;
	pp = P_array;
	ps = S_array;

	for (i = 0; i < 16; i++) {
		temp = A + FF(B, C, D) + cwp[(int) (*pp++)] + *pc++;
    5d57:	01 c8                	add    %ecx,%eax
		CYCLIC(temp, ps[i & 3]);
    5d59:	48 89 d1             	mov    %rdx,%rcx
    5d5c:	48 ff c2             	inc    %rdx
    5d5f:	83 e1 03             	and    $0x3,%ecx
		temp += B;
    5d62:	0f be 0c 0f          	movsbl (%rdi,%rcx,1),%ecx
    5d66:	d3 c0                	rol    %cl,%eax
    5d68:	44 89 c9             	mov    %r9d,%ecx
    5d6b:	44 01 e0             	add    %r12d,%eax

	pc = C_array;
	pp = P_array;
	ps = S_array;

	for (i = 0; i < 16; i++) {
    5d6e:	48 83 fa 10          	cmp    $0x10,%rdx
    5d72:	74 0b                	je     5d7f <md5_hash_block+0x98>
    5d74:	45 89 c1             	mov    %r8d,%r9d
    5d77:	45 89 e0             	mov    %r12d,%r8d
		temp = A + FF(B, C, D) + cwp[(int) (*pp++)] + *pc++;
		CYCLIC(temp, ps[i & 3]);
		temp += B;
    5d7a:	41 89 c4             	mov    %eax,%r12d
    5d7d:	eb ab                	jmp    5d2a <md5_hash_block+0x43>
    5d7f:	31 ff                	xor    %edi,%edi
		B = temp;
	}

	ps += 4;
	for (i = 0; i < 16; i++) {
		temp = A + FG(B, C, D) + cwp[(int) (*pp++)] + *pc++;
    5d81:	89 c2                	mov    %eax,%edx
    5d83:	48 8d 0d 56 04 00 00 	lea    0x456(%rip),%rcx        # 61e0 <C_array.4587+0x40>
    5d8a:	44 31 e2             	xor    %r12d,%edx
    5d8d:	44 21 c2             	and    %r8d,%edx
    5d90:	44 31 e2             	xor    %r12d,%edx
    5d93:	03 14 b9             	add    (%rcx,%rdi,4),%edx
    5d96:	48 8d 0d d3 03 00 00 	lea    0x3d3(%rip),%rcx        # 6170 <P_array.4588+0x10>
    5d9d:	48 0f be 0c 39       	movsbq (%rcx,%rdi,1),%rcx
    5da2:	03 54 8c 08          	add    0x8(%rsp,%rcx,4),%edx
		CYCLIC(temp, ps[i & 3]);
    5da6:	48 89 f9             	mov    %rdi,%rcx
    5da9:	48 ff c7             	inc    %rdi
    5dac:	83 e1 03             	and    $0x3,%ecx
		B = temp;
	}

	ps += 4;
	for (i = 0; i < 16; i++) {
		temp = A + FG(B, C, D) + cwp[(int) (*pp++)] + *pc++;
    5daf:	44 01 ca             	add    %r9d,%edx
		CYCLIC(temp, ps[i & 3]);
    5db2:	4c 8d 0d 8b 03 00 00 	lea    0x38b(%rip),%r9        # 6144 <S_array.4589+0x4>
		temp += B;
    5db9:	41 0f be 0c 09       	movsbl (%r9,%rcx,1),%ecx
    5dbe:	45 89 c1             	mov    %r8d,%r9d
    5dc1:	d3 c2                	rol    %cl,%edx
    5dc3:	01 c2                	add    %eax,%edx
		C = B;
		B = temp;
	}

	ps += 4;
	for (i = 0; i < 16; i++) {
    5dc5:	48 83 ff 10          	cmp    $0x10,%rdi
    5dc9:	74 0a                	je     5dd5 <md5_hash_block+0xee>
    5dcb:	45 89 e0             	mov    %r12d,%r8d
    5dce:	41 89 c4             	mov    %eax,%r12d
		temp = A + FG(B, C, D) + cwp[(int) (*pp++)] + *pc++;
		CYCLIC(temp, ps[i & 3]);
		temp += B;
    5dd1:	89 d0                	mov    %edx,%eax
    5dd3:	eb ac                	jmp    5d81 <md5_hash_block+0x9a>
    5dd5:	45 31 c9             	xor    %r9d,%r9d
		C = B;
		B = temp;
	}
	ps += 4;
	for (i = 0; i < 16; i++) {
		temp = A + FH(B, C, D) + cwp[(int) (*pp++)] + *pc++;
    5dd8:	48 8d 0d 41 04 00 00 	lea    0x441(%rip),%rcx        # 6220 <C_array.4587+0x80>
    5ddf:	89 d7                	mov    %edx,%edi
    5de1:	31 c7                	xor    %eax,%edi
    5de3:	44 31 e7             	xor    %r12d,%edi
    5de6:	42 03 3c 89          	add    (%rcx,%r9,4),%edi
    5dea:	48 8d 0d 8f 03 00 00 	lea    0x38f(%rip),%rcx        # 6180 <P_array.4588+0x20>
    5df1:	4a 0f be 0c 09       	movsbq (%rcx,%r9,1),%rcx
    5df6:	03 7c 8c 08          	add    0x8(%rsp,%rcx,4),%edi
		CYCLIC(temp, ps[i & 3]);
    5dfa:	4c 89 c9             	mov    %r9,%rcx
    5dfd:	49 ff c1             	inc    %r9
    5e00:	83 e1 03             	and    $0x3,%ecx
		C = B;
		B = temp;
	}
	ps += 4;
	for (i = 0; i < 16; i++) {
		temp = A + FH(B, C, D) + cwp[(int) (*pp++)] + *pc++;
    5e03:	44 01 c7             	add    %r8d,%edi
		CYCLIC(temp, ps[i & 3]);
    5e06:	4c 8d 05 3b 03 00 00 	lea    0x33b(%rip),%r8        # 6148 <S_array.4589+0x8>
		temp += B;
    5e0d:	41 0f be 0c 08       	movsbl (%r8,%rcx,1),%ecx
    5e12:	45 89 e0             	mov    %r12d,%r8d
    5e15:	d3 c7                	rol    %cl,%edi
    5e17:	01 d7                	add    %edx,%edi
		D = C;
		C = B;
		B = temp;
	}
	ps += 4;
	for (i = 0; i < 16; i++) {
    5e19:	49 83 f9 10          	cmp    $0x10,%r9
    5e1d:	74 09                	je     5e28 <md5_hash_block+0x141>
    5e1f:	41 89 c4             	mov    %eax,%r12d
    5e22:	89 d0                	mov    %edx,%eax
		temp = A + FH(B, C, D) + cwp[(int) (*pp++)] + *pc++;
		CYCLIC(temp, ps[i & 3]);
		temp += B;
    5e24:	89 fa                	mov    %edi,%edx
    5e26:	eb b0                	jmp    5dd8 <md5_hash_block+0xf1>
    5e28:	45 31 c9             	xor    %r9d,%r9d
		C = B;
		B = temp;
	}
	ps += 4;
	for (i = 0; i < 16; i++) {
		temp = A + FI(B, C, D) + cwp[(int) (*pp++)] + *pc++;
    5e2b:	89 c1                	mov    %eax,%ecx
    5e2d:	4c 8d 05 2c 04 00 00 	lea    0x42c(%rip),%r8        # 6260 <C_array.4587+0xc0>
    5e34:	f7 d1                	not    %ecx
    5e36:	09 f9                	or     %edi,%ecx
    5e38:	31 d1                	xor    %edx,%ecx
    5e3a:	43 03 0c 88          	add    (%r8,%r9,4),%ecx
    5e3e:	4c 8d 05 4b 03 00 00 	lea    0x34b(%rip),%r8        # 6190 <P_array.4588+0x30>
    5e45:	4f 0f be 04 08       	movsbq (%r8,%r9,1),%r8
    5e4a:	42 03 4c 84 08       	add    0x8(%rsp,%r8,4),%ecx
    5e4f:	46 8d 04 21          	lea    (%rcx,%r12,1),%r8d
		CYCLIC(temp, ps[i & 3]);
    5e53:	4c 89 c9             	mov    %r9,%rcx
    5e56:	4c 8d 25 ef 02 00 00 	lea    0x2ef(%rip),%r12        # 614c <S_array.4589+0xc>
    5e5d:	83 e1 03             	and    $0x3,%ecx
    5e60:	49 ff c1             	inc    %r9
		temp += B;
    5e63:	41 0f be 0c 0c       	movsbl (%r12,%rcx,1),%ecx
    5e68:	41 89 c4             	mov    %eax,%r12d
    5e6b:	41 d3 c0             	rol    %cl,%r8d
		D = C;
		C = B;
		B = temp;
	}
	ps += 4;
	for (i = 0; i < 16; i++) {
    5e6e:	49 83 f9 10          	cmp    $0x10,%r9
		temp = A + FI(B, C, D) + cwp[(int) (*pp++)] + *pc++;
		CYCLIC(temp, ps[i & 3]);
		temp += B;
    5e72:	41 8d 0c 38          	lea    (%r8,%rdi,1),%ecx
		D = C;
		C = B;
		B = temp;
	}
	ps += 4;
	for (i = 0; i < 16; i++) {
    5e76:	74 08                	je     5e80 <md5_hash_block+0x199>
    5e78:	89 d0                	mov    %edx,%eax
    5e7a:	89 fa                	mov    %edi,%edx
		temp = A + FI(B, C, D) + cwp[(int) (*pp++)] + *pc++;
		CYCLIC(temp, ps[i & 3]);
		temp += B;
    5e7c:	89 cf                	mov    %ecx,%edi
    5e7e:	eb ab                	jmp    5e2b <md5_hash_block+0x144>
		C = B;
		B = temp;
	}


	ctx->A += A;
    5e80:	01 e8                	add    %ebp,%eax
	ctx->B += B;
    5e82:	01 d9                	add    %ebx,%ecx
	ctx->C += C;
    5e84:	44 01 df             	add    %r11d,%edi
	ctx->D += D;
    5e87:	44 01 d2             	add    %r10d,%edx
		C = B;
		B = temp;
	}


	ctx->A += A;
    5e8a:	89 06                	mov    %eax,(%rsi)
	ctx->B += B;
    5e8c:	89 4e 04             	mov    %ecx,0x4(%rsi)
	ctx->C += C;
	ctx->D += D;
}
    5e8f:	48 8b 44 24 48       	mov    0x48(%rsp),%rax
    5e94:	64 48 33 04 25 28 00 	xor    %fs:0x28,%rax
    5e9b:	00 00 
	}


	ctx->A += A;
	ctx->B += B;
	ctx->C += C;
    5e9d:	89 7e 08             	mov    %edi,0x8(%rsi)
	ctx->D += D;
    5ea0:	89 56 0c             	mov    %edx,0xc(%rsi)
}
    5ea3:	74 05                	je     5eaa <md5_hash_block+0x1c3>
    5ea5:	e8 d6 c5 ff ff       	callq  2480 <__stack_chk_fail@plt>
    5eaa:	48 83 c4 50          	add    $0x50,%rsp
    5eae:	5b                   	pop    %rbx
    5eaf:	5d                   	pop    %rbp
    5eb0:	41 5c                	pop    %r12
    5eb2:	c3                   	retq   

0000000000005eb3 <md5_begin>:
/* Initialize structure containing state of computation.
 * (RFC 1321, 3.3: Step 3)
 */
void md5_begin(md5_ctx_t *ctx)
{
	ctx->A = 0x67452301;
    5eb3:	c7 07 01 23 45 67    	movl   $0x67452301,(%rdi)
	ctx->B = 0xefcdab89;
    5eb9:	c7 47 04 89 ab cd ef 	movl   $0xefcdab89,0x4(%rdi)
	ctx->C = 0x98badcfe;
    5ec0:	c7 47 08 fe dc ba 98 	movl   $0x98badcfe,0x8(%rdi)
	ctx->D = 0x10325476;
    5ec7:	c7 47 0c 76 54 32 10 	movl   $0x10325476,0xc(%rdi)

	ctx->total = 0;
    5ece:	48 c7 47 10 00 00 00 	movq   $0x0,0x10(%rdi)
    5ed5:	00 
	ctx->buflen = 0;
    5ed6:	c7 47 18 00 00 00 00 	movl   $0x0,0x18(%rdi)
    5edd:	c3                   	retq   

0000000000005ede <md5_hash>:
 * with chunks of data that are 4-byte aligned and a multiple of 64 bytes.
 * This function's internal buffer remembers previous data until it has 64
 * bytes worth to pass on.  Call md5_end() to flush this buffer. */

void md5_hash(const void *buffer, size_t len, md5_ctx_t *ctx)
{
    5ede:	41 55                	push   %r13
    5ee0:	41 54                	push   %r12

		// Copy data into aligned buffer.

		if (i > len)
			i = len;
		memcpy(ctx->buffer + ctx->buflen, buf, i);
    5ee2:	4c 8d 6a 1c          	lea    0x1c(%rdx),%r13
 * with chunks of data that are 4-byte aligned and a multiple of 64 bytes.
 * This function's internal buffer remembers previous data until it has 64
 * bytes worth to pass on.  Call md5_end() to flush this buffer. */

void md5_hash(const void *buffer, size_t len, md5_ctx_t *ctx)
{
    5ee6:	55                   	push   %rbp
    5ee7:	53                   	push   %rbx
    5ee8:	49 89 fc             	mov    %rdi,%r12
    5eeb:	51                   	push   %rcx
	char *buf = (char *)buffer;

	/* RFC 1321 specifies the possible length of the file up to 2^64 bits,
	 * Here we only track the number of bytes.  */

	ctx->total += len;
    5eec:	48 01 72 10          	add    %rsi,0x10(%rdx)
 * with chunks of data that are 4-byte aligned and a multiple of 64 bytes.
 * This function's internal buffer remembers previous data until it has 64
 * bytes worth to pass on.  Call md5_end() to flush this buffer. */

void md5_hash(const void *buffer, size_t len, md5_ctx_t *ctx)
{
    5ef0:	48 89 f5             	mov    %rsi,%rbp
    5ef3:	48 89 d3             	mov    %rdx,%rbx

	ctx->total += len;

	// Process all input.

	while (len) {
    5ef6:	48 85 ed             	test   %rbp,%rbp
    5ef9:	74 48                	je     5f43 <md5_hash+0x65>
		unsigned i = 64 - ctx->buflen;
    5efb:	8b 53 18             	mov    0x18(%rbx),%edx
    5efe:	b8 40 00 00 00       	mov    $0x40,%eax
    5f03:	4c 89 e6             	mov    %r12,%rsi
    5f06:	29 d0                	sub    %edx,%eax

		// Copy data into aligned buffer.

		if (i > len)
    5f08:	89 c1                	mov    %eax,%ecx
			i = len;
    5f0a:	48 39 cd             	cmp    %rcx,%rbp
    5f0d:	0f 42 c5             	cmovb  %ebp,%eax
    5f10:	4c 01 ea             	add    %r13,%rdx
		memcpy(ctx->buffer + ctx->buflen, buf, i);
    5f13:	41 89 c0             	mov    %eax,%r8d
    5f16:	48 89 d7             	mov    %rdx,%rdi
    5f19:	4c 89 c1             	mov    %r8,%rcx
		len -= i;
    5f1c:	4c 29 c5             	sub    %r8,%rbp
    5f1f:	f3 a4                	rep movsb %ds:(%rsi),%es:(%rdi)
		ctx->buflen += i;
    5f21:	03 43 18             	add    0x18(%rbx),%eax
		buf += i;
    5f24:	49 89 f4             	mov    %rsi,%r12

		// When buffer fills up, process it.

		if (ctx->buflen == 64) {
    5f27:	83 f8 40             	cmp    $0x40,%eax

		if (i > len)
			i = len;
		memcpy(ctx->buffer + ctx->buflen, buf, i);
		len -= i;
		ctx->buflen += i;
    5f2a:	89 43 18             	mov    %eax,0x18(%rbx)
		buf += i;

		// When buffer fills up, process it.

		if (ctx->buflen == 64) {
    5f2d:	75 c7                	jne    5ef6 <md5_hash+0x18>
			md5_hash_block(ctx->buffer, ctx);
    5f2f:	48 89 de             	mov    %rbx,%rsi
    5f32:	4c 89 ef             	mov    %r13,%rdi
    5f35:	e8 ad fd ff ff       	callq  5ce7 <md5_hash_block>
			ctx->buflen = 0;
    5f3a:	c7 43 18 00 00 00 00 	movl   $0x0,0x18(%rbx)
    5f41:	eb b3                	jmp    5ef6 <md5_hash+0x18>
		}
	}
}
    5f43:	58                   	pop    %rax
    5f44:	5b                   	pop    %rbx
    5f45:	5d                   	pop    %rbp
    5f46:	41 5c                	pop    %r12
    5f48:	41 5d                	pop    %r13
    5f4a:	c3                   	retq   

0000000000005f4b <md5_end>:
 *
 * IMPORTANT: On some systems it is required that RESBUF is correctly
 * aligned for a 32 bits value.
 */
void md5_end(void *resbuf, md5_ctx_t *ctx)
{
    5f4b:	41 54                	push   %r12
    5f4d:	55                   	push   %rbp
	char *buf = ctx->buffer;
    5f4e:	4c 8d 46 1c          	lea    0x1c(%rsi),%r8
 *
 * IMPORTANT: On some systems it is required that RESBUF is correctly
 * aligned for a 32 bits value.
 */
void md5_end(void *resbuf, md5_ctx_t *ctx)
{
    5f52:	53                   	push   %rbx
	char *buf = ctx->buffer;
	int i;

	/* Pad data to block size.  */

	buf[ctx->buflen++] = 0x80;
    5f53:	8b 46 18             	mov    0x18(%rsi),%eax
    {
      __warn_memset_zero_len ();
      return __dest;
    }
#endif
  return __builtin___memset_chk (__dest, __ch, __len, __bos0 (__dest));
    5f56:	b9 80 00 00 00       	mov    $0x80,%ecx
 *
 * IMPORTANT: On some systems it is required that RESBUF is correctly
 * aligned for a 32 bits value.
 */
void md5_end(void *resbuf, md5_ctx_t *ctx)
{
    5f5b:	49 89 fc             	mov    %rdi,%r12
	memset(buf + ctx->buflen, 0, 128 - ctx->buflen);

	/* Put the 64-bit file length in *bits* at the end of the buffer.  */
	ctx->total <<= 3;
	if (ctx->buflen > 56)
		buf += 64;
    5f5e:	48 8d 6e 5c          	lea    0x5c(%rsi),%rbp
 *
 * IMPORTANT: On some systems it is required that RESBUF is correctly
 * aligned for a 32 bits value.
 */
void md5_end(void *resbuf, md5_ctx_t *ctx)
{
    5f62:	48 89 f3             	mov    %rsi,%rbx
	char *buf = ctx->buffer;
	int i;

	/* Pad data to block size.  */

	buf[ctx->buflen++] = 0x80;
    5f65:	8d 50 01             	lea    0x1(%rax),%edx
    5f68:	89 56 18             	mov    %edx,0x18(%rsi)
    5f6b:	c6 44 06 1c 80       	movb   $0x80,0x1c(%rsi,%rax,1)
    5f70:	31 c0                	xor    %eax,%eax
	memset(buf + ctx->buflen, 0, 128 - ctx->buflen);
    5f72:	8b 56 18             	mov    0x18(%rsi),%edx
    5f75:	29 d1                	sub    %edx,%ecx
    5f77:	4c 01 c2             	add    %r8,%rdx
    5f7a:	48 89 d7             	mov    %rdx,%rdi
    5f7d:	f3 aa                	rep stos %al,%es:(%rdi)

	/* Put the 64-bit file length in *bits* at the end of the buffer.  */
	ctx->total <<= 3;
    5f7f:	48 c1 66 10 03       	shlq   $0x3,0x10(%rsi)
	if (ctx->buflen > 56)
		buf += 64;
    5f84:	83 7e 18 39          	cmpl   $0x39,0x18(%rsi)
    5f88:	49 0f 42 e8          	cmovb  %r8,%rbp
    5f8c:	48 8d 45 38          	lea    0x38(%rbp),%rax

	for (i = 0; i < 8; i++)
		buf[56 + i] = ctx->total >> (i*8);
    5f90:	48 8b 53 10          	mov    0x10(%rbx),%rdx
    5f94:	48 ff c0             	inc    %rax
    5f97:	48 d3 ea             	shr    %cl,%rdx
    5f9a:	83 c1 08             	add    $0x8,%ecx
    5f9d:	88 50 ff             	mov    %dl,-0x1(%rax)
	/* Put the 64-bit file length in *bits* at the end of the buffer.  */
	ctx->total <<= 3;
	if (ctx->buflen > 56)
		buf += 64;

	for (i = 0; i < 8; i++)
    5fa0:	83 f9 40             	cmp    $0x40,%ecx
    5fa3:	75 eb                	jne    5f90 <md5_end+0x45>
		buf[56 + i] = ctx->total >> (i*8);

	/* Process last bytes.  */
	if (buf != ctx->buffer)
    5fa5:	4c 39 c5             	cmp    %r8,%rbp
    5fa8:	74 0b                	je     5fb5 <md5_end+0x6a>
		md5_hash_block(ctx->buffer, ctx);
    5faa:	48 89 de             	mov    %rbx,%rsi
    5fad:	4c 89 c7             	mov    %r8,%rdi
    5fb0:	e8 32 fd ff ff       	callq  5ce7 <md5_hash_block>
	md5_hash_block(buf, ctx);
    5fb5:	48 89 de             	mov    %rbx,%rsi
    5fb8:	48 89 ef             	mov    %rbp,%rdi
    5fbb:	e8 27 fd ff ff       	callq  5ce7 <md5_hash_block>
	 * to the wanted ASCII representation of the message digest.
	 *
	 * IMPORTANT: On some systems it is required that RESBUF is correctly
	 * aligned for a 32 bits value.
	 */
	((uint32_t *) resbuf)[0] = SWAP_LE32(ctx->A);
    5fc0:	8b 03                	mov    (%rbx),%eax
    5fc2:	41 89 04 24          	mov    %eax,(%r12)
	((uint32_t *) resbuf)[1] = SWAP_LE32(ctx->B);
    5fc6:	8b 43 04             	mov    0x4(%rbx),%eax
    5fc9:	41 89 44 24 04       	mov    %eax,0x4(%r12)
	((uint32_t *) resbuf)[2] = SWAP_LE32(ctx->C);
    5fce:	8b 43 08             	mov    0x8(%rbx),%eax
    5fd1:	41 89 44 24 08       	mov    %eax,0x8(%r12)
	((uint32_t *) resbuf)[3] = SWAP_LE32(ctx->D);
    5fd6:	8b 43 0c             	mov    0xc(%rbx),%eax
}
    5fd9:	5b                   	pop    %rbx
    5fda:	5d                   	pop    %rbp
	 * aligned for a 32 bits value.
	 */
	((uint32_t *) resbuf)[0] = SWAP_LE32(ctx->A);
	((uint32_t *) resbuf)[1] = SWAP_LE32(ctx->B);
	((uint32_t *) resbuf)[2] = SWAP_LE32(ctx->C);
	((uint32_t *) resbuf)[3] = SWAP_LE32(ctx->D);
    5fdb:	41 89 44 24 0c       	mov    %eax,0xc(%r12)
}
    5fe0:	41 5c                	pop    %r12
    5fe2:	c3                   	retq   

0000000000005fe3 <md5sum>:

int md5sum(char *file, uint32_t *md5)
{
    5fe3:	41 55                	push   %r13
    5fe5:	41 54                	push   %r12
    5fe7:	48 89 fa             	mov    %rdi,%rdx
    5fea:	55                   	push   %rbp
    5feb:	53                   	push   %rbx
    5fec:	48 89 f7             	mov    %rsi,%rdi
    5fef:	b9 04 00 00 00       	mov    $0x4,%ecx
    5ff4:	48 89 f3             	mov    %rsi,%rbx
      if (__OPEN_NEEDS_MODE (__oflag) && __va_arg_pack_len () < 1)
	{
	  __open_missing_mode ();
	  return __open_2 (__path, __oflag);
	}
      return __open_alias (__path, __oflag, __va_arg_pack ());
    5ff7:	31 f6                	xor    %esi,%esi
    5ff9:	48 81 ec b8 01 00 00 	sub    $0x1b8,%rsp
    6000:	64 48 8b 04 25 28 00 	mov    %fs:0x28,%rax
    6007:	00 00 
    6009:	48 89 84 24 a8 01 00 	mov    %rax,0x1a8(%rsp)
    6010:	00 
    6011:	31 c0                	xor    %eax,%eax
    6013:	f3 ab                	rep stos %eax,%es:(%rdi)
    6015:	48 89 d7             	mov    %rdx,%rdi
    6018:	e8 c3 c6 ff ff       	callq  26e0 <open@plt>
    601d:	89 c5                	mov    %eax,%ebp
    601f:	83 c8 ff             	or     $0xffffffff,%eax
	int ret = 0;

	memset(md5, 0, sizeof(*md5) * 4);

	fd = open(file, O_RDONLY);
	if (fd < 0)
    6022:	85 ed                	test   %ebp,%ebp
    6024:	78 5f                	js     6085 <md5sum+0xa2>
		return -1;

	md5_begin(&ctx);
    6026:	4c 8d 64 24 08       	lea    0x8(%rsp),%r12
    602b:	4c 8d ac 24 a8 00 00 	lea    0xa8(%rsp),%r13
    6032:	00 
    6033:	4c 89 e7             	mov    %r12,%rdi
    6036:	e8 e5 c5 ff ff       	callq  2620 <md5_begin@plt>
    603b:	ba 00 01 00 00       	mov    $0x100,%edx
    6040:	4c 89 ee             	mov    %r13,%rsi
    6043:	89 ef                	mov    %ebp,%edi
    6045:	e8 16 c5 ff ff       	callq  2560 <read@plt>
	do {
		len = read(fd, buf, sizeof(buf));
		if (len < 0) {
    604a:	85 c0                	test   %eax,%eax
    604c:	79 0f                	jns    605d <md5sum+0x7a>
			if (errno == EINTR)
    604e:	e8 2d c3 ff ff       	callq  2380 <__errno_location@plt>
    6053:	83 38 04             	cmpl   $0x4,(%rax)
    6056:	74 e3                	je     603b <md5sum+0x58>
				continue;

			ret = -1;
    6058:	83 cb ff             	or     $0xffffffff,%ebx
    605b:	eb 1f                	jmp    607c <md5sum+0x99>
			goto out;
		}
		if (!len)
    605d:	74 10                	je     606f <md5sum+0x8c>
			break;

		md5_hash(buf, len, &ctx);
    605f:	48 63 f0             	movslq %eax,%rsi
    6062:	4c 89 e2             	mov    %r12,%rdx
    6065:	4c 89 ef             	mov    %r13,%rdi
    6068:	e8 d3 c5 ff ff       	callq  2640 <md5_hash@plt>
    606d:	eb cc                	jmp    603b <md5sum+0x58>
	} while(1);

	md5_end(md5, &ctx);
    606f:	48 89 df             	mov    %rbx,%rdi
    6072:	4c 89 e6             	mov    %r12,%rsi
int md5sum(char *file, uint32_t *md5)
{
	char buf[256];
	md5_ctx_t ctx;
	int len, fd;
	int ret = 0;
    6075:	31 db                	xor    %ebx,%ebx
			break;

		md5_hash(buf, len, &ctx);
	} while(1);

	md5_end(md5, &ctx);
    6077:	e8 f4 c6 ff ff       	callq  2770 <md5_end@plt>
out:
	close(fd);
    607c:	89 ef                	mov    %ebp,%edi
    607e:	e8 bd c4 ff ff       	callq  2540 <close@plt>

	return ret;
    6083:	89 d8                	mov    %ebx,%eax
}
    6085:	48 8b 8c 24 a8 01 00 	mov    0x1a8(%rsp),%rcx
    608c:	00 
    608d:	64 48 33 0c 25 28 00 	xor    %fs:0x28,%rcx
    6094:	00 00 
    6096:	74 05                	je     609d <md5sum+0xba>
    6098:	e8 e3 c3 ff ff       	callq  2480 <__stack_chk_fail@plt>
    609d:	48 81 c4 b8 01 00 00 	add    $0x1b8,%rsp
    60a4:	5b                   	pop    %rbx
    60a5:	5d                   	pop    %rbp
    60a6:	41 5c                	pop    %r12
    60a8:	41 5d                	pop    %r13
    60aa:	c3                   	retq   

Disassembly of section .fini:

00000000000060ac <_fini>:
    60ac:	48 83 ec 08          	sub    $0x8,%rsp
    60b0:	48 83 c4 08          	add    $0x8,%rsp
    60b4:	c3                   	retq   
